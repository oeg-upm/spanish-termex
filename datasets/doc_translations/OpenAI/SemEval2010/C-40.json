{
    "id": "C-40",
    "original_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time. They are filled with autonomous, mutable virtual content which is continuously augmented by the users. To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds. In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium. In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability. Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting. We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query. Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments. The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination. We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization. We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future. Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1. INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments. Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side. To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability. In this paper, we mainly focus on the first two requirements. Dynamic extensibility allows regular game-users to deploy their own created content. This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems. Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers. Another important requirement is scalability. Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world. By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported. Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3]. Second Life [4] is the first successfully deployed MMOG system that meets both requirements. To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform. But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5]. In this model, a server continuously transmits both update events and geometry data to every connected user. As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space. One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user. The traditional visibility determination approach, however, has an object popping problem. For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a). As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b). If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience. The visibility calculation for each user not only needs to be accurate, but also fast. This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds. To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing). Our two novel methods represent the main contributions of this work. The organization of this paper is as follows. Section 2 presents related work. Section 3 describes our new view method. In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations. We also discuss its optimization issues. Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments. Finally, we conclude and address future research directions in Section 7. 2. RELATED WORK Visibility determination has been widely explored in the field of 3D graphics. Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline. View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6]. However, these algorithms assume that all the candidate visible objects have been stored locally. If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases. Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5]. Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7]. However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments. On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities. In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users. Here we recognize that such graphics related issues have a very close similarity to spatial database problems. Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments. To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing. The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR). The grid-based partitioning model is a special case of fixed partitioning. Recently, it has been re-discovered since it can be efficient in highly dynamic environments. Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12]. A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism. Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table. Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments. In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely. The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree. SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries. Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently. Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects. As long as any object resides in this region, all the query results are guaranteed to be valid in the system. If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly. Our indexing method is very similar to the above approaches. The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3. OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model. We then propose our own model, and finally we discuss its strengths and limitations. To begin with, we define the terminologies commonly used throughout this paper. Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars. The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities. The spectator entity corresponds to a players viewpoint, but is invisible to other entities. It has no shape and is represented only by a point location. It is designed to allow a game participant to see from a third-person viewpoint. It functions similar to a camera control in the 3D graphics field. It also has a higher degree of mobility than other entities. The avatar represents a normal game user who can freely navigate in the space and interact with other entities. It possesses both features: its own viewpoint and visibility. For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity. The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence. It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility. Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other. To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity. Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area. However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world. The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not. As the user navigates, she continuously searches for all the entities within her AOI. Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model. However, the user-initiated model has a serious object popping problem during navigation. Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely. A large AOI, however, may lead to a significant system degradation. To overcome the object popping problem, we propose a new view model which we call object-initiated view model. All object entities have their own AOI centered at their current location while all spectator entities have no AOI. Every user entity recognizes the objects whose AOIs cover its point location. The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes. A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure. One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view. We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model. To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4. Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time. For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 . Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image. In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4. DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model. Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4. Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting. The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world. Second Life is the classic example of such an approach. A virtual space is partitioned into equal-sized sub-worlds. The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A. As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI. Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure). The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R. Every sub-world is managed by its dedicated server machine. Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities. For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells. Figure 2 shows the 4 × 4 grid enclosed by the dashed lines. Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells. Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2. There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in. This retrieval process is interchangeably called a user (or query) evaluation. Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved. Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell. In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell. Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell. Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell. We also define two data structures for storing and retrieving the tokens: a node and an edge. A node is a data structure that stores ITs of a cell. Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region. An edge is another data structure for two adjacent cells that stores their ATs or DTs. If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE). The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j. The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ). Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10]. To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing. Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query. In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location. For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query. Due to the use of a simple point geometry for entities, this allows for lightweight index updates. Much of the existing work falls into this category. However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead. For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case. One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13]. For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a). Every cell stores IT entities that intersect with its region. Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid. Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures. With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated. In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures. If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M). Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2. Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures. If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1. The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2. Lemma 1. Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information. Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25. To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing. Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated. Generally, this is done through a twostep algorithm [13] that works as follows. The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step). After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user. After all the cells are evaluated, the algorithm starts over. The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations. In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures. Let us assume that the system maintains the row-wise edges. The leftmost node structures are assumed to be obtained in advance. Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges. We repeat this computation until we reach the rightmost cell. Hence, without any column-wise edges we can obtain all the node structures successfully. As a result, we reduce the complexity of the index construction and update by a factor of two. Figure 3(c) illustrates the concept of our row-wise edge indexing method. The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT). The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells. In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2. As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}. E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}. Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}. If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. The above calculation also corresponds to our intuition. P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4. When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged. Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set. Obviously, edge indexing is inefficient for indexing a point geometry. Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement. Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case. In such a situation, we take advantage of using both according to the spatial property of entity extension. In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas. Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation. Let us assume that an edge index is realized with a hash table. Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant. However, the token removal time depends on the expected number of tokens per hash bucket. Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities. Two-table edge indexing is designed to make the token removal overhead constant. First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties. Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq). It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance. It is represented by the number of cell units. structures. If an entity is not moving, its tokens will be placed in a stationary edge structure. Otherwise, it will be placed with a moving edge. Second, all moving edge structures are periodically reconstructed. After the reconstruction, all grid cells are evaluated to compute their visible sets. Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows. As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities. A singly linked list implementation is used for the moving edge structure. 5. ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time. In this analysis, we assume that node and edge structures are implemented with hash tables. For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan. Their processing costs are denoted by Ta, Td, and Ts, respectively. A token scan operation reads the tokens in a hash bucket sequentially. It is extensively used during cell evaluations. Ts and Td are a function of the number of tokens in the bucket while Ta is constant. For the purpose of analysis, we define two random variables. One variable, denoted by mo, represents the side length of the AOI of an entity o. The side lengths are uniformly distributed in the range of [mmin, mmax]. The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval. The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v]. For a simple calculation, both random variables are expressed as the number of cell units. Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities. Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities. Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects. Table 2 summarizes these results. In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing. Different grid cell partitioning with edge methods will lead to different memory requirements. For example, here are two grids: a M × M grid and a 2M × 2M grid. The memory requirement for the user entities is unchanged because it depends only on the total number of user entities. The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid. Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations. For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance. Similar to edge indexing, node indexing has two update policies: full update and incremental update. Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes. The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period. In this analysis, we only consider incremental node indexing. To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5. We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O. As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0). If an object resides in the same cell, there will be no update. If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0). The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed. Roughly speaking, its worst-case processing cost is the same as Tedgefull per update . Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3. In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)). However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2). Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta. Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods. The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v). The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation. After the lookup, Td executes the reverse operation of Ta. Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets. From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing. Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI. In this figure we assume that the average side length of the AOI is 0.1 (or 10 %). The node indexing method, however, depends not only on the side length but also on the reachable distance. Thus the entity update in node indexing is much heavier than the full update for edge indexing. As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node. Therefore, it would take |Q|×Ts to scan all user entities. If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1). In this analysis, we do not consider any data delivery overhead after a cell evaluation. Note that in single-table edge indexing we need to scan all the tokens for cell evaluations. Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation. Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation. Table 4 shows the expected complexities of different cell evaluation scenarios. If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|). However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations. In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing. The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement. First of all, Td is very predictable and a more lightweight procedure than Td. All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant. In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing. Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform. Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific. The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9. Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second. Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6. EVALUATION This section presents two simulation setups and their performance results. Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity. Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15]. P is the ratio of relevant, retrieved items to all retrieved items. A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client. A higher P value means a higher network traffic load than required. R is the ratio of relevant, retrieved items to all relevant items. A lower R value means that more objects that should be recognized are ignored. From the R measure, we can quantitatively estimate the occurrence of object popping. In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15]. The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important. If β is less than 1, P becomes more important. Otherwise, R will affect the E-measure significantly. A lower E-measure value implies that the tested view model has a higher quality. The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI. PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}. RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}. Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing. If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes. Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell. Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result. It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well. Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1). The populated entities are uniformly located in the unit space. The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space. The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP. We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range. A smaller side length leads to higher accuracy but lower comprehensiveness. For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%. Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client. But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered. Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects. To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation. E-measure Distribution: Figure 8 reveals two trends. First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR. Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR. It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR. Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model. We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme. We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes. While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI. As expected, fine-grained grid partitioning showed a smaller E-measure value. The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths. As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP. From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment. As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation. To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell. We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory. We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update. However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal. Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist. Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments. However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment. Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput. In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP. Figure 8: E-measure value as a function of Precision value P when β = 1. Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes. Exhaustive search methods do not maintain any intermediate results. They simply compute whether a given user point is inside a given object AOI. They can tolerate unpredictable behavior of object movement. In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination. Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude. As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI. Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally. Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7. CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing. Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity. Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations. However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain. Currently, we are developing another edge indexing method to make the indexing complexity constant. Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data. We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8. REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech. Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput. Graph. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib. Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411",
    "original_translation": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411",
    "original_sentences": [
        "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
        "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
        "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
        "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
        "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
        "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
        "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
        "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
        "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
        "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
        "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
        "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
        "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
        "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
        "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
        "In this paper, we mainly focus on the first two requirements.",
        "Dynamic extensibility allows regular game-users to deploy their own created content.",
        "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
        "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
        "Another important requirement is scalability.",
        "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
        "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
        "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
        "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
        "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
        "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
        "In this model, a server continuously transmits both update events and geometry data to every connected user.",
        "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
        "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
        "The traditional visibility determination approach, however, has an object popping problem.",
        "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
        "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
        "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
        "The visibility calculation for each user not only needs to be accurate, but also fast.",
        "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
        "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
        "Our two novel methods represent the main contributions of this work.",
        "The organization of this paper is as follows.",
        "Section 2 presents related work.",
        "Section 3 describes our new view method.",
        "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
        "We also discuss its optimization issues.",
        "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
        "Finally, we conclude and address future research directions in Section 7. 2.",
        "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
        "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
        "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
        "However, these algorithms assume that all the candidate visible objects have been stored locally.",
        "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
        "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
        "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
        "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
        "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
        "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
        "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
        "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
        "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
        "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
        "The grid-based partitioning model is a special case of fixed partitioning.",
        "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
        "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
        "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
        "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
        "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
        "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
        "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
        "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
        "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
        "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
        "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
        "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
        "Our indexing method is very similar to the above approaches.",
        "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
        "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
        "We then propose our own model, and finally we discuss its strengths and limitations.",
        "To begin with, we define the terminologies commonly used throughout this paper.",
        "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
        "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
        "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
        "It has no shape and is represented only by a point location.",
        "It is designed to allow a game participant to see from a third-person viewpoint.",
        "It functions similar to a camera control in the 3D graphics field.",
        "It also has a higher degree of mobility than other entities.",
        "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
        "It possesses both features: its own viewpoint and visibility.",
        "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
        "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
        "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
        "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
        "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
        "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
        "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
        "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
        "As the user navigates, she continuously searches for all the entities within her AOI.",
        "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
        "However, the user-initiated model has a serious object popping problem during navigation.",
        "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
        "A large AOI, however, may lead to a significant system degradation.",
        "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
        "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
        "Every user entity recognizes the objects whose AOIs cover its point location.",
        "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
        "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
        "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
        "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
        "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
        "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
        "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
        "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
        "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
        "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
        "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
        "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
        "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
        "Second Life is the classic example of such an approach.",
        "A virtual space is partitioned into equal-sized sub-worlds.",
        "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
        "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
        "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
        "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
        "Every sub-world is managed by its dedicated server machine.",
        "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
        "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
        "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
        "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
        "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
        "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
        "This retrieval process is interchangeably called a user (or query) evaluation.",
        "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
        "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
        "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
        "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
        "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
        "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
        "A node is a data structure that stores ITs of a cell.",
        "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
        "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
        "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
        "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
        "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
        "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
        "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
        "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
        "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
        "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
        "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
        "Much of the existing work falls into this category.",
        "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
        "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
        "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
        "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
        "Every cell stores IT entities that intersect with its region.",
        "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
        "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
        "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
        "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
        "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
        "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
        "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
        "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
        "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
        "Lemma 1.",
        "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
        "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
        "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
        "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
        "Generally, this is done through a twostep algorithm [13] that works as follows.",
        "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
        "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
        "After all the cells are evaluated, the algorithm starts over.",
        "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
        "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
        "Let us assume that the system maintains the row-wise edges.",
        "The leftmost node structures are assumed to be obtained in advance.",
        "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
        "We repeat this computation until we reach the rightmost cell.",
        "Hence, without any column-wise edges we can obtain all the node structures successfully.",
        "As a result, we reduce the complexity of the index construction and update by a factor of two.",
        "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
        "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
        "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
        "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
        "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
        "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
        "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
        "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
        "The above calculation also corresponds to our intuition.",
        "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
        "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
        "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
        "Obviously, edge indexing is inefficient for indexing a point geometry.",
        "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
        "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
        "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
        "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
        "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
        "Let us assume that an edge index is realized with a hash table.",
        "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
        "However, the token removal time depends on the expected number of tokens per hash bucket.",
        "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
        "Two-table edge indexing is designed to make the token removal overhead constant.",
        "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
        "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
        "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
        "It is represented by the number of cell units. structures.",
        "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
        "Otherwise, it will be placed with a moving edge.",
        "Second, all moving edge structures are periodically reconstructed.",
        "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
        "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
        "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
        "A singly linked list implementation is used for the moving edge structure. 5.",
        "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
        "In this analysis, we assume that node and edge structures are implemented with hash tables.",
        "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
        "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
        "A token scan operation reads the tokens in a hash bucket sequentially.",
        "It is extensively used during cell evaluations.",
        "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
        "For the purpose of analysis, we define two random variables.",
        "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
        "The side lengths are uniformly distributed in the range of [mmin, mmax].",
        "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
        "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
        "For a simple calculation, both random variables are expressed as the number of cell units.",
        "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
        "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
        "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
        "Table 2 summarizes these results.",
        "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
        "Different grid cell partitioning with edge methods will lead to different memory requirements.",
        "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
        "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
        "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
        "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
        "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
        "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
        "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
        "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
        "In this analysis, we only consider incremental node indexing.",
        "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
        "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
        "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
        "If an object resides in the same cell, there will be no update.",
        "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
        "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
        "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
        "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
        "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
        "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
        "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
        "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
        "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
        "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
        "After the lookup, Td executes the reverse operation of Ta.",
        "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
        "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
        "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
        "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
        "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
        "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
        "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
        "Therefore, it would take |Q|×Ts to scan all user entities.",
        "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
        "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
        "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
        "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
        "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
        "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
        "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
        "Table 4 shows the expected complexities of different cell evaluation scenarios.",
        "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
        "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
        "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
        "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
        "First of all, Td is very predictable and a more lightweight procedure than Td.",
        "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
        "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
        "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
        "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
        "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
        "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
        "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
        "EVALUATION This section presents two simulation setups and their performance results.",
        "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
        "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
        "P is the ratio of relevant, retrieved items to all retrieved items.",
        "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
        "A higher P value means a higher network traffic load than required.",
        "R is the ratio of relevant, retrieved items to all relevant items.",
        "A lower R value means that more objects that should be recognized are ignored.",
        "From the R measure, we can quantitatively estimate the occurrence of object popping.",
        "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
        "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
        "If β is less than 1, P becomes more important.",
        "Otherwise, R will affect the E-measure significantly.",
        "A lower E-measure value implies that the tested view model has a higher quality.",
        "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
        "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
        "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
        "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
        "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
        "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
        "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
        "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
        "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
        "The populated entities are uniformly located in the unit space.",
        "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
        "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
        "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
        "A smaller side length leads to higher accuracy but lower comprehensiveness.",
        "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
        "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
        "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
        "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
        "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
        "E-measure Distribution: Figure 8 reveals two trends.",
        "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
        "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
        "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
        "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
        "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
        "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
        "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
        "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
        "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
        "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
        "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
        "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
        "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
        "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
        "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
        "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
        "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
        "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
        "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
        "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
        "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
        "Figure 8: E-measure value as a function of Precision value P when β = 1.",
        "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
        "Exhaustive search methods do not maintain any intermediate results.",
        "They simply compute whether a given user point is inside a given object AOI.",
        "They can tolerate unpredictable behavior of object movement.",
        "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
        "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
        "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
        "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
        "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
        "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
        "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
        "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
        "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
        "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
        "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
        "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
        "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
        "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
        "Graph.",
        "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
        "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
        "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
    ],
    "translated_text_sentences": [
        "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real.",
        "Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios.",
        "Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables.",
        "En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local.",
        "En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor.",
        "Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando.",
        "Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento.",
        "Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos.",
        "El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable.",
        "Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos.",
        "Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano.",
        "Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1.",
        "INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación.",
        "Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente.",
        "Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad.",
        "En este documento, nos enfocamos principalmente en los dos primeros requisitos.",
        "La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado.",
        "Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema.",
        "El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos.",
        "Otro requisito importante es la escalabilidad.",
        "Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo.",
        "Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes.",
        "Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3].",
        "Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos.",
        "Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada.",
        "Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5].",
        "En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado.",
        "Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio.",
        "Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario.",
        "Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente.",
        "Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a).",
        "A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b).",
        "Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario.",
        "El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido.",
        "Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios.",
        "Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial).",
        "Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo.",
        "La organización de este documento es la siguiente.",
        "La sección 2 presenta el trabajo relacionado.",
        "La sección 3 describe nuestro nuevo método de visualización.",
        "En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real.",
        "También discutimos sus problemas de optimización.",
        "La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación.",
        "Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2.",
        "El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D.",
        "Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado.",
        "La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6].",
        "Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente.",
        "Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor.",
        "Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5].",
        "Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva.",
        "Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados.",
        "Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales.",
        "En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento.",
        "Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales.",
        "Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos.",
        "Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula.",
        "El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR).",
        "El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo.",
        "Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos.",
        "Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12].",
        "Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo.",
        "En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos.",
        "El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento.",
        "A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente.",
        "La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree.",
        "SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles.",
        "Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas).",
        "A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento.",
        "Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema.",
        "Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha.",
        "Nuestro método de indexación es muy similar a los enfoques anteriores.",
        "La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3.",
        "MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista.",
        "Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones.",
        "Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento.",
        "Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares.",
        "El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades.",
        "La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades.",
        "No tiene forma y está representado solo por una ubicación puntual.",
        "Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona.",
        "Funciona de manera similar a un control de cámara en el campo de la gráfica 3D.",
        "También tiene un mayor grado de movilidad que otras entidades.",
        "El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades.",
        "Posee ambas características: su propio punto de vista y visibilidad.",
        "Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora.",
        "El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia.",
        "Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual.",
        "Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima.",
        "Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad.",
        "Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible.",
        "Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas.",
        "El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene.",
        "A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI.",
        "Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo.",
        "Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación.",
        "Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable.",
        "Sin embargo, un AOI grande puede provocar una degradación significativa del sistema.",
        "Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos.",
        "Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI.",
        "Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual.",
        "Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales.",
        "Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante.",
        "Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario.",
        "Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista.",
        "Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4.",
        "Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real.",
        "Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D.",
        "Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final.",
        "En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4.",
        "DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo.",
        "A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4.",
        "Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos.",
        "El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo.",
        "Second Life es el ejemplo clásico de tal enfoque.",
        "Un espacio virtual se divide en submundos de tamaño igual.",
        "El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A.",
        "Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado.",
        "Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura).",
        "La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R.",
        "Cada submundo es gestionado por su máquina de servidor dedicada.",
        "Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades.",
        "Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla.",
        "La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas.",
        "En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula.",
        "La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2.",
        "Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra.",
        "Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable.",
        "Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices.",
        "La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada.",
        "En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada.",
        "El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente.",
        "El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente.",
        "También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista.",
        "Un nodo es una estructura de datos que almacena sus datos de una celda.",
        "Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda.",
        "Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs.",
        "Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE).",
        "El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j.",
        "La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec).",
        "En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10].",
        "Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos.",
        "La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada.",
        "En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual.",
        "Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango.",
        "Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras.",
        "Gran parte del trabajo existente cae en esta categoría.",
        "Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización.",
        "Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos.",
        "Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13].",
        "Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a).",
        "Cada célula almacena entidades de TI que se intersectan con su región.",
        "El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula.",
        "Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo.",
        "Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj).",
        "En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes.",
        "Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M).",
        "La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2.",
        "Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes.",
        "Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1.",
        "La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2.",
        "Lema 1.",
        "La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante.",
        "Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25.",
        "Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes.",
        "Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente.",
        "Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera.",
        "El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas).",
        "Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario.",
        "Después de evaluar todas las celdas, el algoritmo comienza de nuevo.",
        "El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas.",
        "Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos.",
        "Supongamos que el sistema mantiene los bordes por filas.",
        "Se asume que las estructuras de nodos más a la izquierda se obtienen previamente.",
        "Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila.",
        "Repetimos este cálculo hasta llegar a la celda más a la derecha.",
        "Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos.",
        "Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos.",
        "La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas.",
        "El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT).",
        "El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas.",
        "En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2.",
        "Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}.",
        "E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}.",
        "De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}.",
        "Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
        "El cálculo anterior también corresponde a nuestra intuición.",
        "P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4.",
        "Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios.",
        "Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición.",
        "Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto.",
        "La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación.",
        "El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos.",
        "En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad.",
        "En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas.",
        "La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización.",
        "Supongamos que se realiza un índice de aristas con una tabla hash.",
        "La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante.",
        "Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash.",
        "Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas.",
        "El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante.",
        "Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades.",
        "Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq).",
        "Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable.",
        "Se representa por el número de unidades celulares. estructuras.",
        "Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria.",
        "De lo contrario, se colocará con un borde móvil.",
        "Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente.",
        "Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles.",
        "Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción.",
        "Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades.",
        "Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5.",
        "ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento.",
        "En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash.",
        "Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token.",
        "Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente.",
        "Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial.",
        "Se utiliza ampliamente durante las evaluaciones celulares.",
        "Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante.",
        "Con el propósito de análisis, definimos dos variables aleatorias.",
        "Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o.",
        "Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo].",
        "El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo.",
        "El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v].",
        "Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células.",
        "La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto.",
        "La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto.",
        "La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos.",
        "La Tabla 2 resume estos resultados.",
        "En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos.",
        "La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria.",
        "Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M.",
        "El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario.",
        "Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M).",
        "Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas.",
        "Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q.",
        "Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental.",
        "La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas.",
        "La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período.",
        "En este análisis, solo consideramos la indexación de nodos incremental.",
        "Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5.",
        "También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O.",
        "Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0).",
        "Si un objeto reside en la misma celda, no habrá actualización.",
        "Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0).",
        "El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento.",
        "Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización.",
        "Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3.",
        "En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)).",
        "Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2).",
        "Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta.",
        "Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación.",
        "La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v).",
        "La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token.",
        "Después de la búsqueda, Td ejecuta la operación inversa de Ta.",
        "Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash.",
        "A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas.",
        "La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado.",
        "En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %).",
        "El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable.",
        "Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes.",
        "Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda.",
        "Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario.",
        "Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
        "Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
        "La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1).",
        "En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda.",
        "Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas.",
        "La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda.",
        "A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda.",
        "La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular.",
        "Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|).",
        "Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas.",
        "En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas.",
        "El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento.",
        "En primer lugar, Td es muy predecible y un procedimiento más ligero que Td.",
        "Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes.",
        "Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla.",
        "Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme.",
        "La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación.",
        "El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9.",
        "El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo.",
        "Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6.",
        "EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento.",
        "La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación.",
        "La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15].",
        "P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados.",
        "Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente.",
        "Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria.",
        "R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes.",
        "Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos.",
        "A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos.",
        "Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15].",
        "La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes.",
        "Si β es menor que 1, P se vuelve más importante.",
        "De lo contrario, R afectará significativamente la medida E.",
        "Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad.",
        "El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario.",
        "PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}.",
        "RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}.",
        "Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes.",
        "Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad.",
        "El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente.",
        "Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR.",
        "Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también.",
        "Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1).",
        "Las entidades pobladas están uniformemente ubicadas en el espacio unitario.",
        "La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario.",
        "El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP.",
        "Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario.",
        "Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad.",
        "Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%.",
        "Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente.",
        "Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados.",
        "De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios.",
        "Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema.",
        "Distribución de la medida E: La Figura 8 revela dos tendencias.",
        "Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR.",
        "Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR.",
        "Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR.",
        "Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP.",
        "Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema.",
        "También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación.",
        "Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI.",
        "Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño.",
        "El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario.",
        "A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP.",
        "A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad.",
        "Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes.",
        "Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda.",
        "También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria.",
        "Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización.",
        "Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens.",
        "La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente.",
        "En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes.",
        "Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento.",
        "Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema.",
        "En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP.",
        "Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1.",
        "Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación.",
        "Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio.",
        "Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada.",
        "Pueden tolerar el comportamiento impredecible del movimiento de los objetos.",
        "A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad.",
        "La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud.",
        "Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI.",
        "Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional.",
        "La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7.",
        "CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes.",
        "Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación.",
        "Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones.",
        "Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional.",
        "Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante.",
        "Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones.",
        "Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación.",
        "REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech.",
        "Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput.",
        "Gráfico.",
        "Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib.",
        "Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J.",
        "Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411"
    ],
    "error_count": 10,
    "keys": {
        "edge indexing": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>edge indexing</br> in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF <br>edge indexing</br> In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for <br>edge indexing</br> follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) <br>edge indexing</br> (c) <br>edge indexing</br> with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 <br>edge indexing</br> Our new indexing method, <br>edge indexing</br>, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with <br>edge indexing</br> derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve <br>edge indexing</br> stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original <br>edge indexing</br>.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our <br>edge indexing</br> by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise <br>edge indexing</br> method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of <br>edge indexing</br> of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, <br>edge indexing</br> is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "<br>edge indexing</br>, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our <br>edge indexing</br> method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for <br>edge indexing</br>, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table <br>edge indexing</br> is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, <br>edge indexing</br>, and two-table <br>edge indexing</br>) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table <br>edge indexing</br> consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table <br>edge indexing</br> occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our <br>edge indexing</br> methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to <br>edge indexing</br>, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table <br>edge indexing</br> with full update |Q| |O| · 2(m + 1) single-table <br>edge indexing</br> with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for <br>edge indexing</br> with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for <br>edge indexing</br> with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case <br>edge indexing</br> (single-table <br>edge indexing</br> with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table <br>edge indexing</br> depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table <br>edge indexing</br> Incremental <br>edge indexing</br> Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table <br>edge indexing</br> takes at least twice as long as the update for two-table <br>edge indexing</br>.",
                "Figure 6 shows that full update of <br>edge indexing</br> when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for <br>edge indexing</br>.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table <br>edge indexing</br> we need to scan all the tokens for cell evaluations.",
                "Two-table <br>edge indexing</br> executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any <br>edge indexing</br> method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, <br>edge indexing</br> methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table <br>edge indexing</br> and two-table <br>edge indexing</br>.",
                "The total elapsed time of full update based single-table <br>edge indexing</br> for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table <br>edge indexing</br> is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update <br>edge indexing</br>.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for <br>edge indexing</br>.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of <br>edge indexing</br> In this section, we present the preliminary results of the simulations that examine the applicability of our <br>edge indexing</br> implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented <br>edge indexing</br> algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different <br>edge indexing</br> methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental <br>edge indexing</br> method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table <br>edge indexing</br> method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table <br>edge indexing</br> 100x100 Two−table <br>edge indexing</br> 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, <br>edge indexing</br>.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our <br>edge indexing</br> model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our <br>edge indexing</br> still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another <br>edge indexing</br> method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our <br>edge indexing</br> can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "<br>edge indexing</br> in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "DESIGN OF <br>edge indexing</br> In Section 4.1 we introduce our target application model.",
                "Several optimization issues for <br>edge indexing</br> follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) <br>edge indexing</br> (c) <br>edge indexing</br> with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 <br>edge indexing</br> Our new indexing method, <br>edge indexing</br>, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid."
            ],
            "translated_annotated_samples": [
                "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real.",
                "DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo.",
                "Varios problemas de optimización para el <br>indexado de bordes</br> se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos.",
                "La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) <br>indexación de aristas</br> (c) <br>indexación de aristas</br> con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2.",
                "El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la <br>indexación de bordes</br>, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el <br>indexado de bordes</br> se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) <br>indexación de aristas</br> (c) <br>indexación de aristas</br> con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la <br>indexación de bordes</br>, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. ",
            "candidates": [],
            "error": [
                [
                    "indexado de bordes",
                    "indexación de aristas",
                    "indexación de aristas",
                    "indexación de bordes"
                ]
            ]
        },
        "dynamic virtual environment": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely <br>dynamic virtual environment</br>s is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly <br>dynamic virtual environment</br>s [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "Specifically, performing real-time visibility tests in extremely <br>dynamic virtual environment</br>s is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly <br>dynamic virtual environment</br>s [12, 8, 13, 10]."
            ],
            "translated_annotated_samples": [
                "Específicamente, realizar pruebas de visibilidad en tiempo real en <br>entornos virtuales extremadamente dinámicos</br> es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando.",
                "En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en <br>entornos virtuales altamente dinámicos</br> [12, 8, 13, 10]."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en <br>entornos virtuales extremadamente dinámicos</br> es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en <br>entornos virtuales altamente dinámicos</br> [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    "entornos virtuales extremadamente dinámicos",
                    "entornos virtuales altamente dinámicos"
                ]
            ]
        },
        "game-based application": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging <br>game-based application</br> systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging <br>game-based application</br> systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time."
            ],
            "translated_annotated_samples": [
                "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                []
            ]
        },
        "mutable virtual content": {
            "translated_key": "contenido virtual autónomo y mutable",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, <br>mutable virtual content</br> which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "They are filled with autonomous, <br>mutable virtual content</br> which is continuously augmented by the users."
            ],
            "translated_annotated_samples": [
                "Están llenos de <br>contenido virtual autónomo y mutable</br> que es continuamente aumentado por los usuarios."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de <br>contenido virtual autónomo y mutable</br> que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "spatial database": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a <br>spatial database</br> problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a <br>spatial database</br> while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to <br>spatial database</br> problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "We recognize that the described challenges are closely related to a <br>spatial database</br> problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a <br>spatial database</br> while modeling each avatar both as a spatial object and a moving query.",
                "Here we recognize that such graphics related issues have a very close similarity to <br>spatial database</br> problems."
            ],
            "translated_annotated_samples": [
                "Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de <br>base de datos espacial</br>, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una <br>base de datos espacial</br> mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento.",
                "Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de <br>bases de datos espaciales</br>."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de <br>base de datos espacial</br>, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una <br>base de datos espacial</br> mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de <br>bases de datos espaciales</br>. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    "base de datos espacial",
                    "base de datos espacial",
                    "bases de datos espaciales"
                ]
            ]
        },
        "spatial indexing method": {
            "translated_key": "método de indexación espacial",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new <br>spatial indexing method</br> designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "In Section 4, we present assumptions on our target application and introduce a new <br>spatial indexing method</br> designed to support real-time visibility computations."
            ],
            "translated_annotated_samples": [
                "En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo <br>método de indexación espacial</br> diseñado para soportar cálculos de visibilidad en tiempo real."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo <br>método de indexación espacial</br> diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "real-time visibility test": {
            "translated_key": "pruebas de visibilidad en tiempo real",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing <br>real-time visibility test</br>s in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "Specifically, performing <br>real-time visibility test</br>s in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting."
            ],
            "translated_annotated_samples": [
                "Específicamente, realizar <br>pruebas de visibilidad en tiempo real</br> en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar <br>pruebas de visibilidad en tiempo real</br> en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "object-initiated view model": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "<br>object-initiated view model</br> In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call <br>object-initiated view model</br>.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an <br>object-initiated view model</br>: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the <br>object-initiated view model</br>, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "<br>object-initiated view model</br> In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "To overcome the object popping problem, we propose a new view model which we call <br>object-initiated view model</br>.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an <br>object-initiated view model</br>: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the <br>object-initiated view model</br>, and its efficient indexing method, edge indexing."
            ],
            "translated_annotated_samples": [
                "MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista.",
                "Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos <br>modelo de vista iniciado por objetos</br>.",
                "El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario.",
                "CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el <br>modelo de vista iniciado por objeto</br>, y su método de indexación eficiente, el indexado de bordes."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos <br>modelo de vista iniciado por objetos</br>. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el <br>modelo de vista iniciado por objeto</br>, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    "modelo de vista iniciado por objetos",
                    "modelo de vista iniciado por objeto"
                ]
            ]
        },
        "object popping": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected <br>object popping</br> and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: <br>object popping</br> occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an <br>object popping</br> problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the <br>object popping</br> problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious <br>object popping</br> problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the <br>object popping</br> problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no <br>object popping</br> problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of <br>object popping</br>.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any <br>object popping</br> problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any <br>object popping</br> problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected <br>object popping</br> and supports highly scalable real-time visibility determination.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: <br>object popping</br> occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "The traditional visibility determination approach, however, has an <br>object popping</br> problem.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the <br>object popping</br> problem can be associated with a typical view decision model.",
                "However, the user-initiated model has a serious <br>object popping</br> problem during navigation."
            ],
            "translated_annotated_samples": [
                "El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la <br>aparición inesperada de objetos</br> y que soporta una determinación de visibilidad en tiempo real altamente escalable.",
                "Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El <br>popping de objetos</br> ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5].",
                "Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un <br>problema de objetos que aparecen repentinamente</br>.",
                "MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el <br>problema de los objetos emergentes</br> puede asociarse con un modelo típico de decisión de vista.",
                "Sin embargo, el modelo iniciado por el usuario tiene un grave <br>problema de objetos que aparecen repentinamente</br> durante la navegación."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la <br>aparición inesperada de objetos</br> y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El <br>popping de objetos</br> ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un <br>problema de objetos que aparecen repentinamente</br>. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el <br>problema de los objetos emergentes</br> puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave <br>problema de objetos que aparecen repentinamente</br> durante la navegación. ",
            "candidates": [],
            "error": [
                [
                    "aparición inesperada de objetos",
                    "popping de objetos",
                    "problema de objetos que aparecen repentinamente",
                    "problema de los objetos emergentes",
                    "problema de objetos que aparecen repentinamente"
                ]
            ]
        },
        "3d spatial extension": {
            "translated_key": "Extensión espacial en 3D",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "3d object stream": {
            "translated_key": "Secuencia de objetos en 3D",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "object pop problem": {
            "translated_key": "problema de objeto emergente",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "spatial index": {
            "translated_key": "índice espacial",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient <br>spatial index</br> structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known <br>spatial index</br> structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [
                "The main goal of this paper is to present an efficient <br>spatial index</br> structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "The R-tree is a well-known <br>spatial index</br> structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR)."
            ],
            "translated_annotated_samples": [
                "El objetivo principal de este documento es presentar una estructura de <br>índice espacial</br> eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable.",
                "El R-tree es una estructura de <br>índice espacial</br> bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR)."
            ],
            "translated_text": "Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de <br>índice espacial</br> eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de <br>índice espacial</br> bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "visibility model": {
            "translated_key": "modelo de visibilidad",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}