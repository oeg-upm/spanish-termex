{
    "id": "C-8",
    "original_text": "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications. The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions. The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements. Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms. After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution. In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm. The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3. The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions. We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1. INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4]. In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16]. To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems. The soundness of the theoretical foundation for OT is crucial in this process. One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution. However, the theory of causality is inadequate to capture essential OT conditions for correct transformation. The limitation of the causality theory had caused correctness problems from the very beginning of OT. The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent. However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation. Another condition is that the two concurrent operations must be defined on the same document state. In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22]. This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms. The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors. The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations. In fact, the causality relation is not defined for inverse operations (see Section 2). Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21]. After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution. In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm. The rest of this paper is organized as follows. First, we define causal-dependency/-independency and briefly describe their limitations in Section 2. Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3. In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties. Then, these transformation properties and their pre-conditions are discussed in Section 5. The COT solutions to these transformation properties are presented in Section 6. Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7. Finally, major contributions of this work are summarized in Section 8. 2. LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms. Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23]. Definition 1. Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2. Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23]. To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1. There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1. According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation. In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23]. This term is introduced to differentiate this special transformation function from other steps involved in a transformation process. Figure 1: A real-time group editing scenario. The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle. Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state. When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state. In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly. The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22]. From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g. O1, O2 and O3) directly generated by users, but not for transformed operations (e.g. O1). Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23]. Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations. The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2. The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e. O1 and O3) [21]. To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution. However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3. If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect. Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3. OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined. The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same. In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2). When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1. O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state. When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2. O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle. As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context. In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations. Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations. For any operation O, its inverse is denoted by O. Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O. If O is an original operation, then org(O) = O. Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation. In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document. These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]). We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state. Definition 3. Document state representation A document state can be represented by DS as follows: 1. The initial document state is represented by DS = {}. 2. After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations. Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated. To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O). According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O). More precisely, the context of an operation is defined blow. Definition 4. The context of an operation 1. For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2. For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3. For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations. For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1. According to Definition 4-Item 2, we have C(O2) = {O2}. From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type. Definition 5. Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed). This is because any operation has a context, but only original operations can be included in a context. Definition 6. Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob. In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution. CC1 ensures that O is always executed after the contextdependent operations included in C(O). In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O. When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22]. When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21]. CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS. CC2 ensures that O is transformed against all contextindependent operations in DS before its execution. It can be shown that, for any Ox in DS − C(O), it must be that Ox c O. When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22]. When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21]. CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS. CC3 is required for correctly executing operations. CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob). CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3). CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob. CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob. It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob. CC6 is required for correctly applying IT functions. In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation. These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way. For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation. Let Oij be an original normal operation generated at site i with a sequence number j. If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4. Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations. All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation. Each original inverse operation directly or indirectly corresponds to exactly one original normal operation. For example, inverse operation O may be generated to undo O, and O may be generated to undo O. Both O and O correspond to the same normal operation O. Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation. Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group. For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2. In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group. Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group. Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations. The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i. If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7. Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4]. The vector representation of operation context can also be used as the vector representation of the document state. As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1. Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}. This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3). Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations. Due to space limitation, these technical details are omitted in this paper. 4. THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far. This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations. We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy. In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O). When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation. The set of operations in C(O) can be easily determined from DS based on the information in CV (O). The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo. Both parts share the same core context-based transformation procedure. Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation. COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS. Algorithm 1. COT-DO(O, DS) 1. transform(O, DS − C(O)); 2. Execute O; DS := DS ∪ {org(O)}. Procedure 1. transform(O, CD) Repeat until CD = { }: 1. Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2). This is to upgrade the context of O to DS. In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2). The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined. This procedure repeats the following three steps until CD becomes empty: 1. Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4). An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2. The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5). This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3. After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3). To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1. Consider the operation executions at site 0, with the initial document state DS0 = { }. 1. After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2. When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}. Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}. Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3. When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}. Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle. In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}. Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1). After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user. How to generate the undo command for selecting any operation to undo is part of the undo policy [21]. This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context. In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself. COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation. Algorithm 2. COT-UNDO(O, DS) 1. O := makeInverse(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O. For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}. First, O2 and C(O2) = {O2} are created. Then, COT-DO is invoked with parameters O2 and DS. Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}. This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations. This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations. The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime. Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5. TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions. Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters. Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system. Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components. Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21]. Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses. The makeInverse(O) procedure directly follows these definitions. 1. Convergence Property 1 (CP1)3 . Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2. Convergence Property 2 (CP2). Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3. Inverse Property 2 (IP2)4 . Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4. Inverse Property 3 (IP3). Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa. The above transformation properties are important discoveries of past research, but they are not unconditionally required. The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature. To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1. PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2. PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3. PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4. PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties. Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3. Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11]. IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7). Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole. In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6. COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5). With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3. The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part). Procedure 2. transform(O, CD) 1. If CD = { }, ensure TPsafety(O, CD); 2. Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedure 3. ensure TPsafety(O, CD) 1. Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2. Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3. Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD). Procedure 4. make IP3safe Inverse(O, CD) 1. O := makeInverse(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4. O := makeInverse(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()). If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order. Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2. It should be noted that CD becomes an ordered set after the sorting. The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2. A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations. There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12]. The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2. This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD. An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O. Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3. The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2). This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD. The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7. DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21]. In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined. This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders. There was no explicit representation of an operation context. Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21]. In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined. This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set. Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured. Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context. The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well. Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations. However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations. The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime. The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3. The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole. COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions. The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3. In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21]. An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution. Under this scheme, inverse operations are not explicitly represented in the history buffer. When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair. To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21]. However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations. In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated. Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage. These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme. In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21]. Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function. In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy. This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level. We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group. When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement. If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version. Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage. By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence. COT is not the first OT algorithm that buffers and uses original operations for transformation. Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations. COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research. In this section, we provide our observations and opinions on some important OT correctness issues. OT is a complex system with multiple interrelated components. A system-oriented approach is needed for addressing OT issues. An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions. Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results. The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system. In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails. In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design. Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions. Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined. In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification. A systematic approach is needed in conducting both experimental and theoretic OT research. Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete. For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21]. A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them. On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component. For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult. However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them. Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components. Caution must be taken in interpreting correctness results. For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems. In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems. They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21]. They are unnecessary if the pre-conditions for requiring them have been broken. For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23]. CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12]. One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations. An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties. This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23]. It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2. In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well. For alternative views and approaches to this problem, the reader is referred to [8, 11, 5]. The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios. In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions. Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8. CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm. The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems. The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions. The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24]. Real-world applications provide exciting opportunities and challenges to future OT research. The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications. Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9. REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer. Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. A calculus for concurrent update. In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu. Generalizing operational transformation to the standard general markup language. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs. Concurrency control in groupware systems. In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang. Consistency maintenance based on the mark & retrace technique in groupware systems. In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari. On the consistency problem in mobile distributed computing. In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002. ACM. [7] C. Ignat and M.C. Norrie. Customizable collaborative editor relying on treeOPT algorithm. In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch. Proving correctness of transformation functions in real-time groupware. In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport. Time, clocks, and the ordering of events in a distributed system. Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li. Transparent sharing and interoperation of heterogeneous single-user applications. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li. Preserving operation effects relation in group editors. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun. A time interval based consistency control algorithm for interactive groupware applications. In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack. Proof of correctness of Ressels adOPTed algorithm. Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack. Operation transforms for a distributed shared spreadsheet. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister. A framework for undoing actions in collaborative systems. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins. Automating semantics-based reconciliation for mobile databases. In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal. Logical time: capturing causality in distributed systems. IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser. Reducing the problems of group undo. In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser. An integrating, transformation-oriented approach to concurrency control and undo in group editors. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun. A flexible notification framework for collaborative systems. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun. Undo as concurrent inverse in group editors. ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis. Operational transformation in real-time group editors: issues, algorithms, and achievements. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen. Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems. ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai. Transparent adaptation of single-user applications for multi-user real-time collaboration. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen. Operational transformation for collaborative word processing. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman. Copies convergence in a distributed real-time collaborative environment. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen. A collaborative table editing technique based on transparent adaptation. In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen. Object-associated telepointer for real-time collaborative document editing systems. In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen. Leveraging single-user applications for multi-user collaboration: the CoWord approach. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288",
    "original_translation": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288",
    "original_sentences": [
        "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
        "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
        "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
        "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
        "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
        "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
        "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
        "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
        "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
        "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
        "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
        "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
        "The soundness of the theoretical foundation for OT is crucial in this process.",
        "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
        "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
        "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
        "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
        "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
        "Another condition is that the two concurrent operations must be defined on the same document state.",
        "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
        "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
        "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
        "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
        "In fact, the causality relation is not defined for inverse operations (see Section 2).",
        "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
        "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
        "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
        "The rest of this paper is organized as follows.",
        "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
        "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
        "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
        "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
        "The COT solutions to these transformation properties are presented in Section 6.",
        "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
        "Finally, major contributions of this work are summarized in Section 8. 2.",
        "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
        "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
        "Definition 1.",
        "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
        "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
        "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
        "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
        "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
        "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
        "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
        "Figure 1: A real-time group editing scenario.",
        "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
        "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
        "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
        "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
        "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
        "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
        "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
        "O1).",
        "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
        "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
        "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
        "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
        "O1 and O3) [21].",
        "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
        "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
        "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
        "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
        "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
        "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
        "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
        "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
        "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
        "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
        "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
        "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
        "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
        "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
        "For any operation O, its inverse is denoted by O.",
        "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
        "If O is an original operation, then org(O) = O.",
        "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
        "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
        "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
        "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
        "Definition 3.",
        "Document state representation A document state can be represented by DS as follows: 1.",
        "The initial document state is represented by DS = {}. 2.",
        "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
        "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
        "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
        "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
        "More precisely, the context of an operation is defined blow.",
        "Definition 4.",
        "The context of an operation 1.",
        "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
        "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
        "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
        "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
        "According to Definition 4-Item 2, we have C(O2) = {O2}.",
        "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
        "Definition 5.",
        "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
        "This is because any operation has a context, but only original operations can be included in a context.",
        "Definition 6.",
        "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
        "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
        "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
        "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
        "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
        "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
        "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
        "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
        "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
        "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
        "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
        "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
        "CC3 is required for correctly executing operations.",
        "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
        "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
        "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
        "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
        "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
        "CC6 is required for correctly applying IT functions.",
        "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
        "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
        "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
        "Let Oij be an original normal operation generated at site i with a sequence number j.",
        "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
        "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
        "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
        "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
        "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
        "Both O and O correspond to the same normal operation O.",
        "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
        "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
        "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
        "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
        "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
        "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
        "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
        "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
        "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
        "The vector representation of operation context can also be used as the vector representation of the document state.",
        "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
        "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
        "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
        "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
        "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
        "Due to space limitation, these technical details are omitted in this paper. 4.",
        "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
        "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
        "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
        "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
        "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
        "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
        "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
        "Both parts share the same core context-based transformation procedure.",
        "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
        "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
        "Algorithm 1.",
        "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
        "Execute O; DS := DS ∪ {org(O)}.",
        "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
        "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
        "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
        "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
        "This is to upgrade the context of O to DS.",
        "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
        "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
        "This procedure repeats the following three steps until CD becomes empty: 1.",
        "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
        "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
        "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
        "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
        "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
        "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
        "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
        "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
        "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
        "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
        "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
        "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
        "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
        "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
        "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
        "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
        "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
        "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
        "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
        "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
        "Algorithm 2.",
        "COT-UNDO(O, DS) 1.",
        "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
        "COT-DO(O, DS).",
        "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
        "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
        "First, O2 and C(O2) = {O2} are created.",
        "Then, COT-DO is invoked with parameters O2 and DS.",
        "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
        "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
        "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
        "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
        "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
        "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
        "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
        "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
        "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
        "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
        "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
        "The makeInverse(O) procedure directly follows these definitions. 1.",
        "Convergence Property 1 (CP1)3 .",
        "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
        "Convergence Property 2 (CP2).",
        "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
        "Inverse Property 2 (IP2)4 .",
        "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
        "Inverse Property 3 (IP3).",
        "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
        "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
        "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
        "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
        "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
        "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
        "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
        "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
        "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
        "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
        "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
        "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
        "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
        "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
        "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
        "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
        "Procedure 2. transform(O, CD) 1.",
        "If CD = { }, ensure TPsafety(O, CD); 2.",
        "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
        "Procedure 3. ensure TPsafety(O, CD) 1.",
        "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
        "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
        "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
        "Procedure 4. make IP3safe Inverse(O, CD) 1.",
        "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
        "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
        "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
        "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
        "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
        "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
        "It should be noted that CD becomes an ordered set after the sorting.",
        "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
        "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
        "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
        "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
        "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
        "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
        "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
        "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
        "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
        "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
        "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
        "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
        "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
        "There was no explicit representation of an operation context.",
        "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
        "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
        "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
        "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
        "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
        "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
        "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
        "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
        "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
        "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
        "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
        "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
        "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
        "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
        "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
        "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
        "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
        "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
        "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
        "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
        "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
        "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
        "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
        "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
        "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
        "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
        "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
        "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
        "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
        "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
        "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
        "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
        "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
        "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
        "In this section, we provide our observations and opinions on some important OT correctness issues.",
        "OT is a complex system with multiple interrelated components.",
        "A system-oriented approach is needed for addressing OT issues.",
        "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
        "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
        "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
        "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
        "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
        "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
        "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
        "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
        "A systematic approach is needed in conducting both experimental and theoretic OT research.",
        "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
        "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
        "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
        "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
        "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
        "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
        "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
        "Caution must be taken in interpreting correctness results.",
        "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
        "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
        "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
        "They are unnecessary if the pre-conditions for requiring them have been broken.",
        "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
        "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
        "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
        "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
        "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
        "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
        "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
        "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
        "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
        "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
        "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
        "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
        "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
        "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
        "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
        "Real-world applications provide exciting opportunities and challenges to future OT research.",
        "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
        "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
        "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
        "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
        "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
        "A calculus for concurrent update.",
        "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
        "Generalizing operational transformation to the standard general markup language.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
        "Concurrency control in groupware systems.",
        "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
        "Consistency maintenance based on the mark & retrace technique in groupware systems.",
        "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
        "On the consistency problem in mobile distributed computing.",
        "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
        "ACM. [7] C. Ignat and M.C.",
        "Norrie.",
        "Customizable collaborative editor relying on treeOPT algorithm.",
        "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
        "Proving correctness of transformation functions in real-time groupware.",
        "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
        "Time, clocks, and the ordering of events in a distributed system.",
        "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
        "Transparent sharing and interoperation of heterogeneous single-user applications.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
        "Preserving operation effects relation in group editors.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
        "A time interval based consistency control algorithm for interactive groupware applications.",
        "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
        "Proof of correctness of Ressels adOPTed algorithm.",
        "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
        "Operation transforms for a distributed shared spreadsheet.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
        "A framework for undoing actions in collaborative systems.",
        "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
        "Automating semantics-based reconciliation for mobile databases.",
        "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
        "Logical time: capturing causality in distributed systems.",
        "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
        "Reducing the problems of group undo.",
        "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
        "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
        "A flexible notification framework for collaborative systems.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
        "Undo as concurrent inverse in group editors.",
        "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
        "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
        "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
        "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
        "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
        "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
        "Operational transformation for collaborative word processing.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
        "Copies convergence in a distributed real-time collaborative environment.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
        "A collaborative table editing technique based on transparent adaptation.",
        "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
        "Object-associated telepointer for real-time collaborative document editing systems.",
        "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
        "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
    ],
    "translated_text_sentences": [
        "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas.",
        "La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones.",
        "La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección.",
        "Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados.",
        "Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua.",
        "En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto).",
        "El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3.",
        "El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación.",
        "Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas.",
        "Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1.",
        "La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4].",
        "En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16].",
        "Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos.",
        "La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso.",
        "Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución.",
        "Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta.",
        "La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT.",
        "El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes.",
        "Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación.",
        "Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento.",
        "De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22].",
        "Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT.",
        "La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo.",
        "El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición.",
        "De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2).",
        "Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21].",
        "Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua.",
        "En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto).",
        "El resto de este documento está organizado de la siguiente manera.",
        "Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2.",
        "A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3.",
        "En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación.",
        "Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5.",
        "Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6.",
        "La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7.",
        "Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2.",
        "LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes.",
        "Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23].",
        "Definición 1.",
        "Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2.",
        "Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23].",
        "Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1.",
        "Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1.",
        "Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones.",
        "En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23].",
        "Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación.",
        "Figura 1: Un escenario de edición en grupo en tiempo real.",
        "El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT.",
        "Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento.",
        "Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento.",
        "En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI.",
        "La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22].",
        "A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo,",
        "O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo,",
        "I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation?",
        "Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23].",
        "Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas.",
        "El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2.",
        "El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir,",
        "O1 y O3) [21].",
        "Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución.",
        "Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3.",
        "Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto.",
        "Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3.",
        "CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida.",
        "El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales.",
        "En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2).",
        "Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1.",
        "O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento.",
        "Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2.",
        "O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT.",
        "Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación.",
        "En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones.",
        "Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas.",
        "Para cualquier operación O, su inversa se denota por O^(-1).",
        "Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O.",
        "Si O es una operación original, entonces org(O) = O.",
        "Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento.",
        "En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento.",
        "Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]).",
        "Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento.",
        "Definición 3.",
        "La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1.",
        "El estado inicial del documento está representado por DS = {}. 2.",
        "Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales.",
        "Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación.",
        "Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O).",
        "Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O).",
        "Más precisamente, el contexto de una operación se define a continuación.",
        "Definición 4.",
        "El contexto de una operación 1.",
        "Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2.",
        "Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer.",
        "Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales.",
        "Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1.",
        "Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}.",
        "A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo.",
        "Definición 5.",
        "Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada).",
        "Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto.",
        "Definición 6.",
        "Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob.",
        "En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución.",
        "CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O).",
        "En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O.",
        "Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22].",
        "Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21].",
        "CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS.",
        "CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución.",
        "Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O.",
        "Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22].",
        "Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21].",
        "CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS.",
        "CC3 es necesario para ejecutar correctamente las operaciones.",
        "CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob).",
        "Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3).",
        "CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob.",
        "CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT.",
        "Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob.",
        "CC6 es necesario para aplicar correctamente las funciones de TI.",
        "En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones.",
        "Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente.",
        "Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación.",
        "Sea Oij una operación normal original generada en el sitio i con un número de secuencia j.",
        "Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4.",
        "Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones.",
        "Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha.",
        "Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original.",
        "Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O.",
        "Tanto O como O corresponden a la misma operación normal O.",
        "Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha.",
        "Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo.",
        "Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2.",
        "En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo.",
        "Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo.",
        "Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes.",
        "El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i.",
        "Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7.",
        "Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4].",
        "La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento.",
        "Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1.",
        "Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}.",
        "Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
        "Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3).",
        "Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto.",
        "Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4.",
        "En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento.",
        "Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas.",
        "Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones.",
        "En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O).",
        "Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación.",
        "El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O).",
        "El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer.",
        "Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central.",
        "El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento.",
        "COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS.",
        "Algoritmo 1.",
        "COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2.",
        "Ejecutar O; DS := DS ∪ {org(O)}.",
        "Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1.",
        "Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3.",
        "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
        "COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2).",
        "Esto es para mejorar el contexto de O a DS.",
        "En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2).",
        "El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O.",
        "Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1.",
        "Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4).",
        "Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2.",
        "El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5).",
        "Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3.",
        "Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3).",
        "Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1.",
        "Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1.",
        "Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2.",
        "Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}.",
        "Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}.",
        "Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2).",
        "Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}.",
        "Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT.",
        "En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}.",
        "Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1).",
        "Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario.",
        "Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21].",
        "Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado.",
        "En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo.",
        "COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento.",
        "Algoritmo 2.",
        "COT-DESHACER(O, DS) 1.",
        "O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2.",
        "COT-DO(O, DS). \n\nCOT-DO(O, DS).",
        "COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O.",
        "Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}.",
        "Primero, se crean O2 y C(O2) = {O2}.",
        "Entonces, se invoca a COT-DO con los parámetros O2 y DS.",
        "Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}.",
        "Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales.",
        "Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas.",
        "El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento.",
        "Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5.",
        "Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto.",
        "Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros.",
        "Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT.",
        "Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes.",
        "A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21].",
        "Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes.",
        "El procedimiento makeInverse(O) sigue directamente estas definiciones. 1.",
        "Propiedad de Convergencia 1 (PC1).",
        "Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2.",
        "Propiedad de Convergencia 2 (PC2).",
        "Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3.",
        "Propiedad Inversa 2 (PI2)4.",
        "Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4.",
        "Propiedad Inversa 3 (PI3).",
        "Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa.",
        "Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente.",
        "Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT.",
        "Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1.",
        "PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2.",
        "PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3.",
        "PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4.",
        "PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades.",
        "Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3.",
        "Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11].",
        "Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7).",
        "Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad.",
        "En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6.",
        "Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5).",
        "Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3.",
        "La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces).",
        "Procedimiento 2. transformar(O, CD) 1.",
        "Si CD = { }, asegúrate de TPsafety(O, CD); 2.",
        "Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
        "Procedimiento 3. asegurar la seguridad de TP (O, CD) 1.",
        "Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2.",
        "Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3.",
        "Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD).",
        "Procedimiento 4. hacer IP3safe Inverso(O, CD) 1.",
        "O := hacerInversa(O); C(O) := C(O) − {O}; 2.",
        "NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4.",
        "O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5.",
        "CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()).",
        "Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total.",
        "Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2.",
        "Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación.",
        "El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2.",
        "Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto.",
        "Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12].",
        "La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2.",
        "Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD.",
        "Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O.",
        "Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3.",
        "El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2).",
        "Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD.",
        "El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7.",
        "DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21].",
        "En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido.",
        "Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución.",
        "No hubo una representación explícita de un contexto de operación.",
        "Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21].",
        "En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación.",
        "Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones.",
        "Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa.",
        "Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto.",
        "El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también.",
        "Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales.",
        "Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales.",
        "La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento.",
        "La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3.",
        "La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad.",
        "COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto.",
        "El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3.",
        "En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21].",
        "Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución.",
        "Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial.",
        "Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer.",
        "Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21].",
        "Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas.",
        "En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente.",
        "Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior.",
        "Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento.",
        "En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21].",
        "Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente.",
        "Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente.",
        "Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones.",
        "Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones.",
        "Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto.",
        "Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión.",
        "Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio.",
        "Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones.",
        "COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación.",
        "Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales.",
        "COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT.",
        "En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT.",
        "OT es un sistema complejo con múltiples componentes interrelacionados.",
        "Se necesita un enfoque orientado al sistema para abordar los problemas de OT.",
        "Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT.",
        "Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos.",
        "La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT.",
        "En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla.",
        "En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño.",
        "Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas.",
        "La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos.",
        "En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal.",
        "Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional.",
        "Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa.",
        "Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21].",
        "Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos.",
        "Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional.",
        "Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles.",
        "Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas.",
        "Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes.",
        "Se debe tener precaución al interpretar los resultados de corrección.",
        "Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT.",
        "De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT.",
        "Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21].",
        "Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas.",
        "Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23].",
        "CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12].",
        "Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas.",
        "Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos.",
        "Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23].",
        "Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2.",
        "En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel.",
        "Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5].",
        "El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos.",
        "En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación.",
        "La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8.",
        "CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto).",
        "La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT.",
        "El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación.",
        "El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24].",
        "Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional.",
        "La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes.",
        "Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo. ",
        "REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer.",
        "Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas.",
        "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
        "Un cálculo para actualización concurrente.",
        "En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu.",
        "Generalizando la transformación operacional al lenguaje de marcado general estándar.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs.",
        "Control de concurrencia en sistemas de trabajo en grupo.",
        "En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang.",
        "Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo.",
        "En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari.",
        "Sobre el problema de consistencia en la computación distribuida móvil.",
        "En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002.",
        "ACM. [7] C. Ignat y M.C.",
        "Norrie.",
        "Editor colaborativo personalizable que se basa en el algoritmo treeOPT.",
        "En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch.",
        "Demostrando la corrección de las funciones de transformación en groupware en tiempo real.",
        "En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport.",
        "Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido.",
        "Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li.",
        "Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li.",
        "Preservando la relación de efectos de operación en editores de grupo.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun.",
        "Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas.",
        "En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack.",
        "Prueba de corrección del algoritmo adOPTado de Ressels.",
        "Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack.",
        "Operación transforma para una hoja de cálculo compartida distribuida.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister.",
        "Un marco para deshacer acciones en sistemas colaborativos.",
        "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins.",
        "Automatización de la reconciliación basada en semántica para bases de datos móviles.",
        "En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal.",
        "Tiempo lógico: capturando la causalidad en sistemas distribuidos.",
        "Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser.",
        "Reducir los problemas de deshacer en grupo.",
        "En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser.",
        "Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun.",
        "Un marco de notificación flexible para sistemas colaborativos.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun.",
        "Deshacer como inversión concurrente en editores de grupo.",
        "ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis.",
        "Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros.",
        "En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen.",
        "Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real.",
        "ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai.",
        "Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios.",
        "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen.",
        "Transformación operativa para procesamiento de texto colaborativo.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman.",
        "Convergencia de copias en un entorno colaborativo distribuido en tiempo real.",
        "En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen.",
        "Una técnica de edición colaborativa de tablas basada en adaptación transparente.",
        "En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen.",
        "Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real.",
        "En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen.",
        "Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord.",
        "En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288"
    ],
    "error_count": 3,
    "keys": {
        "operational transformation": {
            "translated_key": "Transformación Operacional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based <br>operational transformation</br> David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT <br>operational transformation</br> (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION <br>operational transformation</br> (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing <br>operational transformation</br> to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "<br>operational transformation</br> in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "<br>operational transformation</br> for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Operation Context and Context-based <br>operational transformation</br> David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT <br>operational transformation</br> (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "INTRODUCTION <br>operational transformation</br> (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "Generalizing <br>operational transformation</br> to the standard general markup language.",
                "<br>operational transformation</br> in real-time group editors: issues, algorithms, and achievements.",
                "<br>operational transformation</br> for collaborative word processing."
            ],
            "translated_annotated_samples": [
                "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas.",
                "La <br>Transformación Operacional</br> (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4].",
                "Generalizando la <br>transformación operacional</br> al lenguaje de marcado general estándar.",
                "Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros.",
                "Transformación operativa para procesamiento de texto colaborativo."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La <br>Transformación Operacional</br> (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la <br>transformación operacional</br> al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "cot": {
            "translated_key": "algoritmo COT",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The <br>cot</br> algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The <br>cot</br> algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the <br>cot</br> algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic <br>cot</br> algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The <br>cot</br> solutions to these transformation properties are presented in Section 6.",
                "Comparison of the <br>cot</br> work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the <br>cot</br> algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC <br>cot</br> ALGORITHM In the basic <br>cot</br> algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the <br>cot</br> algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The <br>cot</br> algorithm has two parts: the <br>cot</br>-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole <br>cot</br> algorithm. 4.1 <br>cot</br>-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "<br>cot</br>-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "<br>cot</br>-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "<br>cot</br>-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of <br>cot</br>-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how <br>cot</br>-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 <br>cot</br>-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In <br>cot</br>-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "<br>cot</br>-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "<br>cot</br>-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "<br>cot</br>-DO(O, DS).",
                "<br>cot</br>-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, <br>cot</br>-DO is invoked with parameters O2 and DS.",
                "Inside <br>cot</br>-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by <br>cot</br>-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic <br>cot</br> algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES <br>cot</br> is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic <br>cot</br> algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic <br>cot</br> algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic <br>cot</br> algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "<br>cot</br> SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of <br>cot</br> is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The <br>cot</br> solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The <br>cot</br> solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the <br>cot</br> solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The <br>cot</br> solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of <br>cot</br>, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 <br>cot</br> versus GOTO-ANYUNDO Both <br>cot</br> and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that <br>cot</br> achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "<br>cot</br> is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The <br>cot</br>-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the <br>cot</br> algorithm, <br>cot</br>-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the <br>cot</br> solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the <br>cot</br> algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the <br>cot</br> algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "<br>cot</br> is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "<br>cot</br> is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like <br>cot</br>) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on <br>cot</br> or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The <br>cot</br> algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of <br>cot</br> with respect to various transformation properties/conditions.",
                "Formal verification of <br>cot</br> correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of <br>cot</br>, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The <br>cot</br> algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The <br>cot</br> algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the <br>cot</br> algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "In this paper, we report the main results of this effort: the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The <br>cot</br> algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The <br>cot</br> algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the <br>cot</br> algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "In this paper, we report the main results of this effort: the theory of operation context and the <br>cot</br> (Context-based OT) algorithm."
            ],
            "translated_annotated_samples": [
                "En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto).",
                "El <br>algoritmo COT</br> es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3.",
                "El <br>algoritmo COT</br> no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación.",
                "Hemos implementado el <br>algoritmo COT</br> en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas.",
                "En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto)."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El <br>algoritmo COT</br> es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El <br>algoritmo COT</br> no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el <br>algoritmo COT</br> en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "context-based ot": {
            "translated_key": "OT basado en contexto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (<br>context-based ot</br>) algorithm."
            ],
            "translated_annotated_samples": [
                "En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (<br>OT basado en contexto</br>).",
                "En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (<br>OT basado en contexto</br>).",
                "CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (<br>OT basado en contexto</br>)."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (<br>OT basado en contexto</br>). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (<br>OT basado en contexto</br>). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (<br>OT basado en contexto</br>). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "causal-dependency": {
            "translated_key": "dependencia causal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define <br>causal-dependency</br>/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], <br>causal-dependency</br>/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "<br>causal-dependency</br> relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the <br>causal-dependency</br>/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture <br>causal-dependency</br> relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, <br>causal-dependency</br> relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "First, we define <br>causal-dependency</br>/-independency and briefly describe their limitations in Section 2.",
                "Following Lamport [9], <br>causal-dependency</br>/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "<br>causal-dependency</br> relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "In other words, the <br>causal-dependency</br>/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture <br>causal-dependency</br> relationships among original normal operations and to represent document states in terms of original normal operations."
            ],
            "translated_annotated_samples": [
                "Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2.",
                "Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23].",
                "Relación de <br>dependencia causal</br> → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2.",
                "En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación <br>dependencia/independencia del contexto</br>. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución.",
                "Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de <br>dependencia causal</br> entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de <br>dependencia causal</br> → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación <br>dependencia/independencia del contexto</br>. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de <br>dependencia causal</br> entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. ",
            "candidates": [],
            "error": [
                [
                    "dependencia causal",
                    "dependencia/independencia del contexto",
                    "dependencia causal"
                ]
            ]
        },
        "concurrency condition": {
            "translated_key": "condición de concurrencia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the <br>concurrency condition</br> alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "However, later research discovered that the <br>concurrency condition</br> alone is not sufficient to ensure the correctness of transformation."
            ],
            "translated_annotated_samples": [
                "Sin embargo, investigaciones posteriores descubrieron que la <br>condición de concurrencia</br> por sí sola no es suficiente para garantizar la corrección de la transformación."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la <br>condición de concurrencia</br> por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "concurrency relation": {
            "translated_key": "relación de concurrencia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the <br>concurrency relation</br> does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Furthermore, the <br>concurrency relation</br> does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23]."
            ],
            "translated_annotated_samples": [
                "Además, la <br>relación de concurrencia</br> no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la <br>relación de concurrencia</br> no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "inverse operation": {
            "translated_key": "operación inversa",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an <br>inverse operation</br> (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an <br>inverse operation</br> O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an <br>inverse operation</br> like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original <br>inverse operation</br> O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original <br>inverse operation</br> O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original <br>inverse operation</br>, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an <br>inverse operation</br>, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original <br>inverse operation</br> can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original <br>inverse operation</br> directly or indirectly corresponds to exactly one original normal operation.",
                "For example, <br>inverse operation</br> O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an <br>inverse operation</br> can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed <br>inverse operation</br> Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an <br>inverse operation</br> Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an <br>inverse operation</br>) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an <br>inverse operation</br> is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "The concept of causality is unsuitable to capture the relationships between an <br>inverse operation</br> (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an <br>inverse operation</br> O2.",
                "Moreover, after executing an <br>inverse operation</br> like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "To achieve the undo effect in [21], an original <br>inverse operation</br> O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "For an original <br>inverse operation</br> O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3."
            ],
            "translated_annotated_samples": [
                "El concepto de causalidad no es adecuado para capturar las relaciones entre una <br>operación inversa</br> (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición.",
                "El comando Deshacer (O2) en la Figura 1 se interpreta como una <br>operación inversa</br> O2.",
                "Además, después de ejecutar una <br>operación inversa</br> como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3.",
                "Para lograr el efecto de deshacer en [21], se debe definir una <br>operación inversa</br> original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O).",
                "Para una <br>operación inversa</br> original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una <br>operación inversa</br> (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una <br>operación inversa</br> O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una <br>operación inversa</br> como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una <br>operación inversa</br> original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una <br>operación inversa</br> original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "document state": {
            "translated_key": "estado del documento",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same <br>document state</br>.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) <br>document state</br>.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the <br>document state</br> that contains the effect of O2, whereas O1 is defined on the initial <br>document state</br>.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the <br>document state</br> including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same <br>document state</br> [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the <br>document state</br> including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the <br>document state</br> with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the <br>document state</br> can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current <br>document state</br> are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the <br>document state</br> which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current <br>document state</br> at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial <br>document state</br>.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current <br>document state</br> at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the <br>document state</br> with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the <br>document state</br> on which the operation is defined, the problem of context representation can be reduced into the problem of <br>document state</br> representation.",
                "In an OT-based group editor, each <br>document state</br> can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same <br>document state</br> must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a <br>document state</br>.",
                "Definition 3.",
                "<br>document state</br> representation A <br>document state</br> can be represented by DS as follows: 1.",
                "The initial <br>document state</br> is represented by DS = {}. 2.",
                "After executing an operation O of any type on the <br>document state</br> represented by DS, the new <br>document state</br> is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the <br>document state</br> representation, the context of an original normal operation should be the same as the representation of the <br>document state</br> from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the <br>document state</br> DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the <br>document state</br> DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the <br>document state</br> from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the <br>document state</br> DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the <br>document state</br> DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the <br>document state</br> DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the <br>document state</br>.",
                "As an example, consider the <br>document state</br> after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the <br>document state</br> after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This <br>document state</br> cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the <br>document state</br> after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a <br>document state</br> DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current <br>document state</br> representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial <br>document state</br> DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current <br>document state</br> representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a <br>document state</br> DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the <br>document state</br> DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the <br>document state</br> on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Another condition is that the two concurrent operations must be defined on the same <br>document state</br>.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) <br>document state</br>.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the <br>document state</br> that contains the effect of O2, whereas O1 is defined on the initial <br>document state</br>.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the <br>document state</br> including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same <br>document state</br> [23]."
            ],
            "translated_annotated_samples": [
                "Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo <br>estado del documento</br>.",
                "Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo <br>estado inicial del documento</br>.",
                "Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el <br>estado del documento</br> que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento.",
                "La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el <br>estado del documento</br> incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22].",
                "Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo <br>estado del documento</br> [23]."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo <br>estado del documento</br>. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo <br>estado inicial del documento</br>. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el <br>estado del documento</br> que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el <br>estado del documento</br> incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo <br>estado del documento</br> [23]. ",
            "candidates": [],
            "error": [
                [
                    "estado del documento",
                    "estado inicial del documento",
                    "estado del documento",
                    "estado del documento",
                    "estado del documento"
                ]
            ]
        },
        "original operation": {
            "translated_key": "operación original",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an <br>original operation</br>, we use the notation org(O) to denote the <br>original operation</br> of O.",
                "If O is an <br>original operation</br>, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the <br>original operation</br> O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an <br>original operation</br> is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an <br>original operation</br> Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an <br>original operation</br> Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an <br>original operation</br> O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any <br>original operation</br> Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an <br>original operation</br> to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same <br>original operation</br> are organized in the same version group.",
                "When an <br>original operation</br> is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the <br>original operation</br> in the transformation process, thus saving the overhead to transform the <br>original operation</br> into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Since every transformed operation must come from an <br>original operation</br>, we use the notation org(O) to denote the <br>original operation</br> of O.",
                "If O is an <br>original operation</br>, then org(O) = O.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the <br>original operation</br> O on the state C(O).",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an <br>original operation</br> is included in the context of another operation of any type.",
                "Context-dependency relation c → Given an <br>original operation</br> Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an <br>original operation</br> Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed)."
            ],
            "translated_annotated_samples": [
                "Dado que cada operación transformada debe provenir de una <br>operación original</br>, usamos la notación org(O) para denotar la <br>operación original</br> de O.",
                "Si O es una <br>operación original</br>, entonces org(O) = O.",
                "Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la <br>operación original</br> O en el estado C(O).",
                "A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una <br>operación original</br> está incluida en el contexto de otra operación de cualquier tipo.",
                "Relación de dependencia de contexto c → Dada una <br>operación original</br> Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una <br>operación original</br> Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada)."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una <br>operación original</br>, usamos la notación org(O) para denotar la <br>operación original</br> de O. Si O es una <br>operación original</br>, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la <br>operación original</br> O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una <br>operación original</br> está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una <br>operación original</br> Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una <br>operación original</br> Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "transformed operation": {
            "translated_key": "operación transformada",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every <br>transformed operation</br> must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a <br>transformed operation</br> O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a <br>transformed operation</br> O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the <br>transformed operation</br> Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a <br>transformed operation</br> whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Since every <br>transformed operation</br> must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "According to the definition of the IT function [23], a <br>transformed operation</br> O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "For a <br>transformed operation</br> O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the <br>transformed operation</br> Oa.",
                "This new inverse O must be IP3-safe because it is created from a <br>transformed operation</br> whose context has included all operations in NCD."
            ],
            "translated_annotated_samples": [
                "Dado que cada <br>operación transformada</br> debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O.",
                "Según la definición de la función de TI [23], una <br>operación transformada</br> O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O).",
                "Para una <br>operación transformada</br> O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales.",
                "Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la <br>operación transformada</br> Oa.",
                "Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una <br>operación transformada</br> cuyo contexto ha incluido todas las operaciones en NCD."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada <br>operación transformada</br> debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una <br>operación transformada</br> O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una <br>operación transformada</br> O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la <br>operación transformada</br> Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una <br>operación transformada</br> cuyo contexto ha incluido todas las operaciones en NCD. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "inverse cluster": {
            "translated_key": "clúster inverso",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The <br>inverse cluster</br> at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "The <br>inverse cluster</br> at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i."
            ],
            "translated_annotated_samples": [
                "El <br>clúster inverso</br> en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El <br>clúster inverso</br> en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "vector representation of operation context": {
            "translated_key": "representación vectorial del contexto de la operación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The <br>vector representation of operation context</br> can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the <br>vector representation of operation context</br> can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "The <br>vector representation of operation context</br> can also be used as the vector representation of the document state.",
                "Moreover, the <br>vector representation of operation context</br> can also be used to efficiently detect contextdependency/-independency relations."
            ],
            "translated_annotated_samples": [
                "La <br>representación vectorial del contexto de la operación</br> también puede ser utilizada como la representación vectorial del estado del documento.",
                "Además, la <br>representación vectorial del contexto de la operación</br> también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La <br>representación vectorial del contexto de la operación</br> también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la <br>representación vectorial del contexto de la operación</br> también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "operation context vector representation": {
            "translated_key": "representación vectorial del contexto de la operación",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "history buffer": {
            "translated_key": "búfer de historial",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the <br>history buffer</br> (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the <br>history buffer</br> position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the <br>history buffer</br>.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "This is different from the log or the <br>history buffer</br> (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "Context relationships among operations are derived from the causality relationships plus the <br>history buffer</br> position relationships among operations [23, 21].",
                "Under this scheme, inverse operations are not explicitly represented in the <br>history buffer</br>."
            ],
            "translated_annotated_samples": [
                "Esto es diferente de los esquemas de registro o de <br>búfer de historial</br> (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas.",
                "Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el <br>búfer de historial</br> entre las operaciones [23, 21].",
                "Bajo este esquema, las operaciones inversas no están explícitamente representadas en el <br>búfer de historial</br>."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de <br>búfer de historial</br> (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el <br>búfer de historial</br> entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el <br>búfer de historial</br>. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "exclusion transformation": {
            "translated_key": "Transformación de Exclusión",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (<br>exclusion transformation</br>) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (<br>exclusion transformation</br>) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21]."
            ],
            "translated_annotated_samples": [
                "A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (<br>Transformación de Exclusión</br>) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (<br>Transformación de Exclusión</br>) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "operation context": {
            "translated_key": "contexto de operación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>operation context</br> and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the <br>operation context</br> theory, including the definition of <br>operation context</br>, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "<br>operation context</br> 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of <br>operation context</br> is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of <br>operation context</br> To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent <br>operation context</br>.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the <br>operation context</br> theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an <br>operation context</br> can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an <br>operation context</br> with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the <br>operation context</br>, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of <br>operation context</br> can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of <br>operation context</br> can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "<br>operation context</br> and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of <br>operation context</br> The notion of <br>operation context</br> was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an <br>operation context</br>.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of <br>operation context</br> is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of <br>operation context</br> is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of <br>operation context</br>, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of <br>operation context</br> for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the <br>operation context</br>, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "The theory of <br>operation context</br> is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of <br>operation context</br> and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "<br>operation context</br> and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "In this paper, we report the main results of this effort: the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "In this paper, we report the main results of this effort: the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "Then, we present the key elements of the <br>operation context</br> theory, including the definition of <br>operation context</br>, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "<br>operation context</br> 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined."
            ],
            "translated_annotated_samples": [
                "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas.",
                "En este documento, informamos los principales resultados de este esfuerzo: la teoría del <br>contexto de operación</br> y el algoritmo COT (OT basado en contexto).",
                "En este documento, informamos los principales resultados de este esfuerzo: la teoría del <br>contexto de operación</br> y el algoritmo COT (OT basado en contexto).",
                "A continuación, presentamos los elementos clave de la teoría del <br>contexto de operación</br>, incluyendo la definición de <br>contexto de operación</br>, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3.",
                "CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del <br>contexto de operación</br> y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del <br>contexto de operación</br> y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del <br>contexto de operación</br>, incluyendo la definición de <br>contexto de operación</br>, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "ot": {
            "translated_key": "ot",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (<br>ot</br>) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for <br>ot</br> is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior <br>ot</br> systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated <br>ot</br> algorithms.",
                "After having designed, implemented, and experimented with a series of <br>ot</br> algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving <br>ot</br> problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based <br>ot</br>) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior <br>ot</br> control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (<br>ot</br>) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, <br>ot</br> has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of <br>ot</br> in solving both old and new problems.",
                "The soundness of the theoretical foundation for <br>ot</br> is crucial in this process.",
                "One theoretical underpinning of all existing <br>ot</br> algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential <br>ot</br> conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of <br>ot</br>.",
                "The dOPT algorithm was the first <br>ot</br> algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up <br>ot</br> algorithms.",
                "The causality theory limitation became even more prominent when <br>ot</br> was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated <br>ot</br> algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of <br>ot</br> algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving <br>ot</br> problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based <br>ot</br>) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior <br>ot</br> work, <br>ot</br> correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing <br>ot</br> algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in <br>ot</br> systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing <br>ot</br> conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In <br>ot</br> systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an <br>ot</br>-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in <br>ot</br> systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior <br>ot</br> algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior <br>ot</br> systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an <br>ot</br> system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an <br>ot</br> system.",
                "Different <br>ot</br> systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in <br>ot</br> literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the <br>ot</br> system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the <br>ot</br> system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the <br>ot</br> system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the <br>ot</br> system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an <br>ot</br> system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the <br>ot</br> system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior <br>ot</br> systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential <br>ot</br> conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior <br>ot</br> algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential <br>ot</br> conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the <br>ot</br> system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior <br>ot</br> algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 <br>ot</br> buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first <br>ot</br> algorithm that buffers and uses original operations for transformation.",
                "Several prior <br>ot</br> algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 <br>ot</br> correctness <br>ot</br> correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important <br>ot</br> correctness issues.",
                "<br>ot</br> is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing <br>ot</br> issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining <br>ot</br> solutions.",
                "Puzzles are subtle but representative scenarios in which certain <br>ot</br> properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an <br>ot</br> system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an <br>ot</br> system works or fails.",
                "In real <br>ot</br> system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify <br>ot</br> correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic <br>ot</br> research.",
                "Many <br>ot</br> components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete <br>ot</br> solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one <br>ot</br> component may be resolved easily, or avoided altogether, if this issue is addressed from a different <br>ot</br> component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different <br>ot</br> systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all <br>ot</br> systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many <br>ot</br> systems.",
                "They are insufficient because an <br>ot</br> system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by <br>ot</br> systems based on COT or some prior <br>ot</br> algorithms [26, 20, 12].",
                "One <br>ot</br> correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An <br>ot</br> system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early <br>ot</br> work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known <br>ot</br> puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based <br>ot</br>) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an <br>ot</br> system; it provides a new foundation for better understanding and resolving <br>ot</br> problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior <br>ot</br> control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future <br>ot</br> research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging <br>ot</br> applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (<br>ot</br>) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for <br>ot</br> is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior <br>ot</br> systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated <br>ot</br> algorithms.",
                "After having designed, implemented, and experimented with a series of <br>ot</br> algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving <br>ot</br> problems, reducing its complexity, and supporting its continual evolution."
            ],
            "translated_annotated_samples": [
                "Operación Contexto y <br>Transformación Operativa</br> Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La <br>Transformación Operativa</br> (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas.",
                "La base teórica de la <br>Terapia Ocupacional</br> es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones.",
                "La teoría de la causalidad ha sido la base de todos los <br>sistemas OT</br> anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección.",
                "Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en <br>algoritmos de OT</br> cada vez más intrincados y complicados.",
                "Después de haber diseñado, implementado y experimentado con una serie de <br>algoritmos de optimización combinatoria</br>, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua."
            ],
            "translated_text": "Operación Contexto y <br>Transformación Operativa</br> Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La <br>Transformación Operativa</br> (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la <br>Terapia Ocupacional</br> es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los <br>sistemas OT</br> anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en <br>algoritmos de OT</br> cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de <br>algoritmos de optimización combinatoria</br>, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. ",
            "candidates": [],
            "error": [
                [
                    "Transformación Operativa",
                    "Transformación Operativa",
                    "Terapia Ocupacional",
                    "sistemas OT",
                    "algoritmos de OT",
                    "algoritmos de optimización combinatoria"
                ]
            ]
        },
        "context-base ot": {
            "translated_key": "base de contexto",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "consistency maintenance": {
            "translated_key": "mantenimiento de la consistencia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for <br>consistency maintenance</br> and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for <br>consistency maintenance</br> in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting <br>consistency maintenance</br> (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting <br>consistency maintenance</br> (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for <br>consistency maintenance</br> (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to <br>consistency maintenance</br> [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both <br>consistency maintenance</br> and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "<br>consistency maintenance</br> based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for <br>consistency maintenance</br> and group undo, and is being applied to an increasing number of collaborative applications.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for <br>consistency maintenance</br> in plain-text group editors [4].",
                "In Section 4, we present the basic COT algorithm for supporting <br>consistency maintenance</br> (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "The COT algorithm has two parts: the COT-DO part for supporting <br>consistency maintenance</br> (do), and the COTUNDO part for supporting undo.",
                "For example, a solution that works well for <br>consistency maintenance</br> (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to <br>consistency maintenance</br> [21]."
            ],
            "translated_annotated_samples": [
                "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el <br>mantenimiento de la consistencia</br> y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas.",
                "La Transformación Operacional (TO) fue originalmente inventada para el <br>mantenimiento de la consistencia</br> en editores de texto plano de grupo [4].",
                "En la Sección 4, presentamos el algoritmo COT básico para el <br>mantenimiento de la consistencia</br> (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación.",
                "El algoritmo COT tiene dos partes: la parte COT-DO para <br>mantener la consistencia</br> (hacer) y la parte COT-UNDO para deshacer.",
                "Por ejemplo, una solución que funciona bien para el <br>mantenimiento de la consistencia</br> (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el <br>mantenimiento de la consistencia</br> [21]."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el <br>mantenimiento de la consistencia</br> y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el <br>mantenimiento de la consistencia</br> en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el <br>mantenimiento de la consistencia</br> (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para <br>mantener la consistencia</br> (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el <br>mantenimiento de la consistencia</br> (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el <br>mantenimiento de la consistencia</br> [21]. ",
            "candidates": [],
            "error": [
                [
                    "mantenimiento de la consistencia",
                    "mantenimiento de la consistencia",
                    "mantenimiento de la consistencia",
                    "mantener la consistencia",
                    "mantenimiento de la consistencia",
                    "mantenimiento de la consistencia"
                ]
            ]
        },
        "undo": {
            "translated_key": "deshacer",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group <br>undo</br>, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and <br>undo</br> of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group <br>undo</br> [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the <br>undo</br> problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level <br>undo</br> command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group <br>undo</br> under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the <br>undo</br> command <br>undo</br>(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the <br>undo</br> command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The <br>undo</br>(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct <br>undo</br> effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], <br>undo</br>(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of <br>undo</br>(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct <br>undo</br> effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, <br>undo</br>(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to <br>undo</br> some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the <br>undo</br> effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-<br>undo</br> ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to <br>undo</br> an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to <br>undo</br> O, and O may be generated to <br>undo</br> O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the <br>undo</br> command <br>undo</br>(O2) in Figure 1.",
                "Since <br>undo</br>(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting <br>undo</br>.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-<br>undo</br> To <br>undo</br> an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the <br>undo</br> command for selecting any operation to <br>undo</br> is part of the undo policy [21].",
                "This paper is confined to the discussion of the <br>undo</br> mechanism, which determines how to <br>undo</br> the selected operation in a given context.",
                "In COT-<br>undo</br>, <br>undo</br>(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-<br>undo</br> takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-<br>undo</br>(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-<br>undo</br> works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret <br>undo</br>(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and <br>undo</br> operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct <br>undo</br> effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-<br>undo</br>-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-<br>undo</br>-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an <br>undo</br>/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any <br>undo</br>/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and <br>undo</br> operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-<br>undo</br>-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the <br>undo</br>-part of a do-<br>undo</br>-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-<br>undo</br>-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-<br>undo</br> are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-<br>undo</br>-pair occurs not immediately after executing each inverse, but only when both the do-part and the <br>undo</br>-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and <br>undo</br> problems are considered; and an <br>undo</br> solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and <br>undo</br> problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and <br>undo</br> problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group <br>undo</br>.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and <br>undo</br> in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "<br>undo</br> as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group <br>undo</br>, and is being applied to an increasing number of collaborative applications.",
                "The COT algorithm is capable of supporting both do and <br>undo</br> of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group <br>undo</br> [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "The causality theory limitation became even more prominent when OT was applied to solve the <br>undo</br> problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level <br>undo</br> command) and other normal editing operations."
            ],
            "translated_annotated_samples": [
                "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la <br>reversión de grupo</br>, y se está aplicando a un número creciente de aplicaciones colaborativas.",
                "El algoritmo COT es capaz de admitir tanto la realización como la <br>reversión</br> de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3.",
                "En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo <br>deshacer en grupo</br> [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16].",
                "La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el <br>problema de deshacer</br> en editores de grupo.",
                "El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un <br>comando de deshacer</br> a nivel meta) y otras operaciones normales de edición."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la <br>reversión de grupo</br>, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la <br>reversión</br> de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo <br>deshacer en grupo</br> [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el <br>problema de deshacer</br> en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un <br>comando de deshacer</br> a nivel meta) y otras operaciones normales de edición. ",
            "candidates": [],
            "error": [
                [
                    "reversión de grupo",
                    "reversión",
                    "deshacer en grupo",
                    "problema de deshacer",
                    "comando de deshacer"
                ]
            ]
        },
        "group editor": {
            "translated_key": "editor de grupo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based <br>group editor</br>, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [
                "In an OT-based <br>group editor</br>, each document state can be uniquely represented by the set of original operations executed so far on the document."
            ],
            "translated_annotated_samples": [
                "En un <br>editor de grupo</br> basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento."
            ],
            "translated_text": "Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence \"O1).\" does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un <br>editor de grupo</br> basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. \n\nO := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). \n\nCOT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.\nTraducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "distribute application": {
            "translated_key": "distribuir la aplicación",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}