{
    "id": "J-17",
    "original_text": "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players. This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20]. We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent. This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling. We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism. This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion. When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism. These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain. Our constructions are novel in two respects. First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity. Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains. However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting. Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism. This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design. Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1. INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm. Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal. Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention. In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization. There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine. Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule. Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]). Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost). Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times. Such a mechanism is called a truthful mechanism. The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players. Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design. In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques. The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain. Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary. This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j. Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20]. We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain. On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms. Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound. In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines. Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i. This assumption makes the domain of players types single-dimensional. Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains. Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism. The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.) Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio. Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions). Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains. In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine. More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high). We call this model the jobdependent two-values case. This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically. A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model. Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern. Thus, the private information of each machine is a vector specifying which jobs are low and high on it. Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem. Our Results and Techniques We present various positive results for our multidimensional scheduling domains. Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism. This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem. Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting. Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable). Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness. We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem. These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain. Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines). By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations). The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms. Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability). This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]). But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains. Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains. The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]). It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain. Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains. Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism. At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism. But, cycle monotonicity does allow us to prove such a statement. In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement. The method for converting approximation algorithms into truthful mechanisms involves another novel idea. Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule. Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio. We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment. For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling. This preserves truthfulness, but we lose another additive factor equal to the approximation ratio. Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design. Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines. They gave an m-approximation positive result and proved various lower bounds. Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism. This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13]. The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known. Lenstra, Shmoys and Tardos [18] gave the first such algorithm. Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan. Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds. We use their procedure in our randomized mechanism. The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]). This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3]. As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13]. For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24]. But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems. Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design. In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly. Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations. Lipton et al. [19] showed that the latter objective cannot be implemented truthfully. These lower bounds were strengthened in [20]. 2. PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine. In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j. We consider two special cases of this problem: 1. The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known. This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2. The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j. We say that a job j is low on machine i if pij = Lj, and high if pij = Hj. We will use the terms schedule and assignment interchangeably. We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j. We will also consider randomized algorithms and algorithms that return a fractional assignment. In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j. For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments). We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li. The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design. Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure. Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents. The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines. Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost. We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs. A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j. The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility. The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments. This is made precise using the notion of dominant-strategy truthfulness. Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare. We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables. The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments. For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector. Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)). For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known. The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it. We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3. CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity. This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains. However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms. Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness. One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms. We include a brief exposition on it for completeness. The exposition here is largely based on [11]. Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a. In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a. Let Vi denote the set of all possible types of player i. A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices). The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i). A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful? It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i). Now fix a player i, and fix the declarations v−i of the others. We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.) Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory. Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b. Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles. Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a. This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles. Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1. Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain. Fix a player i, p−i, and any p1 i , . . . , pK i . Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment. We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0. Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem. For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4. A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞). We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism. This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box. Our construction and proof are simple, and based on two ideas. First, as outlined above, we prove truthfulness using cycle monotonicity. It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this. Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules. This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite. We should point out however that one cannot simply plug in the results of [16]. Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism. VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known. We use the following result adapted from [16]. Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism. Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j. Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation. Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses. Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism. This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3). Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case. Thus, we can apply Corollary 3.4 here. To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1. Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14]. Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1. Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee. We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity. Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m. Then A satisfies cycle-monotonicity. Proof. Fix a player i, and the vector of processing times of the other players p−i. We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1. We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds. Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj. This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj. We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj. We set k = k, and then start a new maximal segment with index k + 1. Note that k = k and k + 1 = k − 1. We now have a subset of indices and we can continue recursively. So all indices are included in some maximal segment. We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Adding this for each segment yields the desired inequality. So now focus on a maximal segment k , k + 1, . . . , k − 1, k . Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj. Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj. We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3. For simplicity, first suppose that the approximation algorithm returns an integral schedule. The idea is to simply spread this schedule. We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i. The resulting assignment clearly satisfies the desired properties. Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled. This spreading out can also be done if the initial schedule is fractional. We now describe the algorithm precisely. Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.) Our algorithm, which we call A , returns the following assignment xF . Initialize xF ij = 0 for all i, j. For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m. Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm. Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p). Proof. First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1. We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m. If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m. Thus, by Lemma 4.3, A satisfies cycle monotonicity. The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p). Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p). If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p). Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism. The computation of payments will depend on the actual approximation algorithm used. Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time. Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism. Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism. Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5. A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j. In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij. As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity. We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with. We describe our algorithm in Section 5.1. In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity. In Section 5.3, we compute explicit payments giving a truthful mechanism. Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan. Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L). Plugging this into (3) and dividing by (H − L), we get the following. Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation. We will assume that L, H are integers, which is without loss of generality. A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized. Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L . Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i. We will therefore use the terms assignment and flow interchangeably. Moreover, there is always an integral max-flow (since all capacities are integers). We will often refer to such a max-flow as the max-flow for (p, T). We need one additional concept before describing the algorithm. There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows. Fix some max-flow. Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T . For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T . Define np,T |T = P i ni p,T |T . We define a prefix-maximal flow or assignment for T as follows. Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T . That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ). An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow. The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1). Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1. A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists. We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths. Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1. Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ . Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2. Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3. Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows. Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase). Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p). The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it. But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T . Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }. This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T . Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity. This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p). Proof. If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L . Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p). So in this case the makespan is at most (and hence exactly) OPT(p). Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof. Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule. The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p). So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T. Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L . Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof. Suppose j is assigned to machine i in step 3. If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value. So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p). Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p). But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction. Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p). Proof. If OPT(p) < H, then by Claim 5.4, we are done. So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done. So assume that there are some unassigned jobs after step 2. We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ . Suppose the claim is false. Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ . Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i. So li > T − H/m at this point. Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li. So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6). Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines. Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction. If T = T∗ (p), this follows from the definition of T∗ (p). If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p). So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H. This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j. If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof. Let Gp denote the residual graph for (p , T) and flow x . Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x . Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T). Thus, x is a valid flow for (p, T). But it is not a max-flow, since np,T > np ,T . So there exists an augmenting path P in the residual graph for (p, T) and flow x . Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow. In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t). All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0. But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x . Let L denote the all-low processing time vector. Define TL i (p−i) = T∗ (L, p−i). Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL . Also, let pL = (L, p−i). Note that T∗ (p) ≥ TL for every instance p = (pi, p−i). Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)). Then, the low-load on machine i is at most TL . Proof. Let T∗ = T∗ (p). If T∗ = TL , then this is clearly true. Otherwise, consider the assignment x truncated at TL . Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ). Also, np,T L < npL,T L because T∗ > TL . So by Lemma 5.8, this truncated flow must assign all the low jobs of i. Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow. Thus, the low-load of i is at most TL . Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively. Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6). Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds. Proof. Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ). Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x. Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H . Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 . Since T1 > TL , we must have np1,T L < npL,T L . So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow. Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed. Lemma 5.11 Suppose T∗ (p1 ) = TL . Then (7) holds. Proof. Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ). Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively. Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}. Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9). Let T = |S | · L. We consider two cases. Suppose first that T ≤ TL . Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i. This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL . Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L . The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL . Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0. Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 . We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 . The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|. Thus we get the inequality |S |·L+(N −|S |)·H > ˆT. Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0). The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above. By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT. Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT. But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L . Lemma 5.12 Algorithm 2 satisfies cycle monotonicity. Proof. Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L . Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity. Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism. To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time. It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment). Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments. Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i. For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully). Let Hi denote the number of jobs assigned to machine i in step 3. By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis). Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T . The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices). The first and second terms in (10), when subtracted from is load li equate is cost to the total load. The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9). Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view. It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm. However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments. The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism. Lemma 5.13 Fix a player i and the other players declarations p−i. Let is true type be p1 i . Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i . Proof. Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i). Since p−i is fixed, we omit p−i from the expressions below for notational clarity. The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L . Thus, (7) implies that c1 i ≤ c2 i . Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value. The payments given by (10) are not individually rational as they actually charge a player a certain amount. However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition. In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10). Note that this is a constant for player i. Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ . As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i). This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set. This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14. Let H = α·L for some 2 < α < 2.5 that we will choose later. There are two machines I, II and seven jobs. Consider the following two scenarios: Scenario 1. Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L. The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2. If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II. In scenario 2, machine I has the same processing-time vector. Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5. The second-best schedule for this scenario has makespan at least Second2 = 5L. Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14. Proof. We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios. This follows because otherwise cycle monotonicity is violated for machine II. Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0. Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364. We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj. For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j. Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij . Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines. Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines. Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p). The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism. But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism. Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6. REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani. Truthful approximation mechanisms for scheduling selfish related machines. In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer. Mechanisms for discrete optimization with rational agents. PhD thesis, Cornell University, 2004. [3] A. Archer and ´E. Tardos. Truthful mechanisms for one-parameter agents. In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano. Deterministic truthful approximation mechanisms for scheduling related machines. In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani. Allocating indivisible goods. In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation. Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking. Approximation techniques for utilitarian mechanism design. In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali. A lower bound for scheduling mechanisms. In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke. Multipart pricing of public goods. Public Choice, 8:17-33, 1971. [10] T. Groves. Incentives in teams. Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra. Characterizing dominant strategy mechanisms with multi-dimensional types, 2004. Working paper. [12] L. A. Hall. Approximation algorithms for scheduling. In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems. PWS Publishing, MA, 1996. [13] A. Kov´acs. Fast monotone 3-approximation algorithm for scheduling related machines. In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan. Approximation algorithms for scheduling on multiple machines. In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan. Towards a characterization of truthful combinatorial auctions. In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy. Truthful and near-optimal mechanism design via linear programming. In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham. Truth revelation in approximately efficient combinatorial auctions. Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E. Tardos. Approximation algorithms for scheduling unrelated parallel machines. Math. Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. On approximately fair allocations of indivisible goods. In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira. Setting lower bounds on truthfulness. In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson. Optimal auction design. Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen. Algorithmic mechanism design. Games and Econ. Behavior, 35:166-196, 2001. [23] J. C. Rochet. A necessary and sufficient condition for rationalizability in a quasilinear context. Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu. Weak monotonicity suffices for truthfulness on convex domains. In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E. Tardos. An approximation algorithm for the generalized assignment problem. Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey. Counterspeculations, auctions, and competitive sealed tenders. J. Finance, 16:8-37, 1961. 261",
    "original_translation": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un dominio fraccional nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas. Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación. Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces. Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas. Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz. Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorio de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13]. El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro mecanismo aleatorio. La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13]. Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales. Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos. En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia. Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas. Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz. Estos límites inferiores fueron fortalecidos en [20]. PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina. En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos. Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2. El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj. Usaremos los términos horario y tarea indistintamente. Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j. También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional. En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li. El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos. El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados. Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j. El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias. Para un mecanismo aleatorio, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en expectativa para un mecanismo aleatorio, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)). Para nuestros dos dominios de programación, la suposición informativa es que los valores Lj, Hj son de conocimiento público. La información privada de una máquina es qué trabajos tienen valor Lj (o L) y cuáles tienen valor Hj (o H) en ella. Enfatizamos que ambos de nuestros dominios son multidimensionales, ya que cada máquina i necesita especificar un vector que indique qué trabajos son bajos y altos en ella. Aunque la veracidad se define en términos de pagos, resulta que en realidad la veracidad se reduce a una cierta condición algorítmica de monotonicidad. Esto parece haber sido observado por primera vez para dominios multidimensionales por Rochet [23] en 1987, y ha sido utilizado con éxito en el diseño algorítmico de mecanismos varias veces, pero para dominios unidimensionales. Sin embargo, para dominios multidimensionales, la condición de monotonía es más compleja y no ha habido éxito en emplearla en el diseño de mecanismos veraces. La mayoría de los resultados positivos para dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad. Una de las principales contribuciones de este artículo es demostrar que la condición de monotonía para entornos multidimensionales, a veces llamada monotonía cíclica, puede ser efectivamente utilizada para diseñar mecanismos veraces. Incluimos una breve exposición sobre ello para completitud. La exposición aquí se basa en gran medida en [11]. La monotonía cíclica se describe mejor en el marco abstracto de elección social: hay un conjunto finito A de alternativas, hay m jugadores, y cada jugador tiene un tipo privado (función de valoración) v: A → R, donde vi(a) debe interpretarse como su valor para la alternativa a. En el ámbito de la programación, A representa todas las posibles asignaciones de trabajos a máquinas, y vi(a) es el negativo de su carga en el horario a. Que Vi denote el conjunto de todos los posibles tipos de jugador i. Un mecanismo es una tupla (f, {Pi}) donde f : V1 × · · · × Vm → A es el algoritmo para elegir la alternativa, y Pi : V1 × · · · × Vm → A es el precio cobrado al jugador i (en el contexto de programación, el mecanismo paga a los jugadores, lo que corresponde a precios negativos). El mecanismo es veraz si para cada i, cada v−i ∈ V−i = Q i =i Vi, y cualquier vi, vi ∈ Vi, tenemos que vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), donde a = f(vi, v−i) y b = f(vi, v−i). Una pregunta básica que surge es si dado un algoritmo f: V1 × · · · × Vm → A, ¿existen precios que harán que el mecanismo resultante sea veraz? Es bien sabido (ver por ejemplo [15]) que el precio Pi solo puede depender de la alternativa elegida y las otras declaraciones, es decir, podemos escribir Pi : V−i × A → R. Por lo tanto, la veracidad implica que para cada i, cada v−i ∈ V−i, y cualquier vi, vi ∈ Vi con f(vi, v−i) = a y f(vi, v−i) = b, tenemos vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i). Ahora fija un jugador i, y fija las declaraciones v−i de los demás. Buscamos una asignación a las variables {Pa}a∈A tal que vi(a) − vi(b) ≥ Pa − Pb para todo a, b ∈ A y vi ∈ Vi con f(vi, v−i) = a. (Estrictamente hablando, deberíamos usar A = f(Vi, v−i) en lugar de A aquí). Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. \n\nDefina δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {Pa}a∈A tal que Pa − Pb ≤ δa,b ∀a, b ∈ A (2). Esto se resuelve fácilmente al observar el grafo de asignación y aplicar un resultado básico estándar de teoría de grafos. Definición 3.1 (Gui et al. [11]): El grafo de asignación de f es un grafo dirigido ponderado G = (A, E) donde E = A × A y el peso de una arista b → a (para cualquier a, b ∈ A) es δa,b. Teorema 3.2 Existe una asignación factible para (2) si y solo si el grafo de asignación no tiene ciclos de longitud negativa. Además, si todos los ciclos son no negativos, una asignación factible es 255 obtenida de la siguiente manera: fije un nodo arbitrario a∗ ∈ A y establezca Pa como la longitud del camino más corto desde a∗ hasta a. Esto lleva a la siguiente definición, que es otra forma de expresar la condición de que el grafo de asignación no tenga ciclos negativos. Definición 3.3 (Monotonía de ciclo) Una función de elección social f satisface la monotonía de ciclo si para cada jugador i, cada v−i ∈ V−i, cada entero K, y cada v1 i , . . . , vK i ∈ Vi, Σ k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 donde ak = f(vk i , v−i) para 1 ≤ k ≤ K, y aK+1 = a1. Corolario 3.4 Existen precios P tales que el mecanismo (f, P) es veraz si y solo si f satisface la monotonicidad del ciclo. Ahora consideramos nuestro dominio específico de programación. Fija un jugador i, p−i, y cualquier p1 i, . . . , pK i. Sea x(pk i , p−i) = xk para 1 ≤ k ≤ K, y sea xK+1 = x1 , pK+1 = p1 . xk podría ser una asignación {0, 1} o una asignación fraccional. Tenemos vk i (xk ) = − P j xk ijpk ij, por lo que la monotonía del ciclo se traduce en PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0. Reorganizando, obtenemos KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Por lo tanto, (3) reduce nuestro problema de diseño de mecanismos a un problema algorítmico concreto. Para la mayor parte de este documento, ignoraremos consecuentemente cualquier consideración estratégica y nos enfocaremos en diseñar un algoritmo de aproximación para minimizar el makespan que cumpla con (3). 4. Una TÉCNICA GENERAL PARA OBTENER MECANISMOS ALEATORIOS En esta sección, consideramos el caso de valores Lj, Hj dependientes del trabajo (con Lj ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde Hj = ∞). Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se proporciona como una caja negra. Nuestra construcción y demostración son simples, y se basan en dos ideas. Primero, como se ha mencionado anteriormente, demostramos la veracidad utilizando la monotonía de ciclo. Parece poco probable que para un algoritmo de aproximación arbitrario dado solo como una caja negra, se pueda encontrar pagos para demostrar la veracidad; pero la ciclo-monotonía nos permite demostrar precisamente esto. Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un dominio fraccional y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros. Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el uso de mecanismos fraccionarios para obtener mecanismos veraces en expectativa. No está claro si el Teorema 3.2, y por lo tanto, esta afirmación, se cumple si A no es finito. Debemos señalar, sin embargo, que no se puede simplemente ingresar los resultados de [16]. Sus resultados son válidos para problemas de maximización del bienestar social y se basan en el uso de VCG para obtener un mecanismo fraccional veraz. Sin embargo, VCG no se aplica a la minimización del makespan, y en nuestro caso ni siquiera se conoce la existencia de un mecanismo fraccional veraz cercano a óptimo. Utilizamos el siguiente resultado adaptado de [16]. Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, P) un mecanismo fraccional veraz. Sea A un algoritmo de redondeo aleatorio que, dado un asignación fraccional x, produce una asignación aleatoria X tal que E ˆ Xij ˜ = xij para todo i, j. Entonces existen pagos P tales que el mecanismo M = (A, P) es veraz en promedio. Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de lanzamientos de moneda. Sea OPT(p) el makespan óptimo (sobre horarios enteros) para la instancia p. Como primer paso, tomamos un algoritmo de aproximación c y lo convertimos en un mecanismo fraccional de verdad de aproximación 2c. Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (satisfaciendo ciertas propiedades) de makespan a lo sumo c · OPT(p) para cada instancia p. Demostramos la veracidad mostrando que el algoritmo fraccional satisface la monotonía de ciclo (3). Observa que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinito): su cardinalidad es a lo sumo la del dominio de entrada, que es a lo sumo 2mn en el caso de dos valores. Por lo tanto, podemos aplicar el Corolario 3.4 aquí. Para convertir este mecanismo fraccional veraz en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que cumpla con los requisitos del Lema 4.1. Afortunadamente, dicho procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14]. Lema 4.2 (Kumar et al. [14]): Dada una asignación fraccional x y un vector de tiempos de procesamiento p, existe un procedimiento de redondeo aleatorio que produce una asignación X (aleatoria) tal que, 1. para cualquier i, j, E ˆ Xij ˜ = xij. 2. para cualquier i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij con probabilidad 1. La propiedad 1 se utilizará para obtener veracidad en la expectativa, y la propiedad 2 nos permitirá demostrar una garantía de aproximación. Primero demostramos que cualquier algoritmo que devuelva una asignación fraccional con ciertas propiedades satisface la monotonía de ciclo. Lema 4.3 Sea A un algoritmo que, para cualquier entrada p, produce una asignación (fraccional) x tal que, si pij = Hj entonces xij ≤ 1/m, y si pij = Lj entonces xij ≥ 1/m. Entonces A satisface la ciclo-monotonía. Prueba. Fija un jugador i y el vector de tiempos de procesamiento de los otros jugadores p−i. Necesitamos demostrar (3), es decir, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 para cada p1 i , . . . , pK i , donde el índice k = K + 1 se toma como k = 1. Demostraremos que para cada trabajo j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Si pk ij es el mismo para todos los k (ya sea siempre Lj o siempre Hj), entonces la desigualdad anterior claramente se cumple. De lo contrario, podemos dividir los índices 1, . . . , K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos k , k + 1, . . . , k − 1, k (donde K + 1 ≡ 1) tal que pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj. Esto se cumple porque debe haber algún k tal que pk ij = Hj > pk−1 ij = Lj. Tomamos k = k y luego seguimos incluyendo índices en este segmento hasta que alcancemos un k tal que pk ij = Lj y pk+1 ij = Hj. Establecemos k = k, y luego comenzamos un nuevo segmento maximal con índice k + 1. Ten en cuenta que k = k y k + 1 = k − 1. Ahora tenemos un subconjunto de índices y podemos continuar de forma recursiva. Entonces, todos los índices están incluidos en algún segmento maximal. Mostraremos que para cada segmento maximal k, k +1, . . . , k, P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Agregar esto para cada segmento produce la desigualdad deseada. Así que ahora concéntrate en un segmento maximal k, k + 1, . . . , k − 1, k. Por lo tanto, existe un k∗ tal que para k ≤ k < k∗ , tenemos pk ij = Hj, y para k∗ ≤ k ≤ k , tenemos pk ij = Lj. Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk∗ ij dado que pk ij = Hj y pk∗ ij = Lj. Ahora describimos cómo usar un algoritmo de c-aproximación para obtener un algoritmo que cumpla con la propiedad en el Lema 4.3. Para simplificar, primero supongamos que el algoritmo de aproximación devuelve un horario integral. La idea es simplemente difundir este horario. Tomamos cada trabajo j asignado a una máquina de alta y lo asignamos en una extensión de 1/m en todas las máquinas; para cada trabajo j asignado a una máquina de baja, digamos i, asignamos una fracción de 1/m a las otras máquinas donde es baja, y asignamos la fracción restante (que es al menos 1/m) a i. La asignación resultante satisface claramente las propiedades deseadas. También observe que la carga en cualquier máquina ha aumentado como máximo en 1 m · (carga en otras máquinas) ≤ makespan, y por lo tanto el makespan se ha duplicado como máximo. Esta distribución también se puede hacer si el horario inicial es fraccionado. Ahora describimos el algoritmo con precisión. Algoritmo 1 Sea A cualquier algoritmo que, para cualquier entrada p, genere una asignación posiblemente fraccional x tal que xij > 0 implica que pij ≤ T, donde T es el makespan de x. (En particular, cabe destacar que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades). Nuestro algoritmo, al que llamamos A, devuelve la siguiente asignación xF. Inicializar xF ij = 0 para todos los i, j. Para cada i, j, 1. si pij = Hj, establezca xF ij = P i :pi j =Hj xi j/m; 2. si pij = Lj, establezca xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m. Teorema 4.4 Supongamos que el algoritmo A cumple las condiciones del Algoritmo 1 y devuelve un makespan de a lo sumo c·OPT(p) para cada p. Entonces, el algoritmo A construido anteriormente es una aproximación 2c, algoritmo fraccional cíclico-monótono. Además, si xF ij > 0 en la entrada p, entonces pij ≤ c · OPT(p). Prueba. Primero, nota que xF es una asignación válida: para cada trabajo j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1. También tenemos que si pij = Hj, entonces xFij = Pi: pij = Hj xij/m ≤ 1/m. Si pij = Lj, entonces xF ij = xij(1 − /m) + P i =i xi j/m donde = |{i = i : pi j = Lj}| ≤ m − 1; por lo tanto, xF ij ≥ P i xi j/m ≥ 1/m. Por lo tanto, según el Lema 4.3, A satisface la monotonía de ciclo. La carga total en cualquier máquina i bajo xF es a lo sumo P j: pij = Hj P i: pij = Hj Hj · xi j m + P j: pij = Lj Lj ` xij + P i = i xi j m ´, que es a lo sumo P j pijxij + P i = i P j pijxi j/m ≤ 2c · OPT(p). Finalmente, si xF ij > 0 y pij = Lj, entonces pij ≤ OPT(p). Si pij = Hj, entonces para algún i (posiblemente i) con pij = Hj, tenemos xi j > 0, por lo tanto, por suposición, pij = Hj = pij ≤ c · OPT(p). El Teorema 4.4 combinado con los Lemas 4.1 y 4.2, proporciona un mecanismo de aproximación 3c, veraz en expectativa. La computación de los pagos dependerá del algoritmo de aproximación actual utilizado. La Sección 3, sin embargo, proporciona un procedimiento explícito para calcular los pagos garantizando la veracidad, aunque quizás no en tiempo polinómico. Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Tomando A en el Algoritmo 1 como el algoritmo que devuelve una asignación óptima de LP que cumple las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de aproximación 3. Corolario 4.6 Existe un mecanismo veraz-en-expectativa con una proporción de aproximación de 3 para el escenario Lj-Hj. 5. Un MECANISMO DETERMINISTA PARA EL CASO DE DOS VALORES Presentamos ahora un mecanismo determinista de aproximación 2-veraz para el caso donde pij ∈ {L, H} para todo i, j. En la secuela, a menudo diremos que j está asignado a una máquina de baja carga para indicar que j está asignado a una máquina i donde pij = L. Llamaremos a un trabajo j un trabajo de baja carga de la máquina i si pij = L; la carga baja de i es la carga en i debido a sus trabajos de baja carga, es decir, P j:pij = L xijpij. Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que cumpla con la monotonía de ciclo. Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar. Describimos nuestro algoritmo en la Sección 5.1. En la Sección 5.2, acotamos su garantía de aproximación y demostramos que cumple con la ciclo-monotonía. En la Sección 5.3, calculamos los pagos explícitos proporcionando un mecanismo veraz. Finalmente, en la Sección 5.4 demostramos que ningún mecanismo determinista puede lograr el makespan óptimo. Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).\n\nDefina nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Entonces, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L). Sustituyendo esto en (3) y dividiendo por (H − L), obtenemos lo siguiente. Proposición 5.1 La monotonía cíclica en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador i, cada p−i, cada entero K, y cada p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación cíclicamente monótono A continuación describimos un algoritmo que satisface la condición (6) y logra una aproximación de 2. Supondremos que L, H son enteros, lo cual no limita la generalidad. Un componente fundamental de nuestro algoritmo será un procedimiento que tome un umbral de carga entero T y calcule una asignación parcial entera x de trabajos a máquinas de manera que (a) un trabajo solo se asigna a una máquina de baja carga; (b) la carga en cualquier máquina sea como máximo T; y (c) se maximice el número de trabajos asignados. Tal asignación se puede calcular resolviendo un problema de flujo máximo: construimos un grafo bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y una arista (j, i) de capacidad infinita si pij = L. También agregamos un nodo fuente s con aristas (s, j) de capacidad 1, y un nodo sumidero t con aristas (i, t) de capacidad T/L. Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de makespan de a lo sumo T, donde xij = 1 si y solo si hay un flujo de 1 en la arista de j a i. Por lo tanto, utilizaremos los términos asignación y flujo indistintamente. Además, siempre hay un flujo máximo integral (ya que todas las capacidades son números enteros). A menudo nos referiremos a dicho flujo máximo como el flujo máximo para (p, T). Necesitamos un concepto adicional antes de describir el algoritmo. Podría haber potencialmente muchos flujos máximos y estaremos interesados en los más equilibrados, los cuales definimos formalmente de la siguiente manera. Arregla algún flujo máximo. Deje que ni p,T sea la cantidad de flujo en el borde (i, t) (o equivalentemente el número de trabajos asignados a i en el horario correspondiente), y deje que np,T sea el tamaño total del flujo máximo, es decir, np,T = Σ i ni p,T. Para cualquier T ≤ T, definimos ni p,T |T = min(ni p,T , T ), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo T. Define np,T |T = P i ni p,T |T . \n\nDefina np,T |T = P i ni p,T |T. Definimos un flujo o asignación de prefijo-maximal para T de la siguiente manera. Definición 5.2 (Flujo prefijo-maximal) Un flujo para la red anterior con umbral T es prefijo-maximal si para cada entero T ≤ T, tenemos np,T |T = np,T. Es decir, en un flujo de prefijo máximo para (p, T), si truncamos el flujo en algún T ≤ T, nos queda un flujo máximo para (p, T). Un hecho elemental sobre los flujos es que si una asignación/flujo x no es un flujo máximo para (p, T) entonces debe existir un camino de aumento P = (s, j1, i1, . . . , jK , iK , t) en el grafo residual que nos permita aumentar el tamaño del flujo. La interpretación es que en la asignación actual, j1 no está asignado, xi j = 0, lo cual se denota por las aristas directas (j , i), y xi j +1 = 1, lo cual se denota por las aristas inversas (i, j +1). Aumentar x usando P cambia la asignación de manera que cada j se asigna a i en la nueva asignación, lo que aumenta el valor del flujo en 1. Un camino de aumento simple no disminuye la carga de ninguna máquina; por lo tanto, se puede argumentar que siempre existe un flujo maximal de prefijo para un umbral T. Primero calculamos un flujo máximo para el umbral 1, utilizamos caminos de aumento simples para aumentarlo a un flujo máximo para el umbral 2, y repetimos el proceso, cada vez aumentando el flujo máximo para el umbral anterior t a un flujo máximo para el umbral t + 1 utilizando caminos de aumento simples. Algoritmo 2 Dado un vector de tiempos de procesamiento p, construir una asignación de trabajos a máquinas de la siguiente manera. 1. Calcular T∗ (p) = min ˘ T ≥ H, T múltiplo de L : np,T · L + (n − np,T ) · H ≤ m · T ¯ . Se observa que np,T ·L+(n−np,T )·H −m·T es una función decreciente de T, por lo que T∗ (p) se puede calcular en tiempo polinómico mediante búsqueda binaria. Calcular un flujo prefijo-maximal para el umbral T∗ (p) y la asignación parcial correspondiente (es decir, j se asigna a i si hay 1 unidad de flujo en el borde (j, i)). 3. Asigna los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera. Considera estos trabajos en un orden arbitrario y asigna cada trabajo a la máquina con la carga actual más baja (donde la carga incluye los trabajos asignados en la fase de flujo). Nuestro algoritmo necesita calcular una asignación prefijo-maximal para el umbral T∗ (p). La prueba que muestra la existencia de un flujo maximal de prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo. Pero hay que tener en cuenta que el flujo máximo permanece igual para cualquier T ≥ T = n · L. Por lo tanto, un flujo maximal de prefijo para T también es maximal de prefijo para cualquier T ≥ T. Por lo tanto, solo necesitamos calcular un flujo maximal de prefijo para T = min{T∗ (p), T }. Esto se puede hacer en tiempo polinómico utilizando el algoritmo de caminos aumentantes iterativos en la prueba de existencia para calcular de forma iterativa el flujo máximo para los múltiplos polinomialmente muchos de L hasta (e incluyendo) T. Teorema 5.3 Se pueden calcular eficientemente pagos que, combinados con el Algoritmo 2, producen un mecanismo veraz de aproximación determinística 2 para el dominio de programación de dos valores. 5.2 Análisis Sea OPT(p) la duración óptima para p. Ahora demostramos que el Algoritmo 2 es un algoritmo de aproximación 2 que cumple con la monotonía cíclica. Esto nos permitirá calcular los pagos en la Sección 5.3 y demostrar el Teorema 5.3. 5.2.1 Prueba de la Aproximación Reclamo 5.4 Si OPT(p) < H, el makespan es a lo sumo OPT(p). Prueba. Si OPT(p) < H, debe ser que el horario óptimo asigna todos los trabajos a máquinas de baja velocidad, por lo que np,OPT(p) = n. Por lo tanto, tenemos T∗ (p) = L · H L. Además, dado que calculamos un flujo maximal de prefijo para el umbral T∗(p), tenemos np,T∗(p)|OPT(p) = np,OPT(p) = n, lo que implica que la carga en cada máquina es a lo sumo OPT(p). Por lo tanto, en este caso el makespan es como máximo (y por lo tanto exactamente) OPT(p). Reclamo 5.5 Si OPT(p) ≥ H, entonces T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Prueba. Sea nOPT(p) el número de trabajos asignados a las máquinas de baja en un horario óptimo. La carga total en todas las máquinas es exactamente nOPT(p) · L + (n − nOPT(p)) · H, y como máximo es m · OPT(p), ya que cada máquina tiene una carga de como máximo OPT(p). Entonces, tomando T = L · OPT(p) L ≥ H, dado que np,T ≥ nOPT(p) tenemos que np,T ·L+(n−np,T )·H ≤ m·T. Por lo tanto, T∗ (p), el T más pequeño de este tipo, es a lo sumo L · OPT(p) L. Reclamo 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina de alta calidad. 258 Prueba. Supongamos que j se asigna a la máquina i en el paso 3. Si pij = L, entonces debemos tener ni p,T ∗(p) = T∗ (p), de lo contrario podríamos haber asignado j a i en el paso 2 para obtener un flujo de valor mayor. Por lo tanto, en el punto justo antes de que se asigne j en el paso 3, la carga de cada máquina debe ser al menos T∗ (p). Por lo tanto, la carga total después de que se asigna j es al menos m · T∗ (p) + L > m · T∗ (p). Pero la carga total es como máximo np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), lo que resulta en una contradicción. Lema 5.7 El algoritmo anterior devuelve un horario con un makespan de a lo sumo OPT(p) + max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p). Prueba. Si OPT(p) < H, entonces, según la Afirmación 5.4, hemos terminado. Entonces supongamos que OPT(p) ≥ H. Por la Afirmación 5.5, sabemos que T∗ (p) ≤ OPT(p) + L. Si no hay trabajos sin asignar después del paso 2 del algoritmo, entonces el tiempo de ejecución es a lo sumo T∗ (p) y hemos terminado. Así que supongamos que hay algunos trabajos no asignados después del paso 2. Mostraremos que el makespan después del paso 3 es a lo sumo T +H ` 1− 1 m ´ donde T = min ˘ T∗ (p), OPT(p) ¯ . Supongamos que la afirmación es falsa. Sea i la máquina con la carga máxima, entonces li > T + H ` 1 − 1 m ´ . Deja que j sea el último trabajo asignado a i en el paso 3, y considera el punto justo antes de que se le asigne a i. Entonces li > T − H/m en este punto. También, dado que j está asignado a i, según nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos li. Por lo tanto, la carga total después de que j sea asignado, es al menos H + m · li > m · T (ya que pij = H según la Reclamación 5.6). Además, para cualquier asignación de trabajos a máquinas en el paso 3, la carga total es a lo sumo np,T ∗(p) · L + (n − np,T ∗(p)) · H ya que hay np,T ∗(p) trabajos asignados a máquinas de baja prioridad. Por lo tanto, debemos tener m · T < np,T ∗(p) · L + (n - np,T ∗(p)) · H. Pero argumentaremos que m · T ≥ np,T ∗(p) · L + (n - np,T ∗(p)) · H, lo cual conduce a una contradicción. Si T = T∗ (p), esto se deduce de la definición de T∗ (p). Si T = OPT(p), entonces dejando que nOPT(p) denote el número de trabajos asignados a las máquinas de baja en un horario óptimo, tenemos np,T ∗(p) ≥ nOPT(p). Entonces, np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H. Este es exactamente la carga total en un horario óptimo, que es a lo sumo m · OPT(p). 5.2.2 Prueba de la monotonía del ciclo. Lema 5.8 Considere dos instancias p = (pi, p−i) y p = (pi, p−i) donde pi ≥ pi, es decir, pij ≥ pij ∀j. Si T es un umbral tal que np,T > np,T, entonces todo flujo máximo x para (p, T) debe asignar todos los trabajos j tales que pij = L. Demostración. Que Gp denote el grafo residual para (p, T) y el flujo x. Supongamos por contradicción que existe un trabajo j∗ con pij∗ = L que no está asignado por x. Dado que pi ≥ pi, todos los bordes (j, i) que están presentes en la red para (p, T) también están presentes en la red para (p, T). Por lo tanto, x es un flujo válido para (p, T). Pero no es un flujo máximo, ya que np,T > np,T. Entonces existe un camino de aumento P en el grafo residual para (p, T) y flujo x. Observa que el nodo i debe estar incluido en P, de lo contrario P también sería un camino de aumento en el grafo residual Gp, lo que contradiría el hecho de que x es un flujo máximo. En particular, esto implica que hay un camino P ⊂ P desde i hasta el sumidero t. Sea P = (i, j1, i1, . . . , jK , iK , t). Todos los bordes de P también están presentes como bordes en Gp: todos los bordes inversos (i, j +1) están presentes ya que dicho borde implica que xi j +1 = 1; todos los bordes directos (j, i) están presentes ya que i = i, por lo que pi j = pi j = L, y xi j +1 = 0. Pero luego hay un camino de aumento (j∗ , i, j1, i1, . . . , jK , iK , t) en Gp que contradice la maximalidad de x. Que L denote el vector de tiempo de procesamiento todo bajo. Define TL i (p−i) = T∗ (L, p−i). \n\nDefina TL i (p−i) = T∗ (L, p−i). Dado que nos estamos enfocando en la máquina i, y p−i está fijo en todo momento, abreviamos TL i (p−i) como TL. Además, sea pL = (L, p−i). Ten en cuenta que T∗ (p) ≥ TL para cada instancia p = (pi, p−i). Corolario 5.9 Sea p = (pi, p−i) cualquier instancia y sea x cualquier flujo prefijo-maximal para (p, T∗ (p)). Entonces, la carga baja en la máquina i es como máximo TL. Prueba. Que T∗ = T∗ (p). Si T∗ = TL, entonces esto es claramente cierto. De lo contrario, considera la asignación x truncada en TL. Dado que x es prefijo-maximal, sabemos que esto constituye un flujo máximo para (p, TL). Además, np,T L < npL,T L porque T∗ > TL. Entonces, según el Lema 5.8, este flujo truncado debe asignar todos los trabajos de baja prioridad de i. Por lo tanto, no puede haber un trabajo j con pij = L que se asigne a i después del umbral TL, ya que entonces j no sería asignado por este flujo truncado. Por lo tanto, la carga baja de i es como máximo TL. Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p−i, p1 i ) y p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) donde n2,1 H y n2,1 L están definidos en (4) y (5), respectivamente. Observa que esto implica inmediatamente la monotonía del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L; sumando esto sobre todos los k = 1, . . . , K da como resultado (6). Lema 5.10 Si T∗ (p1) > TL, entonces se cumple la ecuación (7). Prueba. Que T1 = T∗ (p1) y T2 = T∗ (p2). Toma el flujo máximo de prefijo x2 para (p2, T2), trúnquelo en TL y elimine todos los trabajos de esta asignación que se cuentan en n2,1 H, es decir, todos los trabajos j tales que x2 ij = 1, p2 ij = L, p1 ij = H. Denomina este flujo como x. Observe que x es un flujo válido para (p1, TL), y el tamaño de este flujo es exactamente np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H. Además, ninguno de los trabajos que se cuentan en n2,1 L está asignado por x, ya que cada trabajo j de este tipo tiene prioridad sobre i en p2. Dado que T1 > TL, debemos tener np1,TL < npTL,TL. Por lo tanto, si aumentamos x a un flujo máximo para (p1, TL), entonces, por el Lema 5.8 (con p = pL y p = p1), todos los trabajos correspondientes a n2,1 L deben asignarse en este flujo máximo. Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1,T L ≥ np2,T L − n2,1 H + n2,1 L, como se afirma. Lema 5.11 Supongamos que T∗ (p1 ) = TL. Entonces se cumple (7). Prueba. Nuevamente, dejemos que T1 = T∗ (p1) = TL y T2 = T∗ (p2). Que x1, x2 sean la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculada por nuestro algoritmo para p1, p2 respectivamente. Sea S = {j : x2 ij = 1 y p2 ij = L} y S = {j : x2 ij = 1 y p1 ij = L}. Por lo tanto, |S | = |S| − n2,1 H + n2,1 L y |S| = ni p2,T 2 = ni p2,T 2 |T L (por el Corolario 5.9). Sea T = |S| · L. Consideramos dos casos. Supongamos primero que T ≤ TL. Considera el siguiente flujo para (p1, TL): asigna a cada máquina que no sea i la asignación baja de x2 truncada en TL, y asigna los trabajos en S a la máquina i. Este es un flujo válido para (p1, TL) ya que la carga en i es T ≤ TL. Su tamaño es igual a P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L. El tamaño del flujo máximo para (p1, TL) no es menor, y se sigue la afirmación. Ahora supongamos que T > TL. Dado que |S| · L ≤ TL (por el Corolario 5.9), se sigue que n2,1 L > n2,1 H ≥ 0. Sea ˆT = T − L ≥ TL ya que T, TL son ambos múltiplos de L. Sea M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2. Primero demostramos que m · ˆT < M · L + (n − M) · H. (8) Sea N el número de trabajos asignados a la máquina i en x2. La carga en la máquina i es |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H, lo cual es al menos |S |·L > ˆT ya que n2,1 L ≤ N− |S|. Así obtenemos la desigualdad |S|·L+(N−|S|)·H > ˆT. Ahora considera el punto en la ejecución del algoritmo en la instancia p2 justo antes de que el último trabajo de alta prioridad sea asignado a i en el Paso 3 (debe haber tal trabajo ya que n2,1 L > 0). La carga en i en este punto es |S| · L + (N − |S| − 1) · H, que es al menos |S| · L − L = ˆT por un argumento similar al anterior. Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆT. Sumando estas desigualdades para todos los i = i, y la desigualdad anterior para i, obtenemos que |S| · L + (N − |S|) · H + Σ i = i Σ j p2 i jx2 i j > m ˆT. Pero el lado izquierdo es exactamente M · L + (n − M) · H. Por otro lado, dado que T1 = TL, tenemos m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L) · H. (9) Combinando (8) y (9), obtenemos que np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L. El Lema 5.12 del Algoritmo 2 satisface la monotonía del ciclo. Prueba. Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L. Sumando esto sobre todos los k = 1, . . . , K (donde K + 1 ≡ 1) se obtiene (6). 5.3 Cálculo de precios Los lemas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de aproximación 2 que satisface la monotonía de ciclo. Por lo tanto, según la discusión en la Sección 3, existen precios que generan un mecanismo veraz. Para obtener un mecanismo de tiempo polinómico, también necesitamos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico. No está claro si el procedimiento descrito en la Sección 3, basado en calcular los caminos más cortos en el grafo de asignación, produce un algoritmo de tiempo polinómico, ya que el grafo de asignación tiene un número exponencial de nodos (uno por cada asignación de salida). En lugar de analizar el grafo de asignación, aprovecharemos nuestra prueba de monotonía del ciclo, en particular, la desigualdad (7), y simplemente detallaremos los pagos. Recuerda que la utilidad de un jugador es ui = Pi − li, donde Pi es el pago realizado al jugador i. Para mayor comodidad, primero especificaremos los pagos negativos (es decir, los PIs serán los precios cobrados a los jugadores) y luego mostraremos que estos pueden ser modificados para que los jugadores tengan utilidades no negativas (si actúan de manera veraz). Que Hi denote el número de trabajos asignados a la máquina i en el paso 3. Por el Corolario 5.6, sabemos que todos estos trabajos están asignados a máquinas de alta calidad (según los pis declarados). Deja que H−i = P i =i Hi y n−i p,T = P i =i ni p,T. El pago Pi al jugador i se define como: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10). Podemos interpretar nuestros pagos como igualar el costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios VCG). Los primeros y segundos términos en (10), al restarse de la carga li, igualan el costo al total de la carga. El término np,T ∗(p) − np,T L i (p−i) es de hecho igual a n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) ya que la carga baja en i es a lo sumo TL i (p−i) (según la Reclamación 5.9). Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos de baja prioridad que fueron asignados más allá del umbral TL i (p−i) (a máquinas distintas de i) efectivamente como trabajos de alta prioridad para el cálculo total de utilidad desde su punto de vista. No está claro cómo se podrían haber ideado estos pagos de antemano para demostrar la veracidad de nuestro algoritmo. Sin embargo, al depender de la monotonía del ciclo, no solo pudimos argumentar la existencia de pagos, sino que nuestra prueba allanó el camino para inferir realmente estos pagos. El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan lugar a un mecanismo veraz. Lema 5.13 Fija un jugador i y las declaraciones de los otros jugadores p−i. Deje que su tipo verdadero sea p1 i. Entonces, bajo los pagos definidos en (10), la utilidad cuando declara su verdadero tipo p1 i es al menos su utilidad cuando declara cualquier otro tipo p2 i. Prueba. Que c1 i, c2 i denoten su costo total, definido como el negativo de su utilidad, cuando ella declara p1 y p2, respectivamente (y los demás declaran p−i). Dado que p−i está fijo, omitimos p−i de las expresiones a continuación para mayor claridad notacional. La verdadera carga de i cuando declara su verdadero tipo p1 i es L · ni p1,T ∗(p1) + H · Hi (p1), y por lo tanto c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) Por otro lado, la verdadera carga cuando declara p2 i es L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L) + H · (Hi + n2,1 H − n2,1 L) (ya que el vector de tiempo de procesamiento verdadero es p1 i), y así c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L. Por lo tanto, (7) implica que c1 i ≤ c2 i. Las especificaciones de precios suelen requerirse para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de un jugador debe ser no negativa si revela su valor real. Los pagos dados por (10) no son individualmente racionales ya que en realidad le cobran a un jugador una cierta cantidad. Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficientemente grande a la definición del precio. En nuestro caso, por ejemplo, dejando que H denote el vector de todas las H, podemos añadir el término n·H −(H −L)n(H,p−i),T L i (p−i) a (10). Ten en cuenta que esto es una constante para el jugador i. Por lo tanto, los nuevos pagos son Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ . Como se muestra en (11), esto resultará en una utilidad no negativa para i (ya que n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) para cualquier tipo pi del jugador i). Esta modificación también garantiza la propiedad de normalización adicional deseada de que si un jugador no recibe trabajos, entonces recibe un pago de cero: si el jugador i recibe el conjunto vacío para algún tipo pi, entonces también recibirá el conjunto vacío para el tipo H (esto es fácil de verificar para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero; por lo tanto, por veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que i reciba el conjunto vacío. Esto completa la demostración del Teorema 5.3. 260 5.4 Imposibilidad de implementación exacta. Ahora mostramos que, independientemente de consideraciones computacionales, no existe un algoritmo cíclico-monótono para el caso L-H con una proporción de aproximación mejor que 1.14. Sea H = α·L para algún 2 < α < 2.5 que elegiremos más tarde. Hay dos máquinas I, II y siete trabajos. Considera los siguientes dos escenarios: Escenario 1. Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5 son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna los trabajos 1-5 a una máquina y los trabajos 6, 7 a la otra, y tiene un makespan OPT1 = 5L. El segundo mejor horario tiene un tiempo de ejecución de al menos Second1 = 2H + L. Escenario 2. Si el algoritmo elige un horario óptimo para el escenario 1, asuma sin pérdida de generalidad que los trabajos 6 y 7 están asignados a la máquina II. En el escenario 2, la máquina I tiene el mismo vector de tiempos de procesamiento. La Máquina II reduce los trabajos 6 y 7 a L y aumenta los trabajos 1-5 a H. Un horario óptimo tiene un tiempo de ejecución de 2L + H, donde la Máquina II realiza los trabajos 6, 7 y uno de los trabajos 1-5. La segunda mejor programación para este escenario tiene un makespan de al menos Second2 = 5L. Teorema 5.14 Ningún mecanismo determinístico y veraz para el problema de programación de dos valores puede obtener una proporción de aproximación mejor que 1.14. Prueba. Primero argumentamos que un algoritmo cíclico-monótono no puede elegir el horario óptimo en ambos escenarios. Esto se debe a que de lo contrario se viola la monotonía del ciclo para la máquina II. Tomando p1 II , p2 II como vectores de tiempos de procesamiento de la máquina II para los escenarios 1, 2 respectivamente, obtenemos P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0. Por lo tanto, cualquier mecanismo veraz debe devolver un makespan subóptimo en al menos un escenario, y por lo tanto su ratio de aproximación es al menos min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 para α = 2.364. Observamos que para el caso {Lj, Hj} donde hay una razón común r = Hj Lj para todos los trabajos (esto generaliza el escenario de máquinas restringidas) se puede obtener un mecanismo fraccional veraz (con precios computables eficientemente) que devuelve un horario de makespan de a lo sumo OPT(p) para cada p. Se puede ver cada trabajo j como consistente de Lj subtrabajos de tamaño 1 en una máquina i si pij = Lj, y de tamaño r si pij = Hj. Para esta nueva instancia ˜p, nota que ˜pij ∈ {1, r} para cada i, j. También hay que tener en cuenta que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxij =P j : subtrabajo de j ˜pij ˜xij. Por lo tanto, si utilizamos el Algoritmo 2 para obtener un horario para la instancia ˜p, la ecuación (6) se traduce precisamente a (3) para la asignación x; además, los precios para ˜p se traducen en precios para la instancia p. El número de subtrabajos asignados a máquinas de baja en la fase de flujo es simplemente el trabajo total asignado a las máquinas de baja. Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a las máquinas de baja capacidad. Además, dado que tenemos un dominio fraccional, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p). La asignación x no necesita cumplir la condición de que xij > 0 implica pij ≤ OPT(p) para cualquier r, por lo tanto, el procedimiento de redondeo del Lema 4.2 no produce un mecanismo de aproximación 2-veraz en expectativa. Pero si r > OPT(p) (como en el escenario de máquinas restringidas), esta condición sí se cumple, por lo que obtenemos un mecanismo veraz de aproximación 2. Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda en refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus comentarios útiles. 6. REFERENCIAS [1] N. Andelman, Y. Azar y M. Sorani. Mecanismos de aproximación veraces para la programación de máquinas relacionadas egoístas. En Proc. 22º STACS, 69-82, 2005. [2] A. Archer. Mecanismos para la optimización discreta con agentes racionales. Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´E. This word does not have a meaning in English. Could you please provide more context or clarify the sentence? Mecanismos veraces para agentes de un parámetro. En Proc. 42º FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano. Mecanismos de aproximación veraces determinísticos para máquinas relacionadas con la programación. En Proc. 21º STACS, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani. Asignación de bienes indivisibles. En ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La debilidad de la monotonicidad caracteriza la implementación de estrategias dominantes determinísticas. Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking. Técnicas de aproximación para el diseño de mecanismos utilitarios. En Proc. 37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali. Un límite inferior para los mecanismos de programación. En Proc. 18th SODA, páginas 1163-1170, 2007. [9] E. Clarke. Precios escalonados de bienes públicos. Elección Pública, 8:17-33, 1971. [10] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, y R. V. Vohra. Caracterizando mecanismos de estrategia dominante con tipos multidimensionales, 2004. Documento de trabajo. [12] L. A. Sala. Algoritmos de aproximación para la programación de tareas. En D. Hochbaum, editor, Algoritmos de Aproximación para Problemas NP-Difíciles. PWS Publishing, MA, 1996. [13] A. Kovács. Algoritmo de aproximación rápida y monótona 3 para la programación de máquinas relacionadas. En Proc. 13th ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan. Algoritmos de aproximación para la programación en múltiples máquinas. En Proc. 46th FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan. Hacia una caracterización de subastas combinatorias veraces. En Proc. 44th FOCS, páginas 574-583, 2003. [16] R. Lavi y C. Swamy. Diseño de mecanismos veraz y casi óptimos a través de programación lineal. En Proc. 46th FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. OCallaghan y Y. Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Revista de la ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, y ´E. This word does not have a meaning in English. Could you please provide more context or another sentence for translation? Algoritmos de aproximación para la programación de máquinas paralelas no relacionadas. Matemáticas. Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. \n\nProg., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, y A. Saberi. Sobre asignaciones aproximadamente justas de bienes indivisibles. En Proc. 5to EC, páginas 125-131, 2004. [20] A. Mualem y M. Schapira. Estableciendo límites inferiores en la veracidad. En Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [22] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Economía. Comportamiento, 35:166-196, 2001. [23] J. C. Rochet. Una condición necesaria y suficiente para la racionalización en un contexto cuasilineal. Revista de Economía Matemática, 16:191-200, 1987. [24] M. Saks y L. Yu. La monotonía débil es suficiente para la veracidad en dominios convexos. En Proc. 6to EC, páginas 286-293, 2005. [25] D. B. Shmoys y ´E. This word does not have a specific meaning in English. Could you please provide more context or another sentence for translation? Un algoritmo de aproximación para el problema de asignación generalizada. Programación Matemática, 62:461-474, 1993. [26] W. Vickrey. Contraespeculaciones, subastas y licitaciones selladas competitivas. I'm sorry, but the sentence \"J.\" does not have a clear meaning or context for translation. Could you please provide more information or a complete sentence for me to translate into Spanish? Finanzas, 16:8-37, 1961. 261",
    "original_sentences": [
        "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
        "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
        "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
        "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
        "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
        "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
        "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
        "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
        "Our constructions are novel in two respects.",
        "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
        "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
        "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
        "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
        "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
        "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
        "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
        "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
        "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
        "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
        "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
        "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
        "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
        "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
        "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
        "Such a mechanism is called a truthful mechanism.",
        "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
        "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
        "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
        "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
        "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
        "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
        "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
        "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
        "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
        "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
        "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
        "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
        "This assumption makes the domain of players types single-dimensional.",
        "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
        "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
        "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
        "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
        "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
        "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
        "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
        "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
        "We call this model the jobdependent two-values case.",
        "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
        "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
        "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
        "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
        "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
        "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
        "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
        "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
        "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
        "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
        "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
        "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
        "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
        "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
        "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
        "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
        "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
        "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
        "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
        "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
        "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
        "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
        "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
        "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
        "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
        "But, cycle monotonicity does allow us to prove such a statement.",
        "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
        "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
        "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
        "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
        "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
        "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
        "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
        "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
        "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
        "They gave an m-approximation positive result and proved various lower bounds.",
        "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
        "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
        "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
        "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
        "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
        "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
        "We use their procedure in our randomized mechanism.",
        "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
        "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
        "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
        "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
        "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
        "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
        "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
        "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
        "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
        "These lower bounds were strengthened in [20]. 2.",
        "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
        "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
        "We consider two special cases of this problem: 1.",
        "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
        "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
        "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
        "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
        "We will use the terms schedule and assignment interchangeably.",
        "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
        "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
        "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
        "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
        "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
        "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
        "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
        "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
        "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
        "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
        "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
        "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
        "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
        "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
        "This is made precise using the notion of dominant-strategy truthfulness.",
        "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
        "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
        "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
        "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
        "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
        "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
        "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
        "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
        "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
        "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
        "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
        "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
        "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
        "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
        "We include a brief exposition on it for completeness.",
        "The exposition here is largely based on [11].",
        "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
        "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
        "Let Vi denote the set of all possible types of player i.",
        "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
        "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
        "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
        "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
        "Now fix a player i, and fix the declarations v−i of the others.",
        "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
        "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
        "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
        "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
        "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
        "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
        "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
        "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
        "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
        "Fix a player i, p−i, and any p1 i , . . . , pK i .",
        "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
        "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
        "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
        "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
        "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
        "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
        "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
        "Our construction and proof are simple, and based on two ideas.",
        "First, as outlined above, we prove truthfulness using cycle monotonicity.",
        "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
        "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
        "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
        "We should point out however that one cannot simply plug in the results of [16].",
        "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
        "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
        "We use the following result adapted from [16].",
        "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
        "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
        "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
        "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
        "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
        "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
        "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
        "Thus, we can apply Corollary 3.4 here.",
        "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
        "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
        "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
        "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
        "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
        "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
        "Then A satisfies cycle-monotonicity.",
        "Proof.",
        "Fix a player i, and the vector of processing times of the other players p−i.",
        "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
        "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
        "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
        "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
        "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
        "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
        "We set k = k, and then start a new maximal segment with index k + 1.",
        "Note that k = k and k + 1 = k − 1.",
        "We now have a subset of indices and we can continue recursively.",
        "So all indices are included in some maximal segment.",
        "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
        "Adding this for each segment yields the desired inequality.",
        "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
        "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
        "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
        "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
        "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
        "The idea is to simply spread this schedule.",
        "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
        "The resulting assignment clearly satisfies the desired properties.",
        "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
        "This spreading out can also be done if the initial schedule is fractional.",
        "We now describe the algorithm precisely.",
        "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
        "Our algorithm, which we call A , returns the following assignment xF .",
        "Initialize xF ij = 0 for all i, j.",
        "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
        "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
        "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
        "Proof.",
        "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
        "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
        "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
        "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
        "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
        "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
        "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
        "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
        "The computation of payments will depend on the actual approximation algorithm used.",
        "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
        "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
        "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
        "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
        "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
        "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
        "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
        "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
        "We describe our algorithm in Section 5.1.",
        "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
        "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
        "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
        "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
        "Plugging this into (3) and dividing by (H − L), we get the following.",
        "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
        "We will assume that L, H are integers, which is without loss of generality.",
        "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
        "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
        "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
        "We will therefore use the terms assignment and flow interchangeably.",
        "Moreover, there is always an integral max-flow (since all capacities are integers).",
        "We will often refer to such a max-flow as the max-flow for (p, T).",
        "We need one additional concept before describing the algorithm.",
        "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
        "Fix some max-flow.",
        "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
        "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
        "Define np,T |T = P i ni p,T |T .",
        "We define a prefix-maximal flow or assignment for T as follows.",
        "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
        "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
        "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
        "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
        "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
        "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
        "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
        "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
        "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
        "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
        "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
        "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
        "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
        "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
        "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
        "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
        "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
        "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
        "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
        "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
        "Proof.",
        "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
        "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
        "So in this case the makespan is at most (and hence exactly) OPT(p).",
        "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
        "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
        "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
        "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
        "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
        "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
        "Suppose j is assigned to machine i in step 3.",
        "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
        "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
        "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
        "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
        "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
        "Proof.",
        "If OPT(p) < H, then by Claim 5.4, we are done.",
        "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
        "So assume that there are some unassigned jobs after step 2.",
        "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
        "Suppose the claim is false.",
        "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
        "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
        "So li > T − H/m at this point.",
        "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
        "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
        "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
        "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
        "If T = T∗ (p), this follows from the definition of T∗ (p).",
        "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
        "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
        "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
        "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
        "Let Gp denote the residual graph for (p , T) and flow x .",
        "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
        "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
        "Thus, x is a valid flow for (p, T).",
        "But it is not a max-flow, since np,T > np ,T .",
        "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
        "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
        "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
        "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
        "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
        "Let L denote the all-low processing time vector.",
        "Define TL i (p−i) = T∗ (L, p−i).",
        "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
        "Also, let pL = (L, p−i).",
        "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
        "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
        "Then, the low-load on machine i is at most TL .",
        "Proof.",
        "Let T∗ = T∗ (p).",
        "If T∗ = TL , then this is clearly true.",
        "Otherwise, consider the assignment x truncated at TL .",
        "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
        "Also, np,T L < npL,T L because T∗ > TL .",
        "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
        "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
        "Thus, the low-load of i is at most TL .",
        "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
        "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
        "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
        "Proof.",
        "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
        "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
        "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
        "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
        "Since T1 > TL , we must have np1,T L < npL,T L .",
        "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
        "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
        "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
        "Then (7) holds.",
        "Proof.",
        "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
        "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
        "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
        "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
        "Let T = |S | · L. We consider two cases.",
        "Suppose first that T ≤ TL .",
        "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
        "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
        "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
        "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
        "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
        "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
        "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
        "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
        "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
        "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
        "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
        "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
        "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
        "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
        "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
        "Proof.",
        "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
        "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
        "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
        "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
        "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
        "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
        "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
        "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
        "Let Hi denote the number of jobs assigned to machine i in step 3.",
        "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
        "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
        "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
        "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
        "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
        "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
        "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
        "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
        "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
        "Lemma 5.13 Fix a player i and the other players declarations p−i.",
        "Let is true type be p1 i .",
        "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
        "Proof.",
        "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
        "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
        "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
        "Thus, (7) implies that c1 i ≤ c2 i .",
        "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
        "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
        "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
        "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
        "Note that this is a constant for player i.",
        "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
        "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
        "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
        "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
        "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
        "There are two machines I, II and seven jobs.",
        "Consider the following two scenarios: Scenario 1.",
        "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
        "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
        "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
        "In scenario 2, machine I has the same processing-time vector.",
        "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
        "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
        "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
        "Proof.",
        "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
        "This follows because otherwise cycle monotonicity is violated for machine II.",
        "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
        "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
        "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
        "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
        "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
        "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
        "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
        "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
        "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
        "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
        "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
        "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
        "Truthful approximation mechanisms for scheduling selfish related machines.",
        "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
        "Mechanisms for discrete optimization with rational agents.",
        "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
        "Tardos.",
        "Truthful mechanisms for one-parameter agents.",
        "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
        "Deterministic truthful approximation mechanisms for scheduling related machines.",
        "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
        "Allocating indivisible goods.",
        "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
        "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
        "Approximation techniques for utilitarian mechanism design.",
        "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
        "A lower bound for scheduling mechanisms.",
        "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
        "Multipart pricing of public goods.",
        "Public Choice, 8:17-33, 1971. [10] T. Groves.",
        "Incentives in teams.",
        "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
        "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
        "Working paper. [12] L. A.",
        "Hall.",
        "Approximation algorithms for scheduling.",
        "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
        "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
        "Fast monotone 3-approximation algorithm for scheduling related machines.",
        "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
        "Approximation algorithms for scheduling on multiple machines.",
        "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
        "Towards a characterization of truthful combinatorial auctions.",
        "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
        "Truthful and near-optimal mechanism design via linear programming.",
        "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
        "Truth revelation in approximately efficient combinatorial auctions.",
        "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
        "Tardos.",
        "Approximation algorithms for scheduling unrelated parallel machines.",
        "Math.",
        "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
        "On approximately fair allocations of indivisible goods.",
        "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
        "Setting lower bounds on truthfulness.",
        "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
        "Optimal auction design.",
        "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
        "Algorithmic mechanism design.",
        "Games and Econ.",
        "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
        "A necessary and sufficient condition for rationalizability in a quasilinear context.",
        "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
        "Weak monotonicity suffices for truthfulness on convex domains.",
        "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
        "Tardos.",
        "An approximation algorithm for the generalized assignment problem.",
        "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
        "Counterspeculations, auctions, and competitive sealed tenders.",
        "J.",
        "Finance, 16:8-37, 1961. 261"
    ],
    "translated_text_sentences": [
        "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos.",
        "Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20].",
        "Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo.",
        "Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación.",
        "Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación.",
        "Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra.",
        "Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz.",
        "Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional.",
        "Nuestras construcciones son novedosas en dos aspectos.",
        "Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo.",
        "La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales.",
        "Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional.",
        "Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa.",
        "Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces.",
        "Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1.",
        "INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo.",
        "El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal.",
        "Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención.",
        "En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan.",
        "Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina.",
        "Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario.",
        "La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]).",
        "Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido).",
        "Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento.",
        "Un mecanismo así se llama un mecanismo veraz.",
        "El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores.",
        "En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos.",
        "En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas.",
        "La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio.",
        "Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios.",
        "Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j.",
        "Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20].",
        "Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo.",
        "En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos.",
        "Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista.",
        "En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas.",
        "Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i.",
        "Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional.",
        "La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios.",
        "Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado.",
        "La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2).",
        "Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación.",
        "Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias).",
        "Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales.",
        "En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina.",
        "Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto).",
        "Llamamos a este modelo el caso de dos valores dependiente del trabajo.",
        "Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico.",
        "Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores.",
        "Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto.",
        "Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella.",
        "Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general.",
        "Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional.",
        "Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa.",
        "Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional.",
        "Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj.",
        "Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente).",
        "Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad.",
        "Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema.",
        "Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional.",
        "Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas).",
        "Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales).",
        "La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos.",
        "En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad).",
        "Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]).",
        "Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales.",
        "Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios.",
        "La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]).",
        "Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios.",
        "Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales.",
        "Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c.",
        "A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido.",
        "Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación.",
        "De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general.",
        "El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa.",
        "Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional.",
        "Moverse a un dominio fraccional nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación.",
        "Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria.",
        "Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas.",
        "Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación.",
        "Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces.",
        "Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas.",
        "Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores.",
        "Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz.",
        "Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorio de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13].",
        "El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2.",
        "Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo.",
        "Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan.",
        "Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites.",
        "Utilizamos su procedimiento en nuestro mecanismo aleatorio.",
        "La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]).",
        "Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3].",
        "Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13].",
        "Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24].",
        "Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales.",
        "Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos.",
        "En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia.",
        "Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas.",
        "Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz.",
        "Estos límites inferiores fueron fortalecidos en [20].",
        "PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina.",
        "En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j.",
        "Consideramos dos casos especiales de este problema: 1.",
        "El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos.",
        "Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2.",
        "El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j.",
        "Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj.",
        "Usaremos los términos horario y tarea indistintamente.",
        "Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j.",
        "También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional.",
        "En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j.",
        "Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras).",
        "Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li.",
        "El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos.",
        "El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico.",
        "Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes.",
        "El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas.",
        "Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo.",
        "Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados.",
        "Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j.",
        "El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad.",
        "Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos.",
        "Esto se hace preciso utilizando la noción de veracidad de estrategia dominante.",
        "Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
        "Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas.",
        "También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias.",
        "La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias.",
        "Para un mecanismo aleatorio, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento.",
        "La desigualdad (1) también define la veracidad en expectativa para un mecanismo aleatorio, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)).",
        "Para nuestros dos dominios de programación, la suposición informativa es que los valores Lj, Hj son de conocimiento público.",
        "La información privada de una máquina es qué trabajos tienen valor Lj (o L) y cuáles tienen valor Hj (o H) en ella.",
        "Enfatizamos que ambos de nuestros dominios son multidimensionales, ya que cada máquina i necesita especificar un vector que indique qué trabajos son bajos y altos en ella.",
        "Aunque la veracidad se define en términos de pagos, resulta que en realidad la veracidad se reduce a una cierta condición algorítmica de monotonicidad.",
        "Esto parece haber sido observado por primera vez para dominios multidimensionales por Rochet [23] en 1987, y ha sido utilizado con éxito en el diseño algorítmico de mecanismos varias veces, pero para dominios unidimensionales.",
        "Sin embargo, para dominios multidimensionales, la condición de monotonía es más compleja y no ha habido éxito en emplearla en el diseño de mecanismos veraces.",
        "La mayoría de los resultados positivos para dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad.",
        "Una de las principales contribuciones de este artículo es demostrar que la condición de monotonía para entornos multidimensionales, a veces llamada monotonía cíclica, puede ser efectivamente utilizada para diseñar mecanismos veraces.",
        "Incluimos una breve exposición sobre ello para completitud.",
        "La exposición aquí se basa en gran medida en [11].",
        "La monotonía cíclica se describe mejor en el marco abstracto de elección social: hay un conjunto finito A de alternativas, hay m jugadores, y cada jugador tiene un tipo privado (función de valoración) v: A → R, donde vi(a) debe interpretarse como su valor para la alternativa a.",
        "En el ámbito de la programación, A representa todas las posibles asignaciones de trabajos a máquinas, y vi(a) es el negativo de su carga en el horario a.",
        "Que Vi denote el conjunto de todos los posibles tipos de jugador i.",
        "Un mecanismo es una tupla (f, {Pi}) donde f : V1 × · · · × Vm → A es el algoritmo para elegir la alternativa, y Pi : V1 × · · · × Vm → A es el precio cobrado al jugador i (en el contexto de programación, el mecanismo paga a los jugadores, lo que corresponde a precios negativos).",
        "El mecanismo es veraz si para cada i, cada v−i ∈ V−i = Q i =i Vi, y cualquier vi, vi ∈ Vi, tenemos que vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), donde a = f(vi, v−i) y b = f(vi, v−i).",
        "Una pregunta básica que surge es si dado un algoritmo f: V1 × · · · × Vm → A, ¿existen precios que harán que el mecanismo resultante sea veraz?",
        "Es bien sabido (ver por ejemplo [15]) que el precio Pi solo puede depender de la alternativa elegida y las otras declaraciones, es decir, podemos escribir Pi : V−i × A → R. Por lo tanto, la veracidad implica que para cada i, cada v−i ∈ V−i, y cualquier vi, vi ∈ Vi con f(vi, v−i) = a y f(vi, v−i) = b, tenemos vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
        "Ahora fija un jugador i, y fija las declaraciones v−i de los demás.",
        "Buscamos una asignación a las variables {Pa}a∈A tal que vi(a) − vi(b) ≥ Pa − Pb para todo a, b ∈ A y vi ∈ Vi con f(vi, v−i) = a. (Estrictamente hablando, deberíamos usar A = f(Vi, v−i) en lugar de A aquí).",
        "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. \n\nDefina δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
        "Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {Pa}a∈A tal que Pa − Pb ≤ δa,b ∀a, b ∈ A (2). Esto se resuelve fácilmente al observar el grafo de asignación y aplicar un resultado básico estándar de teoría de grafos.",
        "Definición 3.1 (Gui et al. [11]): El grafo de asignación de f es un grafo dirigido ponderado G = (A, E) donde E = A × A y el peso de una arista b → a (para cualquier a, b ∈ A) es δa,b.",
        "Teorema 3.2 Existe una asignación factible para (2) si y solo si el grafo de asignación no tiene ciclos de longitud negativa.",
        "Además, si todos los ciclos son no negativos, una asignación factible es 255 obtenida de la siguiente manera: fije un nodo arbitrario a∗ ∈ A y establezca Pa como la longitud del camino más corto desde a∗ hasta a.",
        "Esto lleva a la siguiente definición, que es otra forma de expresar la condición de que el grafo de asignación no tenga ciclos negativos.",
        "Definición 3.3 (Monotonía de ciclo) Una función de elección social f satisface la monotonía de ciclo si para cada jugador i, cada v−i ∈ V−i, cada entero K, y cada v1 i , . . . , vK i ∈ Vi, Σ k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 donde ak = f(vk i , v−i) para 1 ≤ k ≤ K, y aK+1 = a1.",
        "Corolario 3.4 Existen precios P tales que el mecanismo (f, P) es veraz si y solo si f satisface la monotonicidad del ciclo. Ahora consideramos nuestro dominio específico de programación.",
        "Fija un jugador i, p−i, y cualquier p1 i, . . . , pK i.",
        "Sea x(pk i , p−i) = xk para 1 ≤ k ≤ K, y sea xK+1 = x1 , pK+1 = p1 . xk podría ser una asignación {0, 1} o una asignación fraccional.",
        "Tenemos vk i (xk ) = − P j xk ijpk ij, por lo que la monotonía del ciclo se traduce en PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
        "Reorganizando, obtenemos KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Por lo tanto, (3) reduce nuestro problema de diseño de mecanismos a un problema algorítmico concreto.",
        "Para la mayor parte de este documento, ignoraremos consecuentemente cualquier consideración estratégica y nos enfocaremos en diseñar un algoritmo de aproximación para minimizar el makespan que cumpla con (3). 4.",
        "Una TÉCNICA GENERAL PARA OBTENER MECANISMOS ALEATORIOS En esta sección, consideramos el caso de valores Lj, Hj dependientes del trabajo (con Lj ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde Hj = ∞).",
        "Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa.",
        "Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se proporciona como una caja negra.",
        "Nuestra construcción y demostración son simples, y se basan en dos ideas.",
        "Primero, como se ha mencionado anteriormente, demostramos la veracidad utilizando la monotonía de ciclo.",
        "Parece poco probable que para un algoritmo de aproximación arbitrario dado solo como una caja negra, se pueda encontrar pagos para demostrar la veracidad; pero la ciclo-monotonía nos permite demostrar precisamente esto.",
        "Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un dominio fraccional y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros.",
        "Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el uso de mecanismos fraccionarios para obtener mecanismos veraces en expectativa. No está claro si el Teorema 3.2, y por lo tanto, esta afirmación, se cumple si A no es finito.",
        "Debemos señalar, sin embargo, que no se puede simplemente ingresar los resultados de [16].",
        "Sus resultados son válidos para problemas de maximización del bienestar social y se basan en el uso de VCG para obtener un mecanismo fraccional veraz.",
        "Sin embargo, VCG no se aplica a la minimización del makespan, y en nuestro caso ni siquiera se conoce la existencia de un mecanismo fraccional veraz cercano a óptimo.",
        "Utilizamos el siguiente resultado adaptado de [16].",
        "Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, P) un mecanismo fraccional veraz.",
        "Sea A un algoritmo de redondeo aleatorio que, dado un asignación fraccional x, produce una asignación aleatoria X tal que E ˆ Xij ˜ = xij para todo i, j.",
        "Entonces existen pagos P tales que el mecanismo M = (A, P) es veraz en promedio.",
        "Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de lanzamientos de moneda.",
        "Sea OPT(p) el makespan óptimo (sobre horarios enteros) para la instancia p. Como primer paso, tomamos un algoritmo de aproximación c y lo convertimos en un mecanismo fraccional de verdad de aproximación 2c.",
        "Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (satisfaciendo ciertas propiedades) de makespan a lo sumo c · OPT(p) para cada instancia p. Demostramos la veracidad mostrando que el algoritmo fraccional satisface la monotonía de ciclo (3).",
        "Observa que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinito): su cardinalidad es a lo sumo la del dominio de entrada, que es a lo sumo 2mn en el caso de dos valores.",
        "Por lo tanto, podemos aplicar el Corolario 3.4 aquí.",
        "Para convertir este mecanismo fraccional veraz en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que cumpla con los requisitos del Lema 4.1.",
        "Afortunadamente, dicho procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14].",
        "Lema 4.2 (Kumar et al. [14]): Dada una asignación fraccional x y un vector de tiempos de procesamiento p, existe un procedimiento de redondeo aleatorio que produce una asignación X (aleatoria) tal que, 1. para cualquier i, j, E ˆ Xij ˜ = xij. 2. para cualquier i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij con probabilidad 1.",
        "La propiedad 1 se utilizará para obtener veracidad en la expectativa, y la propiedad 2 nos permitirá demostrar una garantía de aproximación.",
        "Primero demostramos que cualquier algoritmo que devuelva una asignación fraccional con ciertas propiedades satisface la monotonía de ciclo.",
        "Lema 4.3 Sea A un algoritmo que, para cualquier entrada p, produce una asignación (fraccional) x tal que, si pij = Hj entonces xij ≤ 1/m, y si pij = Lj entonces xij ≥ 1/m.",
        "Entonces A satisface la ciclo-monotonía.",
        "Prueba.",
        "Fija un jugador i y el vector de tiempos de procesamiento de los otros jugadores p−i.",
        "Necesitamos demostrar (3), es decir, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 para cada p1 i , . . . , pK i , donde el índice k = K + 1 se toma como k = 1.",
        "Demostraremos que para cada trabajo j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
        "Si pk ij es el mismo para todos los k (ya sea siempre Lj o siempre Hj), entonces la desigualdad anterior claramente se cumple.",
        "De lo contrario, podemos dividir los índices 1, . . . , K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos k , k + 1, . . . , k − 1, k (donde K + 1 ≡ 1) tal que pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
        "Esto se cumple porque debe haber algún k tal que pk ij = Hj > pk−1 ij = Lj.",
        "Tomamos k = k y luego seguimos incluyendo índices en este segmento hasta que alcancemos un k tal que pk ij = Lj y pk+1 ij = Hj.",
        "Establecemos k = k, y luego comenzamos un nuevo segmento maximal con índice k + 1.",
        "Ten en cuenta que k = k y k + 1 = k − 1.",
        "Ahora tenemos un subconjunto de índices y podemos continuar de forma recursiva.",
        "Entonces, todos los índices están incluidos en algún segmento maximal.",
        "Mostraremos que para cada segmento maximal k, k +1, . . . , k, P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
        "Agregar esto para cada segmento produce la desigualdad deseada.",
        "Así que ahora concéntrate en un segmento maximal k, k + 1, . . . , k − 1, k.",
        "Por lo tanto, existe un k∗ tal que para k ≤ k < k∗ , tenemos pk ij = Hj, y para k∗ ≤ k ≤ k , tenemos pk ij = Lj.",
        "Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk∗ ij dado que pk ij = Hj y pk∗ ij = Lj.",
        "Ahora describimos cómo usar un algoritmo de c-aproximación para obtener un algoritmo que cumpla con la propiedad en el Lema 4.3.",
        "Para simplificar, primero supongamos que el algoritmo de aproximación devuelve un horario integral.",
        "La idea es simplemente difundir este horario.",
        "Tomamos cada trabajo j asignado a una máquina de alta y lo asignamos en una extensión de 1/m en todas las máquinas; para cada trabajo j asignado a una máquina de baja, digamos i, asignamos una fracción de 1/m a las otras máquinas donde es baja, y asignamos la fracción restante (que es al menos 1/m) a i.",
        "La asignación resultante satisface claramente las propiedades deseadas.",
        "También observe que la carga en cualquier máquina ha aumentado como máximo en 1 m · (carga en otras máquinas) ≤ makespan, y por lo tanto el makespan se ha duplicado como máximo.",
        "Esta distribución también se puede hacer si el horario inicial es fraccionado.",
        "Ahora describimos el algoritmo con precisión.",
        "Algoritmo 1 Sea A cualquier algoritmo que, para cualquier entrada p, genere una asignación posiblemente fraccional x tal que xij > 0 implica que pij ≤ T, donde T es el makespan de x. (En particular, cabe destacar que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades).",
        "Nuestro algoritmo, al que llamamos A, devuelve la siguiente asignación xF.",
        "Inicializar xF ij = 0 para todos los i, j.",
        "Para cada i, j, 1. si pij = Hj, establezca xF ij = P i :pi j =Hj xi j/m; 2. si pij = Lj, establezca xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
        "Teorema 4.4 Supongamos que el algoritmo A cumple las condiciones del Algoritmo 1 y devuelve un makespan de a lo sumo c·OPT(p) para cada p. Entonces, el algoritmo A construido anteriormente es una aproximación 2c, algoritmo fraccional cíclico-monótono.",
        "Además, si xF ij > 0 en la entrada p, entonces pij ≤ c · OPT(p).",
        "Prueba.",
        "Primero, nota que xF es una asignación válida: para cada trabajo j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
        "También tenemos que si pij = Hj, entonces xFij = Pi: pij = Hj xij/m ≤ 1/m.",
        "Si pij = Lj, entonces xF ij = xij(1 − /m) + P i =i xi j/m donde = |{i = i : pi j = Lj}| ≤ m − 1; por lo tanto, xF ij ≥ P i xi j/m ≥ 1/m.",
        "Por lo tanto, según el Lema 4.3, A satisface la monotonía de ciclo.",
        "La carga total en cualquier máquina i bajo xF es a lo sumo P j: pij = Hj P i: pij = Hj Hj · xi j m + P j: pij = Lj Lj ` xij + P i = i xi j m ´, que es a lo sumo P j pijxij + P i = i P j pijxi j/m ≤ 2c · OPT(p).",
        "Finalmente, si xF ij > 0 y pij = Lj, entonces pij ≤ OPT(p).",
        "Si pij = Hj, entonces para algún i (posiblemente i) con pij = Hj, tenemos xi j > 0, por lo tanto, por suposición, pij = Hj = pij ≤ c · OPT(p).",
        "El Teorema 4.4 combinado con los Lemas 4.1 y 4.2, proporciona un mecanismo de aproximación 3c, veraz en expectativa.",
        "La computación de los pagos dependerá del algoritmo de aproximación actual utilizado.",
        "La Sección 3, sin embargo, proporciona un procedimiento explícito para calcular los pagos garantizando la veracidad, aunque quizás no en tiempo polinómico.",
        "Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa.",
        "Tomando A en el Algoritmo 1 como el algoritmo que devuelve una asignación óptima de LP que cumple las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de aproximación 3.",
        "Corolario 4.6 Existe un mecanismo veraz-en-expectativa con una proporción de aproximación de 3 para el escenario Lj-Hj. 5.",
        "Un MECANISMO DETERMINISTA PARA EL CASO DE DOS VALORES Presentamos ahora un mecanismo determinista de aproximación 2-veraz para el caso donde pij ∈ {L, H} para todo i, j.",
        "En la secuela, a menudo diremos que j está asignado a una máquina de baja carga para indicar que j está asignado a una máquina i donde pij = L. Llamaremos a un trabajo j un trabajo de baja carga de la máquina i si pij = L; la carga baja de i es la carga en i debido a sus trabajos de baja carga, es decir, P j:pij = L xijpij.",
        "Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que cumpla con la monotonía de ciclo.",
        "Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar.",
        "Describimos nuestro algoritmo en la Sección 5.1.",
        "En la Sección 5.2, acotamos su garantía de aproximación y demostramos que cumple con la ciclo-monotonía.",
        "En la Sección 5.3, calculamos los pagos explícitos proporcionando un mecanismo veraz.",
        "Finalmente, en la Sección 5.4 demostramos que ningún mecanismo determinista puede lograr el makespan óptimo.",
        "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).\n\nDefina nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Entonces, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
        "Sustituyendo esto en (3) y dividiendo por (H − L), obtenemos lo siguiente.",
        "Proposición 5.1 La monotonía cíclica en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador i, cada p−i, cada entero K, y cada p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación cíclicamente monótono A continuación describimos un algoritmo que satisface la condición (6) y logra una aproximación de 2.",
        "Supondremos que L, H son enteros, lo cual no limita la generalidad.",
        "Un componente fundamental de nuestro algoritmo será un procedimiento que tome un umbral de carga entero T y calcule una asignación parcial entera x de trabajos a máquinas de manera que (a) un trabajo solo se asigna a una máquina de baja carga; (b) la carga en cualquier máquina sea como máximo T; y (c) se maximice el número de trabajos asignados.",
        "Tal asignación se puede calcular resolviendo un problema de flujo máximo: construimos un grafo bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y una arista (j, i) de capacidad infinita si pij = L. También agregamos un nodo fuente s con aristas (s, j) de capacidad 1, y un nodo sumidero t con aristas (i, t) de capacidad T/L.",
        "Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de makespan de a lo sumo T, donde xij = 1 si y solo si hay un flujo de 1 en la arista de j a i.",
        "Por lo tanto, utilizaremos los términos asignación y flujo indistintamente.",
        "Además, siempre hay un flujo máximo integral (ya que todas las capacidades son números enteros).",
        "A menudo nos referiremos a dicho flujo máximo como el flujo máximo para (p, T).",
        "Necesitamos un concepto adicional antes de describir el algoritmo.",
        "Podría haber potencialmente muchos flujos máximos y estaremos interesados en los más equilibrados, los cuales definimos formalmente de la siguiente manera.",
        "Arregla algún flujo máximo.",
        "Deje que ni p,T sea la cantidad de flujo en el borde (i, t) (o equivalentemente el número de trabajos asignados a i en el horario correspondiente), y deje que np,T sea el tamaño total del flujo máximo, es decir, np,T = Σ i ni p,T.",
        "Para cualquier T ≤ T, definimos ni p,T |T = min(ni p,T , T ), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo T.",
        "Define np,T |T = P i ni p,T |T . \n\nDefina np,T |T = P i ni p,T |T.",
        "Definimos un flujo o asignación de prefijo-maximal para T de la siguiente manera.",
        "Definición 5.2 (Flujo prefijo-maximal) Un flujo para la red anterior con umbral T es prefijo-maximal si para cada entero T ≤ T, tenemos np,T |T = np,T.",
        "Es decir, en un flujo de prefijo máximo para (p, T), si truncamos el flujo en algún T ≤ T, nos queda un flujo máximo para (p, T).",
        "Un hecho elemental sobre los flujos es que si una asignación/flujo x no es un flujo máximo para (p, T) entonces debe existir un camino de aumento P = (s, j1, i1, . . . , jK , iK , t) en el grafo residual que nos permita aumentar el tamaño del flujo.",
        "La interpretación es que en la asignación actual, j1 no está asignado, xi j = 0, lo cual se denota por las aristas directas (j , i), y xi j +1 = 1, lo cual se denota por las aristas inversas (i, j +1).",
        "Aumentar x usando P cambia la asignación de manera que cada j se asigna a i en la nueva asignación, lo que aumenta el valor del flujo en 1.",
        "Un camino de aumento simple no disminuye la carga de ninguna máquina; por lo tanto, se puede argumentar que siempre existe un flujo maximal de prefijo para un umbral T.",
        "Primero calculamos un flujo máximo para el umbral 1, utilizamos caminos de aumento simples para aumentarlo a un flujo máximo para el umbral 2, y repetimos el proceso, cada vez aumentando el flujo máximo para el umbral anterior t a un flujo máximo para el umbral t + 1 utilizando caminos de aumento simples.",
        "Algoritmo 2 Dado un vector de tiempos de procesamiento p, construir una asignación de trabajos a máquinas de la siguiente manera. 1.",
        "Calcular T∗ (p) = min ˘ T ≥ H, T múltiplo de L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
        "Se observa que np,T ·L+(n−np,T )·H −m·T es una función decreciente de T, por lo que T∗ (p) se puede calcular en tiempo polinómico mediante búsqueda binaria.",
        "Calcular un flujo prefijo-maximal para el umbral T∗ (p) y la asignación parcial correspondiente (es decir, j se asigna a i si hay 1 unidad de flujo en el borde (j, i)). 3.",
        "Asigna los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera.",
        "Considera estos trabajos en un orden arbitrario y asigna cada trabajo a la máquina con la carga actual más baja (donde la carga incluye los trabajos asignados en la fase de flujo).",
        "Nuestro algoritmo necesita calcular una asignación prefijo-maximal para el umbral T∗ (p).",
        "La prueba que muestra la existencia de un flujo maximal de prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo.",
        "Pero hay que tener en cuenta que el flujo máximo permanece igual para cualquier T ≥ T = n · L. Por lo tanto, un flujo maximal de prefijo para T también es maximal de prefijo para cualquier T ≥ T.",
        "Por lo tanto, solo necesitamos calcular un flujo maximal de prefijo para T = min{T∗ (p), T }.",
        "Esto se puede hacer en tiempo polinómico utilizando el algoritmo de caminos aumentantes iterativos en la prueba de existencia para calcular de forma iterativa el flujo máximo para los múltiplos polinomialmente muchos de L hasta (e incluyendo) T.",
        "Teorema 5.3 Se pueden calcular eficientemente pagos que, combinados con el Algoritmo 2, producen un mecanismo veraz de aproximación determinística 2 para el dominio de programación de dos valores. 5.2 Análisis Sea OPT(p) la duración óptima para p. Ahora demostramos que el Algoritmo 2 es un algoritmo de aproximación 2 que cumple con la monotonía cíclica.",
        "Esto nos permitirá calcular los pagos en la Sección 5.3 y demostrar el Teorema 5.3. 5.2.1 Prueba de la Aproximación Reclamo 5.4 Si OPT(p) < H, el makespan es a lo sumo OPT(p).",
        "Prueba.",
        "Si OPT(p) < H, debe ser que el horario óptimo asigna todos los trabajos a máquinas de baja velocidad, por lo que np,OPT(p) = n. Por lo tanto, tenemos T∗ (p) = L · H L.",
        "Además, dado que calculamos un flujo maximal de prefijo para el umbral T∗(p), tenemos np,T∗(p)|OPT(p) = np,OPT(p) = n, lo que implica que la carga en cada máquina es a lo sumo OPT(p).",
        "Por lo tanto, en este caso el makespan es como máximo (y por lo tanto exactamente) OPT(p).",
        "Reclamo 5.5 Si OPT(p) ≥ H, entonces T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Prueba.",
        "Sea nOPT(p) el número de trabajos asignados a las máquinas de baja en un horario óptimo.",
        "La carga total en todas las máquinas es exactamente nOPT(p) · L + (n − nOPT(p)) · H, y como máximo es m · OPT(p), ya que cada máquina tiene una carga de como máximo OPT(p).",
        "Entonces, tomando T = L · OPT(p) L ≥ H, dado que np,T ≥ nOPT(p) tenemos que np,T ·L+(n−np,T )·H ≤ m·T.",
        "Por lo tanto, T∗ (p), el T más pequeño de este tipo, es a lo sumo L · OPT(p) L.",
        "Reclamo 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina de alta calidad. 258 Prueba.",
        "Supongamos que j se asigna a la máquina i en el paso 3.",
        "Si pij = L, entonces debemos tener ni p,T ∗(p) = T∗ (p), de lo contrario podríamos haber asignado j a i en el paso 2 para obtener un flujo de valor mayor.",
        "Por lo tanto, en el punto justo antes de que se asigne j en el paso 3, la carga de cada máquina debe ser al menos T∗ (p).",
        "Por lo tanto, la carga total después de que se asigna j es al menos m · T∗ (p) + L > m · T∗ (p).",
        "Pero la carga total es como máximo np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), lo que resulta en una contradicción.",
        "Lema 5.7 El algoritmo anterior devuelve un horario con un makespan de a lo sumo OPT(p) + max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
        "Prueba.",
        "Si OPT(p) < H, entonces, según la Afirmación 5.4, hemos terminado.",
        "Entonces supongamos que OPT(p) ≥ H. Por la Afirmación 5.5, sabemos que T∗ (p) ≤ OPT(p) + L. Si no hay trabajos sin asignar después del paso 2 del algoritmo, entonces el tiempo de ejecución es a lo sumo T∗ (p) y hemos terminado.",
        "Así que supongamos que hay algunos trabajos no asignados después del paso 2.",
        "Mostraremos que el makespan después del paso 3 es a lo sumo T +H ` 1− 1 m ´ donde T = min ˘ T∗ (p), OPT(p) ¯ .",
        "Supongamos que la afirmación es falsa.",
        "Sea i la máquina con la carga máxima, entonces li > T + H ` 1 − 1 m ´ .",
        "Deja que j sea el último trabajo asignado a i en el paso 3, y considera el punto justo antes de que se le asigne a i.",
        "Entonces li > T − H/m en este punto.",
        "También, dado que j está asignado a i, según nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos li.",
        "Por lo tanto, la carga total después de que j sea asignado, es al menos H + m · li > m · T (ya que pij = H según la Reclamación 5.6).",
        "Además, para cualquier asignación de trabajos a máquinas en el paso 3, la carga total es a lo sumo np,T ∗(p) · L + (n − np,T ∗(p)) · H ya que hay np,T ∗(p) trabajos asignados a máquinas de baja prioridad.",
        "Por lo tanto, debemos tener m · T < np,T ∗(p) · L + (n - np,T ∗(p)) · H. Pero argumentaremos que m · T ≥ np,T ∗(p) · L + (n - np,T ∗(p)) · H, lo cual conduce a una contradicción.",
        "Si T = T∗ (p), esto se deduce de la definición de T∗ (p).",
        "Si T = OPT(p), entonces dejando que nOPT(p) denote el número de trabajos asignados a las máquinas de baja en un horario óptimo, tenemos np,T ∗(p) ≥ nOPT(p).",
        "Entonces, np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
        "Este es exactamente la carga total en un horario óptimo, que es a lo sumo m · OPT(p). 5.2.2 Prueba de la monotonía del ciclo. Lema 5.8 Considere dos instancias p = (pi, p−i) y p = (pi, p−i) donde pi ≥ pi, es decir, pij ≥ pij ∀j.",
        "Si T es un umbral tal que np,T > np,T, entonces todo flujo máximo x para (p, T) debe asignar todos los trabajos j tales que pij = L. Demostración.",
        "Que Gp denote el grafo residual para (p, T) y el flujo x.",
        "Supongamos por contradicción que existe un trabajo j∗ con pij∗ = L que no está asignado por x.",
        "Dado que pi ≥ pi, todos los bordes (j, i) que están presentes en la red para (p, T) también están presentes en la red para (p, T).",
        "Por lo tanto, x es un flujo válido para (p, T).",
        "Pero no es un flujo máximo, ya que np,T > np,T.",
        "Entonces existe un camino de aumento P en el grafo residual para (p, T) y flujo x.",
        "Observa que el nodo i debe estar incluido en P, de lo contrario P también sería un camino de aumento en el grafo residual Gp, lo que contradiría el hecho de que x es un flujo máximo.",
        "En particular, esto implica que hay un camino P ⊂ P desde i hasta el sumidero t. Sea P = (i, j1, i1, . . . , jK , iK , t).",
        "Todos los bordes de P también están presentes como bordes en Gp: todos los bordes inversos (i, j +1) están presentes ya que dicho borde implica que xi j +1 = 1; todos los bordes directos (j, i) están presentes ya que i = i, por lo que pi j = pi j = L, y xi j +1 = 0.",
        "Pero luego hay un camino de aumento (j∗ , i, j1, i1, . . . , jK , iK , t) en Gp que contradice la maximalidad de x.",
        "Que L denote el vector de tiempo de procesamiento todo bajo.",
        "Define TL i (p−i) = T∗ (L, p−i). \n\nDefina TL i (p−i) = T∗ (L, p−i).",
        "Dado que nos estamos enfocando en la máquina i, y p−i está fijo en todo momento, abreviamos TL i (p−i) como TL.",
        "Además, sea pL = (L, p−i).",
        "Ten en cuenta que T∗ (p) ≥ TL para cada instancia p = (pi, p−i).",
        "Corolario 5.9 Sea p = (pi, p−i) cualquier instancia y sea x cualquier flujo prefijo-maximal para (p, T∗ (p)).",
        "Entonces, la carga baja en la máquina i es como máximo TL.",
        "Prueba.",
        "Que T∗ = T∗ (p).",
        "Si T∗ = TL, entonces esto es claramente cierto.",
        "De lo contrario, considera la asignación x truncada en TL.",
        "Dado que x es prefijo-maximal, sabemos que esto constituye un flujo máximo para (p, TL).",
        "Además, np,T L < npL,T L porque T∗ > TL.",
        "Entonces, según el Lema 5.8, este flujo truncado debe asignar todos los trabajos de baja prioridad de i.",
        "Por lo tanto, no puede haber un trabajo j con pij = L que se asigne a i después del umbral TL, ya que entonces j no sería asignado por este flujo truncado.",
        "Por lo tanto, la carga baja de i es como máximo TL.",
        "Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p−i, p1 i ) y p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) donde n2,1 H y n2,1 L están definidos en (4) y (5), respectivamente.",
        "Observa que esto implica inmediatamente la monotonía del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L; sumando esto sobre todos los k = 1, . . . , K da como resultado (6).",
        "Lema 5.10 Si T∗ (p1) > TL, entonces se cumple la ecuación (7).",
        "Prueba.",
        "Que T1 = T∗ (p1) y T2 = T∗ (p2).",
        "Toma el flujo máximo de prefijo x2 para (p2, T2), trúnquelo en TL y elimine todos los trabajos de esta asignación que se cuentan en n2,1 H, es decir, todos los trabajos j tales que x2 ij = 1, p2 ij = L, p1 ij = H. Denomina este flujo como x.",
        "Observe que x es un flujo válido para (p1, TL), y el tamaño de este flujo es exactamente np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H.",
        "Además, ninguno de los trabajos que se cuentan en n2,1 L está asignado por x, ya que cada trabajo j de este tipo tiene prioridad sobre i en p2.",
        "Dado que T1 > TL, debemos tener np1,TL < npTL,TL.",
        "Por lo tanto, si aumentamos x a un flujo máximo para (p1, TL), entonces, por el Lema 5.8 (con p = pL y p = p1), todos los trabajos correspondientes a n2,1 L deben asignarse en este flujo máximo.",
        "Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1,T L ≥ np2,T L − n2,1 H + n2,1 L, como se afirma.",
        "Lema 5.11 Supongamos que T∗ (p1 ) = TL.",
        "Entonces se cumple (7).",
        "Prueba.",
        "Nuevamente, dejemos que T1 = T∗ (p1) = TL y T2 = T∗ (p2).",
        "Que x1, x2 sean la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculada por nuestro algoritmo para p1, p2 respectivamente.",
        "Sea S = {j : x2 ij = 1 y p2 ij = L} y S = {j : x2 ij = 1 y p1 ij = L}.",
        "Por lo tanto, |S | = |S| − n2,1 H + n2,1 L y |S| = ni p2,T 2 = ni p2,T 2 |T L (por el Corolario 5.9).",
        "Sea T = |S| · L. Consideramos dos casos.",
        "Supongamos primero que T ≤ TL.",
        "Considera el siguiente flujo para (p1, TL): asigna a cada máquina que no sea i la asignación baja de x2 truncada en TL, y asigna los trabajos en S a la máquina i.",
        "Este es un flujo válido para (p1, TL) ya que la carga en i es T ≤ TL.",
        "Su tamaño es igual a P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L.",
        "El tamaño del flujo máximo para (p1, TL) no es menor, y se sigue la afirmación. Ahora supongamos que T > TL.",
        "Dado que |S| · L ≤ TL (por el Corolario 5.9), se sigue que n2,1 L > n2,1 H ≥ 0.",
        "Sea ˆT = T − L ≥ TL ya que T, TL son ambos múltiplos de L. Sea M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2.",
        "Primero demostramos que m · ˆT < M · L + (n − M) · H. (8) Sea N el número de trabajos asignados a la máquina i en x2.",
        "La carga en la máquina i es |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H, lo cual es al menos |S |·L > ˆT ya que n2,1 L ≤ N− |S|.",
        "Así obtenemos la desigualdad |S|·L+(N−|S|)·H > ˆT.",
        "Ahora considera el punto en la ejecución del algoritmo en la instancia p2 justo antes de que el último trabajo de alta prioridad sea asignado a i en el Paso 3 (debe haber tal trabajo ya que n2,1 L > 0).",
        "La carga en i en este punto es |S| · L + (N − |S| − 1) · H, que es al menos |S| · L − L = ˆT por un argumento similar al anterior.",
        "Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆT.",
        "Sumando estas desigualdades para todos los i = i, y la desigualdad anterior para i, obtenemos que |S| · L + (N − |S|) · H + Σ i = i Σ j p2 i jx2 i j > m ˆT.",
        "Pero el lado izquierdo es exactamente M · L + (n − M) · H. Por otro lado, dado que T1 = TL, tenemos m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L) · H. (9) Combinando (8) y (9), obtenemos que np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L.",
        "El Lema 5.12 del Algoritmo 2 satisface la monotonía del ciclo.",
        "Prueba.",
        "Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L.",
        "Sumando esto sobre todos los k = 1, . . . , K (donde K + 1 ≡ 1) se obtiene (6). 5.3 Cálculo de precios Los lemas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de aproximación 2 que satisface la monotonía de ciclo.",
        "Por lo tanto, según la discusión en la Sección 3, existen precios que generan un mecanismo veraz.",
        "Para obtener un mecanismo de tiempo polinómico, también necesitamos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico.",
        "No está claro si el procedimiento descrito en la Sección 3, basado en calcular los caminos más cortos en el grafo de asignación, produce un algoritmo de tiempo polinómico, ya que el grafo de asignación tiene un número exponencial de nodos (uno por cada asignación de salida).",
        "En lugar de analizar el grafo de asignación, aprovecharemos nuestra prueba de monotonía del ciclo, en particular, la desigualdad (7), y simplemente detallaremos los pagos.",
        "Recuerda que la utilidad de un jugador es ui = Pi − li, donde Pi es el pago realizado al jugador i.",
        "Para mayor comodidad, primero especificaremos los pagos negativos (es decir, los PIs serán los precios cobrados a los jugadores) y luego mostraremos que estos pueden ser modificados para que los jugadores tengan utilidades no negativas (si actúan de manera veraz).",
        "Que Hi denote el número de trabajos asignados a la máquina i en el paso 3.",
        "Por el Corolario 5.6, sabemos que todos estos trabajos están asignados a máquinas de alta calidad (según los pis declarados).",
        "Deja que H−i = P i =i Hi y n−i p,T = P i =i ni p,T.",
        "El pago Pi al jugador i se define como: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10). Podemos interpretar nuestros pagos como igualar el costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios VCG).",
        "Los primeros y segundos términos en (10), al restarse de la carga li, igualan el costo al total de la carga.",
        "El término np,T ∗(p) − np,T L i (p−i) es de hecho igual a n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) ya que la carga baja en i es a lo sumo TL i (p−i) (según la Reclamación 5.9).",
        "Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos de baja prioridad que fueron asignados más allá del umbral TL i (p−i) (a máquinas distintas de i) efectivamente como trabajos de alta prioridad para el cálculo total de utilidad desde su punto de vista.",
        "No está claro cómo se podrían haber ideado estos pagos de antemano para demostrar la veracidad de nuestro algoritmo.",
        "Sin embargo, al depender de la monotonía del ciclo, no solo pudimos argumentar la existencia de pagos, sino que nuestra prueba allanó el camino para inferir realmente estos pagos.",
        "El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan lugar a un mecanismo veraz.",
        "Lema 5.13 Fija un jugador i y las declaraciones de los otros jugadores p−i.",
        "Deje que su tipo verdadero sea p1 i.",
        "Entonces, bajo los pagos definidos en (10), la utilidad cuando declara su verdadero tipo p1 i es al menos su utilidad cuando declara cualquier otro tipo p2 i.",
        "Prueba.",
        "Que c1 i, c2 i denoten su costo total, definido como el negativo de su utilidad, cuando ella declara p1 y p2, respectivamente (y los demás declaran p−i).",
        "Dado que p−i está fijo, omitimos p−i de las expresiones a continuación para mayor claridad notacional.",
        "La verdadera carga de i cuando declara su verdadero tipo p1 i es L · ni p1,T ∗(p1) + H · Hi (p1), y por lo tanto c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) Por otro lado, la verdadera carga cuando declara p2 i es L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L) + H · (Hi + n2,1 H − n2,1 L) (ya que el vector de tiempo de procesamiento verdadero es p1 i), y así c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L.",
        "Por lo tanto, (7) implica que c1 i ≤ c2 i.",
        "Las especificaciones de precios suelen requerirse para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de un jugador debe ser no negativa si revela su valor real.",
        "Los pagos dados por (10) no son individualmente racionales ya que en realidad le cobran a un jugador una cierta cantidad.",
        "Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficientemente grande a la definición del precio.",
        "En nuestro caso, por ejemplo, dejando que H denote el vector de todas las H, podemos añadir el término n·H −(H −L)n(H,p−i),T L i (p−i) a (10).",
        "Ten en cuenta que esto es una constante para el jugador i.",
        "Por lo tanto, los nuevos pagos son Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
        "Como se muestra en (11), esto resultará en una utilidad no negativa para i (ya que n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) para cualquier tipo pi del jugador i).",
        "Esta modificación también garantiza la propiedad de normalización adicional deseada de que si un jugador no recibe trabajos, entonces recibe un pago de cero: si el jugador i recibe el conjunto vacío para algún tipo pi, entonces también recibirá el conjunto vacío para el tipo H (esto es fácil de verificar para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero; por lo tanto, por veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que i reciba el conjunto vacío.",
        "Esto completa la demostración del Teorema 5.3. 260 5.4 Imposibilidad de implementación exacta. Ahora mostramos que, independientemente de consideraciones computacionales, no existe un algoritmo cíclico-monótono para el caso L-H con una proporción de aproximación mejor que 1.14.",
        "Sea H = α·L para algún 2 < α < 2.5 que elegiremos más tarde.",
        "Hay dos máquinas I, II y siete trabajos.",
        "Considera los siguientes dos escenarios: Escenario 1.",
        "Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5 son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna los trabajos 1-5 a una máquina y los trabajos 6, 7 a la otra, y tiene un makespan OPT1 = 5L.",
        "El segundo mejor horario tiene un tiempo de ejecución de al menos Second1 = 2H + L. Escenario 2.",
        "Si el algoritmo elige un horario óptimo para el escenario 1, asuma sin pérdida de generalidad que los trabajos 6 y 7 están asignados a la máquina II.",
        "En el escenario 2, la máquina I tiene el mismo vector de tiempos de procesamiento.",
        "La Máquina II reduce los trabajos 6 y 7 a L y aumenta los trabajos 1-5 a H. Un horario óptimo tiene un tiempo de ejecución de 2L + H, donde la Máquina II realiza los trabajos 6, 7 y uno de los trabajos 1-5.",
        "La segunda mejor programación para este escenario tiene un makespan de al menos Second2 = 5L.",
        "Teorema 5.14 Ningún mecanismo determinístico y veraz para el problema de programación de dos valores puede obtener una proporción de aproximación mejor que 1.14.",
        "Prueba.",
        "Primero argumentamos que un algoritmo cíclico-monótono no puede elegir el horario óptimo en ambos escenarios.",
        "Esto se debe a que de lo contrario se viola la monotonía del ciclo para la máquina II.",
        "Tomando p1 II , p2 II como vectores de tiempos de procesamiento de la máquina II para los escenarios 1, 2 respectivamente, obtenemos P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
        "Por lo tanto, cualquier mecanismo veraz debe devolver un makespan subóptimo en al menos un escenario, y por lo tanto su ratio de aproximación es al menos min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 para α = 2.364.",
        "Observamos que para el caso {Lj, Hj} donde hay una razón común r = Hj Lj para todos los trabajos (esto generaliza el escenario de máquinas restringidas) se puede obtener un mecanismo fraccional veraz (con precios computables eficientemente) que devuelve un horario de makespan de a lo sumo OPT(p) para cada p. Se puede ver cada trabajo j como consistente de Lj subtrabajos de tamaño 1 en una máquina i si pij = Lj, y de tamaño r si pij = Hj.",
        "Para esta nueva instancia ˜p, nota que ˜pij ∈ {1, r} para cada i, j.",
        "También hay que tener en cuenta que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxij =P j : subtrabajo de j ˜pij ˜xij.",
        "Por lo tanto, si utilizamos el Algoritmo 2 para obtener un horario para la instancia ˜p, la ecuación (6) se traduce precisamente a (3) para la asignación x; además, los precios para ˜p se traducen en precios para la instancia p. El número de subtrabajos asignados a máquinas de baja en la fase de flujo es simplemente el trabajo total asignado a las máquinas de baja.",
        "Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a las máquinas de baja capacidad.",
        "Además, dado que tenemos un dominio fraccional, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p).",
        "La asignación x no necesita cumplir la condición de que xij > 0 implica pij ≤ OPT(p) para cualquier r, por lo tanto, el procedimiento de redondeo del Lema 4.2 no produce un mecanismo de aproximación 2-veraz en expectativa.",
        "Pero si r > OPT(p) (como en el escenario de máquinas restringidas), esta condición sí se cumple, por lo que obtenemos un mecanismo veraz de aproximación 2.",
        "Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda en refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus comentarios útiles. 6.",
        "REFERENCIAS [1] N. Andelman, Y. Azar y M. Sorani.",
        "Mecanismos de aproximación veraces para la programación de máquinas relacionadas egoístas.",
        "En Proc. 22º STACS, 69-82, 2005. [2] A. Archer.",
        "Mecanismos para la optimización discreta con agentes racionales.",
        "Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´E.",
        "This word does not have a meaning in English. Could you please provide more context or clarify the sentence?",
        "Mecanismos veraces para agentes de un parámetro.",
        "En Proc. 42º FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano.",
        "Mecanismos de aproximación veraces determinísticos para máquinas relacionadas con la programación.",
        "En Proc. 21º STACS, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani.",
        "Asignación de bienes indivisibles.",
        "En ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La debilidad de la monotonicidad caracteriza la implementación de estrategias dominantes determinísticas.",
        "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking.",
        "Técnicas de aproximación para el diseño de mecanismos utilitarios.",
        "En Proc. 37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali.",
        "Un límite inferior para los mecanismos de programación.",
        "En Proc. 18th SODA, páginas 1163-1170, 2007. [9] E. Clarke.",
        "Precios escalonados de bienes públicos.",
        "Elección Pública, 8:17-33, 1971. [10] T. Groves.",
        "Incentivos en equipos.",
        "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, y R. V. Vohra.",
        "Caracterizando mecanismos de estrategia dominante con tipos multidimensionales, 2004.",
        "Documento de trabajo. [12] L. A.",
        "Sala.",
        "Algoritmos de aproximación para la programación de tareas.",
        "En D. Hochbaum, editor, Algoritmos de Aproximación para Problemas NP-Difíciles.",
        "PWS Publishing, MA, 1996. [13] A. Kovács.",
        "Algoritmo de aproximación rápida y monótona 3 para la programación de máquinas relacionadas.",
        "En Proc. 13th ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan.",
        "Algoritmos de aproximación para la programación en múltiples máquinas.",
        "En Proc. 46th FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan.",
        "Hacia una caracterización de subastas combinatorias veraces.",
        "En Proc. 44th FOCS, páginas 574-583, 2003. [16] R. Lavi y C. Swamy.",
        "Diseño de mecanismos veraz y casi óptimos a través de programación lineal.",
        "En Proc. 46th FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. OCallaghan y Y. Shoham.",
        "Revelación de la verdad en subastas combinatorias aproximadamente eficientes.",
        "Revista de la ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, y ´E.",
        "This word does not have a meaning in English. Could you please provide more context or another sentence for translation?",
        "Algoritmos de aproximación para la programación de máquinas paralelas no relacionadas.",
        "Matemáticas.",
        "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. \n\nProg., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, y A. Saberi.",
        "Sobre asignaciones aproximadamente justas de bienes indivisibles.",
        "En Proc. 5to EC, páginas 125-131, 2004. [20] A. Mualem y M. Schapira.",
        "Estableciendo límites inferiores en la veracidad.",
        "En Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
        "Diseño óptimo de subasta.",
        "Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [22] N. Nisan y A. Ronen.",
        "Diseño de mecanismos algorítmicos.",
        "Juegos y Economía.",
        "Comportamiento, 35:166-196, 2001. [23] J. C. Rochet.",
        "Una condición necesaria y suficiente para la racionalización en un contexto cuasilineal.",
        "Revista de Economía Matemática, 16:191-200, 1987. [24] M. Saks y L. Yu.",
        "La monotonía débil es suficiente para la veracidad en dominios convexos.",
        "En Proc. 6to EC, páginas 286-293, 2005. [25] D. B. Shmoys y ´E.",
        "This word does not have a specific meaning in English. Could you please provide more context or another sentence for translation?",
        "Un algoritmo de aproximación para el problema de asignación generalizada.",
        "Programación Matemática, 62:461-474, 1993. [26] W. Vickrey.",
        "Contraespeculaciones, subastas y licitaciones selladas competitivas.",
        "I'm sorry, but the sentence \"J.\" does not have a clear meaning or context for translation. Could you please provide more information or a complete sentence for me to translate into Spanish?",
        "Finanzas, 16:8-37, 1961. 261"
    ],
    "error_count": 1,
    "keys": {
        "mechanism design": {
            "translated_key": "diseño de mecanismos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful <br>mechanism design</br> for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic <br>mechanism design</br>, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful <br>mechanism design</br>.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION <br>mechanism design</br> studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic <br>mechanism design</br> has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via <br>mechanism design</br>: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of <br>mechanism design</br>.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other <br>mechanism design</br> settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful <br>mechanism design</br> for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful <br>mechanism design</br> for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful <br>mechanism design</br> in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful <br>mechanism design</br>.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful <br>mechanism design</br> for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in <br>mechanism design</br>.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 <br>mechanism design</br> We consider the makespan-minimization problem in the above scheduling domains in the context of <br>mechanism design</br>.",
                "<br>mechanism design</br> studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic <br>mechanism design</br> several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our <br>mechanism design</br> problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian <br>mechanism design</br>.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal <br>mechanism design</br> via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic <br>mechanism design</br>.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Truthful <br>mechanism design</br> for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic <br>mechanism design</br>, where the machines are the strategic players.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful <br>mechanism design</br>.",
                "INTRODUCTION <br>mechanism design</br> studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic <br>mechanism design</br> has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Hence, we approach the problem via <br>mechanism design</br>: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos.",
                "Esto se basa en una técnica de [16], y muestra la utilidad de los <br>mecanismos fraccionarios</br> en el diseño de mecanismos veraces.",
                "INTRODUCCIÓN El <br>diseño de mecanismos</br> estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo.",
                "El <br>diseño de mecanismos</br> algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal.",
                "Por lo tanto, abordamos el problema a través del <br>diseño de mecanismos</br>: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los <br>mecanismos fraccionarios</br> en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El <br>diseño de mecanismos</br> estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El <br>diseño de mecanismos</br> algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del <br>diseño de mecanismos</br>: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. ",
            "candidates": [],
            "error": [
                [
                    "mecanismos fraccionarios",
                    "diseño de mecanismos",
                    "diseño de mecanismos",
                    "diseño de mecanismos"
                ]
            ]
        },
        "approximation algorithm": {
            "translated_key": "algoritmo de aproximación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-<br>approximation algorithm</br> to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an <br>approximation algorithm</br> in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-<br>approximation algorithm</br> can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary <br>approximation algorithm</br>, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the <br>approximation algorithm</br> in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an <br>approximation algorithm</br> for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-<br>approximation algorithm</br> into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary <br>approximation algorithm</br> given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the <br>approximation algorithm</br> returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-<br>approximation algorithm</br> to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the <br>approximation algorithm</br> returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual <br>approximation algorithm</br> used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an <br>approximation algorithm</br> that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone <br>approximation algorithm</br> We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-<br>approximation algorithm</br> that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-<br>approximation algorithm</br> for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An <br>approximation algorithm</br> for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "We give a general technique to convert any c-<br>approximation algorithm</br> to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an <br>approximation algorithm</br> in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Consider, for example, our first result showing that any c-<br>approximation algorithm</br> can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary <br>approximation algorithm</br>, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the <br>approximation algorithm</br> in a rather simple fashion, while losing a factor of 2 in the approximation ratio."
            ],
            "translated_annotated_samples": [
                "Ofrecemos una técnica general para convertir cualquier <br>algoritmo de c-aproximación</br> en un mecanismo de verdad en expectativa de 3c-aproximación.",
                "Este es uno de los pocos resultados conocidos que utilizan un <br>algoritmo de aproximación</br> de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional.",
                "Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier <br>algoritmo de c-aproximación</br> puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c.",
                "A nivel de generalidad de un <br>algoritmo de aproximación</br> arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido.",
                "Moverse a un dominio fraccional nos permite incorporar la veracidad en el <br>algoritmo de aproximación</br> de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier <br>algoritmo de c-aproximación</br> en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un <br>algoritmo de aproximación</br> de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier <br>algoritmo de c-aproximación</br> puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un <br>algoritmo de aproximación</br> arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un dominio fraccional nos permite incorporar la veracidad en el <br>algoritmo de aproximación</br> de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. ",
            "candidates": [],
            "error": [
                [
                    "algoritmo de c-aproximación",
                    "algoritmo de aproximación",
                    "algoritmo de c-aproximación",
                    "algoritmo de aproximación",
                    "algoritmo de aproximación"
                ]
            ]
        },
        "scheduling": {
            "translated_key": "programación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional <br>scheduling</br> via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional <br>scheduling</br> domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in <br>scheduling</br>.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional <br>scheduling</br> domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine <br>scheduling</br>, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in <br>scheduling</br> environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional <br>scheduling</br> are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such <br>scheduling</br> domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of <br>scheduling</br> in strategic environments, ideas from multidimensional <br>scheduling</br> may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values <br>scheduling</br> model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional <br>scheduling</br> domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional <br>scheduling</br> domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine <br>scheduling</br>.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The <br>scheduling</br> domain In our <br>scheduling</br> problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic <br>scheduling</br> model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above <br>scheduling</br> domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A <br>scheduling</br> mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two <br>scheduling</br> domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the <br>scheduling</br> domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the <br>scheduling</br> setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific <br>scheduling</br> domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} <br>scheduling</br> domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values <br>scheduling</br> domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values <br>scheduling</br> domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value <br>scheduling</br> problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for <br>scheduling</br> selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for <br>scheduling</br> related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for <br>scheduling</br> mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for <br>scheduling</br>.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for <br>scheduling</br> related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for <br>scheduling</br> on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for <br>scheduling</br> unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Truthful Mechanism Design for Multi-Dimensional <br>scheduling</br> via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional <br>scheduling</br> domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in <br>scheduling</br>.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional <br>scheduling</br> domain.",
                "In this paper, we consider such an alternative goal in the context of machine <br>scheduling</br>, namely, makespan minimization."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos veraces para <br>programación</br> multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos.",
                "Este es un dominio de <br>programación</br> multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20].",
                "Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la <br>programación</br>.",
                "Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de <br>programación</br> multidimensional.",
                "En este artículo, consideramos un objetivo alternativo en el contexto de la <br>programación de máquinas</br>, a saber, la minimización del makespan."
            ],
            "translated_text": "Diseño de mecanismos veraces para <br>programación</br> multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de <br>programación</br> multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la <br>programación</br>. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de <br>programación</br> multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la <br>programación de máquinas</br>, a saber, la minimización del makespan. ",
            "candidates": [],
            "error": [
                [
                    "programación",
                    "programación",
                    "programación",
                    "programación",
                    "programación de máquinas"
                ]
            ]
        },
        "multi-dimensional scheduling": {
            "translated_key": "programación multidimensional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for <br>multi-dimensional scheduling</br> via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Truthful Mechanism Design for <br>multi-dimensional scheduling</br> via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos veraces para <br>programación multidimensional</br> a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos."
            ],
            "translated_text": "Diseño de mecanismos veraces para <br>programación multidimensional</br> a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un dominio fraccional nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas. Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación. Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces. Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas. Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz. Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorio de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13]. El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro mecanismo aleatorio. La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13]. Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales. Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos. En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia. Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas. Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz. Estos límites inferiores fueron fortalecidos en [20]. PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina. En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos. Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2. El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj. Usaremos los términos horario y tarea indistintamente. Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j. También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional. En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li. El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos. El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados. Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j. El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias. Para un mecanismo aleatorio, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en expectativa para un mecanismo aleatorio, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)). Para nuestros dos dominios de programación, la suposición informativa es que los valores Lj, Hj son de conocimiento público. La información privada de una máquina es qué trabajos tienen valor Lj (o L) y cuáles tienen valor Hj (o H) en ella. Enfatizamos que ambos de nuestros dominios son multidimensionales, ya que cada máquina i necesita especificar un vector que indique qué trabajos son bajos y altos en ella. Aunque la veracidad se define en términos de pagos, resulta que en realidad la veracidad se reduce a una cierta condición algorítmica de monotonicidad. Esto parece haber sido observado por primera vez para dominios multidimensionales por Rochet [23] en 1987, y ha sido utilizado con éxito en el diseño algorítmico de mecanismos varias veces, pero para dominios unidimensionales. Sin embargo, para dominios multidimensionales, la condición de monotonía es más compleja y no ha habido éxito en emplearla en el diseño de mecanismos veraces. La mayoría de los resultados positivos para dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad. Una de las principales contribuciones de este artículo es demostrar que la condición de monotonía para entornos multidimensionales, a veces llamada monotonía cíclica, puede ser efectivamente utilizada para diseñar mecanismos veraces. Incluimos una breve exposición sobre ello para completitud. La exposición aquí se basa en gran medida en [11]. La monotonía cíclica se describe mejor en el marco abstracto de elección social: hay un conjunto finito A de alternativas, hay m jugadores, y cada jugador tiene un tipo privado (función de valoración) v: A → R, donde vi(a) debe interpretarse como su valor para la alternativa a. En el ámbito de la programación, A representa todas las posibles asignaciones de trabajos a máquinas, y vi(a) es el negativo de su carga en el horario a. Que Vi denote el conjunto de todos los posibles tipos de jugador i. Un mecanismo es una tupla (f, {Pi}) donde f : V1 × · · · × Vm → A es el algoritmo para elegir la alternativa, y Pi : V1 × · · · × Vm → A es el precio cobrado al jugador i (en el contexto de programación, el mecanismo paga a los jugadores, lo que corresponde a precios negativos). El mecanismo es veraz si para cada i, cada v−i ∈ V−i = Q i =i Vi, y cualquier vi, vi ∈ Vi, tenemos que vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), donde a = f(vi, v−i) y b = f(vi, v−i). Una pregunta básica que surge es si dado un algoritmo f: V1 × · · · × Vm → A, ¿existen precios que harán que el mecanismo resultante sea veraz? Es bien sabido (ver por ejemplo [15]) que el precio Pi solo puede depender de la alternativa elegida y las otras declaraciones, es decir, podemos escribir Pi : V−i × A → R. Por lo tanto, la veracidad implica que para cada i, cada v−i ∈ V−i, y cualquier vi, vi ∈ Vi con f(vi, v−i) = a y f(vi, v−i) = b, tenemos vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i). Ahora fija un jugador i, y fija las declaraciones v−i de los demás. Buscamos una asignación a las variables {Pa}a∈A tal que vi(a) − vi(b) ≥ Pa − Pb para todo a, b ∈ A y vi ∈ Vi con f(vi, v−i) = a. (Estrictamente hablando, deberíamos usar A = f(Vi, v−i) en lugar de A aquí). Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. \n\nDefina δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {Pa}a∈A tal que Pa − Pb ≤ δa,b ∀a, b ∈ A (2). Esto se resuelve fácilmente al observar el grafo de asignación y aplicar un resultado básico estándar de teoría de grafos. Definición 3.1 (Gui et al. [11]): El grafo de asignación de f es un grafo dirigido ponderado G = (A, E) donde E = A × A y el peso de una arista b → a (para cualquier a, b ∈ A) es δa,b. Teorema 3.2 Existe una asignación factible para (2) si y solo si el grafo de asignación no tiene ciclos de longitud negativa. Además, si todos los ciclos son no negativos, una asignación factible es 255 obtenida de la siguiente manera: fije un nodo arbitrario a∗ ∈ A y establezca Pa como la longitud del camino más corto desde a∗ hasta a. Esto lleva a la siguiente definición, que es otra forma de expresar la condición de que el grafo de asignación no tenga ciclos negativos. Definición 3.3 (Monotonía de ciclo) Una función de elección social f satisface la monotonía de ciclo si para cada jugador i, cada v−i ∈ V−i, cada entero K, y cada v1 i , . . . , vK i ∈ Vi, Σ k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 donde ak = f(vk i , v−i) para 1 ≤ k ≤ K, y aK+1 = a1. Corolario 3.4 Existen precios P tales que el mecanismo (f, P) es veraz si y solo si f satisface la monotonicidad del ciclo. Ahora consideramos nuestro dominio específico de programación. Fija un jugador i, p−i, y cualquier p1 i, . . . , pK i. Sea x(pk i , p−i) = xk para 1 ≤ k ≤ K, y sea xK+1 = x1 , pK+1 = p1 . xk podría ser una asignación {0, 1} o una asignación fraccional. Tenemos vk i (xk ) = − P j xk ijpk ij, por lo que la monotonía del ciclo se traduce en PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0. Reorganizando, obtenemos KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Por lo tanto, (3) reduce nuestro problema de diseño de mecanismos a un problema algorítmico concreto. Para la mayor parte de este documento, ignoraremos consecuentemente cualquier consideración estratégica y nos enfocaremos en diseñar un algoritmo de aproximación para minimizar el makespan que cumpla con (3). 4. Una TÉCNICA GENERAL PARA OBTENER MECANISMOS ALEATORIOS En esta sección, consideramos el caso de valores Lj, Hj dependientes del trabajo (con Lj ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde Hj = ∞). Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se proporciona como una caja negra. Nuestra construcción y demostración son simples, y se basan en dos ideas. Primero, como se ha mencionado anteriormente, demostramos la veracidad utilizando la monotonía de ciclo. Parece poco probable que para un algoritmo de aproximación arbitrario dado solo como una caja negra, se pueda encontrar pagos para demostrar la veracidad; pero la ciclo-monotonía nos permite demostrar precisamente esto. Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un dominio fraccional y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros. Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el uso de mecanismos fraccionarios para obtener mecanismos veraces en expectativa. No está claro si el Teorema 3.2, y por lo tanto, esta afirmación, se cumple si A no es finito. Debemos señalar, sin embargo, que no se puede simplemente ingresar los resultados de [16]. Sus resultados son válidos para problemas de maximización del bienestar social y se basan en el uso de VCG para obtener un mecanismo fraccional veraz. Sin embargo, VCG no se aplica a la minimización del makespan, y en nuestro caso ni siquiera se conoce la existencia de un mecanismo fraccional veraz cercano a óptimo. Utilizamos el siguiente resultado adaptado de [16]. Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, P) un mecanismo fraccional veraz. Sea A un algoritmo de redondeo aleatorio que, dado un asignación fraccional x, produce una asignación aleatoria X tal que E ˆ Xij ˜ = xij para todo i, j. Entonces existen pagos P tales que el mecanismo M = (A, P) es veraz en promedio. Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de lanzamientos de moneda. Sea OPT(p) el makespan óptimo (sobre horarios enteros) para la instancia p. Como primer paso, tomamos un algoritmo de aproximación c y lo convertimos en un mecanismo fraccional de verdad de aproximación 2c. Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (satisfaciendo ciertas propiedades) de makespan a lo sumo c · OPT(p) para cada instancia p. Demostramos la veracidad mostrando que el algoritmo fraccional satisface la monotonía de ciclo (3). Observa que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinito): su cardinalidad es a lo sumo la del dominio de entrada, que es a lo sumo 2mn en el caso de dos valores. Por lo tanto, podemos aplicar el Corolario 3.4 aquí. Para convertir este mecanismo fraccional veraz en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que cumpla con los requisitos del Lema 4.1. Afortunadamente, dicho procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14]. Lema 4.2 (Kumar et al. [14]): Dada una asignación fraccional x y un vector de tiempos de procesamiento p, existe un procedimiento de redondeo aleatorio que produce una asignación X (aleatoria) tal que, 1. para cualquier i, j, E ˆ Xij ˜ = xij. 2. para cualquier i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij con probabilidad 1. La propiedad 1 se utilizará para obtener veracidad en la expectativa, y la propiedad 2 nos permitirá demostrar una garantía de aproximación. Primero demostramos que cualquier algoritmo que devuelva una asignación fraccional con ciertas propiedades satisface la monotonía de ciclo. Lema 4.3 Sea A un algoritmo que, para cualquier entrada p, produce una asignación (fraccional) x tal que, si pij = Hj entonces xij ≤ 1/m, y si pij = Lj entonces xij ≥ 1/m. Entonces A satisface la ciclo-monotonía. Prueba. Fija un jugador i y el vector de tiempos de procesamiento de los otros jugadores p−i. Necesitamos demostrar (3), es decir, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 para cada p1 i , . . . , pK i , donde el índice k = K + 1 se toma como k = 1. Demostraremos que para cada trabajo j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Si pk ij es el mismo para todos los k (ya sea siempre Lj o siempre Hj), entonces la desigualdad anterior claramente se cumple. De lo contrario, podemos dividir los índices 1, . . . , K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos k , k + 1, . . . , k − 1, k (donde K + 1 ≡ 1) tal que pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj. Esto se cumple porque debe haber algún k tal que pk ij = Hj > pk−1 ij = Lj. Tomamos k = k y luego seguimos incluyendo índices en este segmento hasta que alcancemos un k tal que pk ij = Lj y pk+1 ij = Hj. Establecemos k = k, y luego comenzamos un nuevo segmento maximal con índice k + 1. Ten en cuenta que k = k y k + 1 = k − 1. Ahora tenemos un subconjunto de índices y podemos continuar de forma recursiva. Entonces, todos los índices están incluidos en algún segmento maximal. Mostraremos que para cada segmento maximal k, k +1, . . . , k, P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Agregar esto para cada segmento produce la desigualdad deseada. Así que ahora concéntrate en un segmento maximal k, k + 1, . . . , k − 1, k. Por lo tanto, existe un k∗ tal que para k ≤ k < k∗ , tenemos pk ij = Hj, y para k∗ ≤ k ≤ k , tenemos pk ij = Lj. Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk∗ ij dado que pk ij = Hj y pk∗ ij = Lj. Ahora describimos cómo usar un algoritmo de c-aproximación para obtener un algoritmo que cumpla con la propiedad en el Lema 4.3. Para simplificar, primero supongamos que el algoritmo de aproximación devuelve un horario integral. La idea es simplemente difundir este horario. Tomamos cada trabajo j asignado a una máquina de alta y lo asignamos en una extensión de 1/m en todas las máquinas; para cada trabajo j asignado a una máquina de baja, digamos i, asignamos una fracción de 1/m a las otras máquinas donde es baja, y asignamos la fracción restante (que es al menos 1/m) a i. La asignación resultante satisface claramente las propiedades deseadas. También observe que la carga en cualquier máquina ha aumentado como máximo en 1 m · (carga en otras máquinas) ≤ makespan, y por lo tanto el makespan se ha duplicado como máximo. Esta distribución también se puede hacer si el horario inicial es fraccionado. Ahora describimos el algoritmo con precisión. Algoritmo 1 Sea A cualquier algoritmo que, para cualquier entrada p, genere una asignación posiblemente fraccional x tal que xij > 0 implica que pij ≤ T, donde T es el makespan de x. (En particular, cabe destacar que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades). Nuestro algoritmo, al que llamamos A, devuelve la siguiente asignación xF. Inicializar xF ij = 0 para todos los i, j. Para cada i, j, 1. si pij = Hj, establezca xF ij = P i :pi j =Hj xi j/m; 2. si pij = Lj, establezca xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m. Teorema 4.4 Supongamos que el algoritmo A cumple las condiciones del Algoritmo 1 y devuelve un makespan de a lo sumo c·OPT(p) para cada p. Entonces, el algoritmo A construido anteriormente es una aproximación 2c, algoritmo fraccional cíclico-monótono. Además, si xF ij > 0 en la entrada p, entonces pij ≤ c · OPT(p). Prueba. Primero, nota que xF es una asignación válida: para cada trabajo j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1. También tenemos que si pij = Hj, entonces xFij = Pi: pij = Hj xij/m ≤ 1/m. Si pij = Lj, entonces xF ij = xij(1 − /m) + P i =i xi j/m donde = |{i = i : pi j = Lj}| ≤ m − 1; por lo tanto, xF ij ≥ P i xi j/m ≥ 1/m. Por lo tanto, según el Lema 4.3, A satisface la monotonía de ciclo. La carga total en cualquier máquina i bajo xF es a lo sumo P j: pij = Hj P i: pij = Hj Hj · xi j m + P j: pij = Lj Lj ` xij + P i = i xi j m ´, que es a lo sumo P j pijxij + P i = i P j pijxi j/m ≤ 2c · OPT(p). Finalmente, si xF ij > 0 y pij = Lj, entonces pij ≤ OPT(p). Si pij = Hj, entonces para algún i (posiblemente i) con pij = Hj, tenemos xi j > 0, por lo tanto, por suposición, pij = Hj = pij ≤ c · OPT(p). El Teorema 4.4 combinado con los Lemas 4.1 y 4.2, proporciona un mecanismo de aproximación 3c, veraz en expectativa. La computación de los pagos dependerá del algoritmo de aproximación actual utilizado. La Sección 3, sin embargo, proporciona un procedimiento explícito para calcular los pagos garantizando la veracidad, aunque quizás no en tiempo polinómico. Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Tomando A en el Algoritmo 1 como el algoritmo que devuelve una asignación óptima de LP que cumple las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de aproximación 3. Corolario 4.6 Existe un mecanismo veraz-en-expectativa con una proporción de aproximación de 3 para el escenario Lj-Hj. 5. Un MECANISMO DETERMINISTA PARA EL CASO DE DOS VALORES Presentamos ahora un mecanismo determinista de aproximación 2-veraz para el caso donde pij ∈ {L, H} para todo i, j. En la secuela, a menudo diremos que j está asignado a una máquina de baja carga para indicar que j está asignado a una máquina i donde pij = L. Llamaremos a un trabajo j un trabajo de baja carga de la máquina i si pij = L; la carga baja de i es la carga en i debido a sus trabajos de baja carga, es decir, P j:pij = L xijpij. Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que cumpla con la monotonía de ciclo. Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar. Describimos nuestro algoritmo en la Sección 5.1. En la Sección 5.2, acotamos su garantía de aproximación y demostramos que cumple con la ciclo-monotonía. En la Sección 5.3, calculamos los pagos explícitos proporcionando un mecanismo veraz. Finalmente, en la Sección 5.4 demostramos que ningún mecanismo determinista puede lograr el makespan óptimo. Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).\n\nDefina nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Entonces, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L). Sustituyendo esto en (3) y dividiendo por (H − L), obtenemos lo siguiente. Proposición 5.1 La monotonía cíclica en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador i, cada p−i, cada entero K, y cada p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación cíclicamente monótono A continuación describimos un algoritmo que satisface la condición (6) y logra una aproximación de 2. Supondremos que L, H son enteros, lo cual no limita la generalidad. Un componente fundamental de nuestro algoritmo será un procedimiento que tome un umbral de carga entero T y calcule una asignación parcial entera x de trabajos a máquinas de manera que (a) un trabajo solo se asigna a una máquina de baja carga; (b) la carga en cualquier máquina sea como máximo T; y (c) se maximice el número de trabajos asignados. Tal asignación se puede calcular resolviendo un problema de flujo máximo: construimos un grafo bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y una arista (j, i) de capacidad infinita si pij = L. También agregamos un nodo fuente s con aristas (s, j) de capacidad 1, y un nodo sumidero t con aristas (i, t) de capacidad T/L. Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de makespan de a lo sumo T, donde xij = 1 si y solo si hay un flujo de 1 en la arista de j a i. Por lo tanto, utilizaremos los términos asignación y flujo indistintamente. Además, siempre hay un flujo máximo integral (ya que todas las capacidades son números enteros). A menudo nos referiremos a dicho flujo máximo como el flujo máximo para (p, T). Necesitamos un concepto adicional antes de describir el algoritmo. Podría haber potencialmente muchos flujos máximos y estaremos interesados en los más equilibrados, los cuales definimos formalmente de la siguiente manera. Arregla algún flujo máximo. Deje que ni p,T sea la cantidad de flujo en el borde (i, t) (o equivalentemente el número de trabajos asignados a i en el horario correspondiente), y deje que np,T sea el tamaño total del flujo máximo, es decir, np,T = Σ i ni p,T. Para cualquier T ≤ T, definimos ni p,T |T = min(ni p,T , T ), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo T. Define np,T |T = P i ni p,T |T . \n\nDefina np,T |T = P i ni p,T |T. Definimos un flujo o asignación de prefijo-maximal para T de la siguiente manera. Definición 5.2 (Flujo prefijo-maximal) Un flujo para la red anterior con umbral T es prefijo-maximal si para cada entero T ≤ T, tenemos np,T |T = np,T. Es decir, en un flujo de prefijo máximo para (p, T), si truncamos el flujo en algún T ≤ T, nos queda un flujo máximo para (p, T). Un hecho elemental sobre los flujos es que si una asignación/flujo x no es un flujo máximo para (p, T) entonces debe existir un camino de aumento P = (s, j1, i1, . . . , jK , iK , t) en el grafo residual que nos permita aumentar el tamaño del flujo. La interpretación es que en la asignación actual, j1 no está asignado, xi j = 0, lo cual se denota por las aristas directas (j , i), y xi j +1 = 1, lo cual se denota por las aristas inversas (i, j +1). Aumentar x usando P cambia la asignación de manera que cada j se asigna a i en la nueva asignación, lo que aumenta el valor del flujo en 1. Un camino de aumento simple no disminuye la carga de ninguna máquina; por lo tanto, se puede argumentar que siempre existe un flujo maximal de prefijo para un umbral T. Primero calculamos un flujo máximo para el umbral 1, utilizamos caminos de aumento simples para aumentarlo a un flujo máximo para el umbral 2, y repetimos el proceso, cada vez aumentando el flujo máximo para el umbral anterior t a un flujo máximo para el umbral t + 1 utilizando caminos de aumento simples. Algoritmo 2 Dado un vector de tiempos de procesamiento p, construir una asignación de trabajos a máquinas de la siguiente manera. 1. Calcular T∗ (p) = min ˘ T ≥ H, T múltiplo de L : np,T · L + (n − np,T ) · H ≤ m · T ¯ . Se observa que np,T ·L+(n−np,T )·H −m·T es una función decreciente de T, por lo que T∗ (p) se puede calcular en tiempo polinómico mediante búsqueda binaria. Calcular un flujo prefijo-maximal para el umbral T∗ (p) y la asignación parcial correspondiente (es decir, j se asigna a i si hay 1 unidad de flujo en el borde (j, i)). 3. Asigna los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera. Considera estos trabajos en un orden arbitrario y asigna cada trabajo a la máquina con la carga actual más baja (donde la carga incluye los trabajos asignados en la fase de flujo). Nuestro algoritmo necesita calcular una asignación prefijo-maximal para el umbral T∗ (p). La prueba que muestra la existencia de un flujo maximal de prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo. Pero hay que tener en cuenta que el flujo máximo permanece igual para cualquier T ≥ T = n · L. Por lo tanto, un flujo maximal de prefijo para T también es maximal de prefijo para cualquier T ≥ T. Por lo tanto, solo necesitamos calcular un flujo maximal de prefijo para T = min{T∗ (p), T }. Esto se puede hacer en tiempo polinómico utilizando el algoritmo de caminos aumentantes iterativos en la prueba de existencia para calcular de forma iterativa el flujo máximo para los múltiplos polinomialmente muchos de L hasta (e incluyendo) T. Teorema 5.3 Se pueden calcular eficientemente pagos que, combinados con el Algoritmo 2, producen un mecanismo veraz de aproximación determinística 2 para el dominio de programación de dos valores. 5.2 Análisis Sea OPT(p) la duración óptima para p. Ahora demostramos que el Algoritmo 2 es un algoritmo de aproximación 2 que cumple con la monotonía cíclica. Esto nos permitirá calcular los pagos en la Sección 5.3 y demostrar el Teorema 5.3. 5.2.1 Prueba de la Aproximación Reclamo 5.4 Si OPT(p) < H, el makespan es a lo sumo OPT(p). Prueba. Si OPT(p) < H, debe ser que el horario óptimo asigna todos los trabajos a máquinas de baja velocidad, por lo que np,OPT(p) = n. Por lo tanto, tenemos T∗ (p) = L · H L. Además, dado que calculamos un flujo maximal de prefijo para el umbral T∗(p), tenemos np,T∗(p)|OPT(p) = np,OPT(p) = n, lo que implica que la carga en cada máquina es a lo sumo OPT(p). Por lo tanto, en este caso el makespan es como máximo (y por lo tanto exactamente) OPT(p). Reclamo 5.5 Si OPT(p) ≥ H, entonces T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Prueba. Sea nOPT(p) el número de trabajos asignados a las máquinas de baja en un horario óptimo. La carga total en todas las máquinas es exactamente nOPT(p) · L + (n − nOPT(p)) · H, y como máximo es m · OPT(p), ya que cada máquina tiene una carga de como máximo OPT(p). Entonces, tomando T = L · OPT(p) L ≥ H, dado que np,T ≥ nOPT(p) tenemos que np,T ·L+(n−np,T )·H ≤ m·T. Por lo tanto, T∗ (p), el T más pequeño de este tipo, es a lo sumo L · OPT(p) L. Reclamo 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina de alta calidad. 258 Prueba. Supongamos que j se asigna a la máquina i en el paso 3. Si pij = L, entonces debemos tener ni p,T ∗(p) = T∗ (p), de lo contrario podríamos haber asignado j a i en el paso 2 para obtener un flujo de valor mayor. Por lo tanto, en el punto justo antes de que se asigne j en el paso 3, la carga de cada máquina debe ser al menos T∗ (p). Por lo tanto, la carga total después de que se asigna j es al menos m · T∗ (p) + L > m · T∗ (p). Pero la carga total es como máximo np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), lo que resulta en una contradicción. Lema 5.7 El algoritmo anterior devuelve un horario con un makespan de a lo sumo OPT(p) + max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p). Prueba. Si OPT(p) < H, entonces, según la Afirmación 5.4, hemos terminado. Entonces supongamos que OPT(p) ≥ H. Por la Afirmación 5.5, sabemos que T∗ (p) ≤ OPT(p) + L. Si no hay trabajos sin asignar después del paso 2 del algoritmo, entonces el tiempo de ejecución es a lo sumo T∗ (p) y hemos terminado. Así que supongamos que hay algunos trabajos no asignados después del paso 2. Mostraremos que el makespan después del paso 3 es a lo sumo T +H ` 1− 1 m ´ donde T = min ˘ T∗ (p), OPT(p) ¯ . Supongamos que la afirmación es falsa. Sea i la máquina con la carga máxima, entonces li > T + H ` 1 − 1 m ´ . Deja que j sea el último trabajo asignado a i en el paso 3, y considera el punto justo antes de que se le asigne a i. Entonces li > T − H/m en este punto. También, dado que j está asignado a i, según nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos li. Por lo tanto, la carga total después de que j sea asignado, es al menos H + m · li > m · T (ya que pij = H según la Reclamación 5.6). Además, para cualquier asignación de trabajos a máquinas en el paso 3, la carga total es a lo sumo np,T ∗(p) · L + (n − np,T ∗(p)) · H ya que hay np,T ∗(p) trabajos asignados a máquinas de baja prioridad. Por lo tanto, debemos tener m · T < np,T ∗(p) · L + (n - np,T ∗(p)) · H. Pero argumentaremos que m · T ≥ np,T ∗(p) · L + (n - np,T ∗(p)) · H, lo cual conduce a una contradicción. Si T = T∗ (p), esto se deduce de la definición de T∗ (p). Si T = OPT(p), entonces dejando que nOPT(p) denote el número de trabajos asignados a las máquinas de baja en un horario óptimo, tenemos np,T ∗(p) ≥ nOPT(p). Entonces, np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H. Este es exactamente la carga total en un horario óptimo, que es a lo sumo m · OPT(p). 5.2.2 Prueba de la monotonía del ciclo. Lema 5.8 Considere dos instancias p = (pi, p−i) y p = (pi, p−i) donde pi ≥ pi, es decir, pij ≥ pij ∀j. Si T es un umbral tal que np,T > np,T, entonces todo flujo máximo x para (p, T) debe asignar todos los trabajos j tales que pij = L. Demostración. Que Gp denote el grafo residual para (p, T) y el flujo x. Supongamos por contradicción que existe un trabajo j∗ con pij∗ = L que no está asignado por x. Dado que pi ≥ pi, todos los bordes (j, i) que están presentes en la red para (p, T) también están presentes en la red para (p, T). Por lo tanto, x es un flujo válido para (p, T). Pero no es un flujo máximo, ya que np,T > np,T. Entonces existe un camino de aumento P en el grafo residual para (p, T) y flujo x. Observa que el nodo i debe estar incluido en P, de lo contrario P también sería un camino de aumento en el grafo residual Gp, lo que contradiría el hecho de que x es un flujo máximo. En particular, esto implica que hay un camino P ⊂ P desde i hasta el sumidero t. Sea P = (i, j1, i1, . . . , jK , iK , t). Todos los bordes de P también están presentes como bordes en Gp: todos los bordes inversos (i, j +1) están presentes ya que dicho borde implica que xi j +1 = 1; todos los bordes directos (j, i) están presentes ya que i = i, por lo que pi j = pi j = L, y xi j +1 = 0. Pero luego hay un camino de aumento (j∗ , i, j1, i1, . . . , jK , iK , t) en Gp que contradice la maximalidad de x. Que L denote el vector de tiempo de procesamiento todo bajo. Define TL i (p−i) = T∗ (L, p−i). \n\nDefina TL i (p−i) = T∗ (L, p−i). Dado que nos estamos enfocando en la máquina i, y p−i está fijo en todo momento, abreviamos TL i (p−i) como TL. Además, sea pL = (L, p−i). Ten en cuenta que T∗ (p) ≥ TL para cada instancia p = (pi, p−i). Corolario 5.9 Sea p = (pi, p−i) cualquier instancia y sea x cualquier flujo prefijo-maximal para (p, T∗ (p)). Entonces, la carga baja en la máquina i es como máximo TL. Prueba. Que T∗ = T∗ (p). Si T∗ = TL, entonces esto es claramente cierto. De lo contrario, considera la asignación x truncada en TL. Dado que x es prefijo-maximal, sabemos que esto constituye un flujo máximo para (p, TL). Además, np,T L < npL,T L porque T∗ > TL. Entonces, según el Lema 5.8, este flujo truncado debe asignar todos los trabajos de baja prioridad de i. Por lo tanto, no puede haber un trabajo j con pij = L que se asigne a i después del umbral TL, ya que entonces j no sería asignado por este flujo truncado. Por lo tanto, la carga baja de i es como máximo TL. Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p−i, p1 i ) y p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) donde n2,1 H y n2,1 L están definidos en (4) y (5), respectivamente. Observa que esto implica inmediatamente la monotonía del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L; sumando esto sobre todos los k = 1, . . . , K da como resultado (6). Lema 5.10 Si T∗ (p1) > TL, entonces se cumple la ecuación (7). Prueba. Que T1 = T∗ (p1) y T2 = T∗ (p2). Toma el flujo máximo de prefijo x2 para (p2, T2), trúnquelo en TL y elimine todos los trabajos de esta asignación que se cuentan en n2,1 H, es decir, todos los trabajos j tales que x2 ij = 1, p2 ij = L, p1 ij = H. Denomina este flujo como x. Observe que x es un flujo válido para (p1, TL), y el tamaño de este flujo es exactamente np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H. Además, ninguno de los trabajos que se cuentan en n2,1 L está asignado por x, ya que cada trabajo j de este tipo tiene prioridad sobre i en p2. Dado que T1 > TL, debemos tener np1,TL < npTL,TL. Por lo tanto, si aumentamos x a un flujo máximo para (p1, TL), entonces, por el Lema 5.8 (con p = pL y p = p1), todos los trabajos correspondientes a n2,1 L deben asignarse en este flujo máximo. Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1,T L ≥ np2,T L − n2,1 H + n2,1 L, como se afirma. Lema 5.11 Supongamos que T∗ (p1 ) = TL. Entonces se cumple (7). Prueba. Nuevamente, dejemos que T1 = T∗ (p1) = TL y T2 = T∗ (p2). Que x1, x2 sean la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculada por nuestro algoritmo para p1, p2 respectivamente. Sea S = {j : x2 ij = 1 y p2 ij = L} y S = {j : x2 ij = 1 y p1 ij = L}. Por lo tanto, |S | = |S| − n2,1 H + n2,1 L y |S| = ni p2,T 2 = ni p2,T 2 |T L (por el Corolario 5.9). Sea T = |S| · L. Consideramos dos casos. Supongamos primero que T ≤ TL. Considera el siguiente flujo para (p1, TL): asigna a cada máquina que no sea i la asignación baja de x2 truncada en TL, y asigna los trabajos en S a la máquina i. Este es un flujo válido para (p1, TL) ya que la carga en i es T ≤ TL. Su tamaño es igual a P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L. El tamaño del flujo máximo para (p1, TL) no es menor, y se sigue la afirmación. Ahora supongamos que T > TL. Dado que |S| · L ≤ TL (por el Corolario 5.9), se sigue que n2,1 L > n2,1 H ≥ 0. Sea ˆT = T − L ≥ TL ya que T, TL son ambos múltiplos de L. Sea M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2. Primero demostramos que m · ˆT < M · L + (n − M) · H. (8) Sea N el número de trabajos asignados a la máquina i en x2. La carga en la máquina i es |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H, lo cual es al menos |S |·L > ˆT ya que n2,1 L ≤ N− |S|. Así obtenemos la desigualdad |S|·L+(N−|S|)·H > ˆT. Ahora considera el punto en la ejecución del algoritmo en la instancia p2 justo antes de que el último trabajo de alta prioridad sea asignado a i en el Paso 3 (debe haber tal trabajo ya que n2,1 L > 0). La carga en i en este punto es |S| · L + (N − |S| − 1) · H, que es al menos |S| · L − L = ˆT por un argumento similar al anterior. Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆT. Sumando estas desigualdades para todos los i = i, y la desigualdad anterior para i, obtenemos que |S| · L + (N − |S|) · H + Σ i = i Σ j p2 i jx2 i j > m ˆT. Pero el lado izquierdo es exactamente M · L + (n − M) · H. Por otro lado, dado que T1 = TL, tenemos m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L) · H. (9) Combinando (8) y (9), obtenemos que np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L. El Lema 5.12 del Algoritmo 2 satisface la monotonía del ciclo. Prueba. Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L. Sumando esto sobre todos los k = 1, . . . , K (donde K + 1 ≡ 1) se obtiene (6). 5.3 Cálculo de precios Los lemas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de aproximación 2 que satisface la monotonía de ciclo. Por lo tanto, según la discusión en la Sección 3, existen precios que generan un mecanismo veraz. Para obtener un mecanismo de tiempo polinómico, también necesitamos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico. No está claro si el procedimiento descrito en la Sección 3, basado en calcular los caminos más cortos en el grafo de asignación, produce un algoritmo de tiempo polinómico, ya que el grafo de asignación tiene un número exponencial de nodos (uno por cada asignación de salida). En lugar de analizar el grafo de asignación, aprovecharemos nuestra prueba de monotonía del ciclo, en particular, la desigualdad (7), y simplemente detallaremos los pagos. Recuerda que la utilidad de un jugador es ui = Pi − li, donde Pi es el pago realizado al jugador i. Para mayor comodidad, primero especificaremos los pagos negativos (es decir, los PIs serán los precios cobrados a los jugadores) y luego mostraremos que estos pueden ser modificados para que los jugadores tengan utilidades no negativas (si actúan de manera veraz). Que Hi denote el número de trabajos asignados a la máquina i en el paso 3. Por el Corolario 5.6, sabemos que todos estos trabajos están asignados a máquinas de alta calidad (según los pis declarados). Deja que H−i = P i =i Hi y n−i p,T = P i =i ni p,T. El pago Pi al jugador i se define como: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10). Podemos interpretar nuestros pagos como igualar el costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios VCG). Los primeros y segundos términos en (10), al restarse de la carga li, igualan el costo al total de la carga. El término np,T ∗(p) − np,T L i (p−i) es de hecho igual a n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) ya que la carga baja en i es a lo sumo TL i (p−i) (según la Reclamación 5.9). Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos de baja prioridad que fueron asignados más allá del umbral TL i (p−i) (a máquinas distintas de i) efectivamente como trabajos de alta prioridad para el cálculo total de utilidad desde su punto de vista. No está claro cómo se podrían haber ideado estos pagos de antemano para demostrar la veracidad de nuestro algoritmo. Sin embargo, al depender de la monotonía del ciclo, no solo pudimos argumentar la existencia de pagos, sino que nuestra prueba allanó el camino para inferir realmente estos pagos. El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan lugar a un mecanismo veraz. Lema 5.13 Fija un jugador i y las declaraciones de los otros jugadores p−i. Deje que su tipo verdadero sea p1 i. Entonces, bajo los pagos definidos en (10), la utilidad cuando declara su verdadero tipo p1 i es al menos su utilidad cuando declara cualquier otro tipo p2 i. Prueba. Que c1 i, c2 i denoten su costo total, definido como el negativo de su utilidad, cuando ella declara p1 y p2, respectivamente (y los demás declaran p−i). Dado que p−i está fijo, omitimos p−i de las expresiones a continuación para mayor claridad notacional. La verdadera carga de i cuando declara su verdadero tipo p1 i es L · ni p1,T ∗(p1) + H · Hi (p1), y por lo tanto c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) Por otro lado, la verdadera carga cuando declara p2 i es L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L) + H · (Hi + n2,1 H − n2,1 L) (ya que el vector de tiempo de procesamiento verdadero es p1 i), y así c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L. Por lo tanto, (7) implica que c1 i ≤ c2 i. Las especificaciones de precios suelen requerirse para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de un jugador debe ser no negativa si revela su valor real. Los pagos dados por (10) no son individualmente racionales ya que en realidad le cobran a un jugador una cierta cantidad. Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficientemente grande a la definición del precio. En nuestro caso, por ejemplo, dejando que H denote el vector de todas las H, podemos añadir el término n·H −(H −L)n(H,p−i),T L i (p−i) a (10). Ten en cuenta que esto es una constante para el jugador i. Por lo tanto, los nuevos pagos son Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ . Como se muestra en (11), esto resultará en una utilidad no negativa para i (ya que n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) para cualquier tipo pi del jugador i). Esta modificación también garantiza la propiedad de normalización adicional deseada de que si un jugador no recibe trabajos, entonces recibe un pago de cero: si el jugador i recibe el conjunto vacío para algún tipo pi, entonces también recibirá el conjunto vacío para el tipo H (esto es fácil de verificar para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero; por lo tanto, por veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que i reciba el conjunto vacío. Esto completa la demostración del Teorema 5.3. 260 5.4 Imposibilidad de implementación exacta. Ahora mostramos que, independientemente de consideraciones computacionales, no existe un algoritmo cíclico-monótono para el caso L-H con una proporción de aproximación mejor que 1.14. Sea H = α·L para algún 2 < α < 2.5 que elegiremos más tarde. Hay dos máquinas I, II y siete trabajos. Considera los siguientes dos escenarios: Escenario 1. Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5 son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna los trabajos 1-5 a una máquina y los trabajos 6, 7 a la otra, y tiene un makespan OPT1 = 5L. El segundo mejor horario tiene un tiempo de ejecución de al menos Second1 = 2H + L. Escenario 2. Si el algoritmo elige un horario óptimo para el escenario 1, asuma sin pérdida de generalidad que los trabajos 6 y 7 están asignados a la máquina II. En el escenario 2, la máquina I tiene el mismo vector de tiempos de procesamiento. La Máquina II reduce los trabajos 6 y 7 a L y aumenta los trabajos 1-5 a H. Un horario óptimo tiene un tiempo de ejecución de 2L + H, donde la Máquina II realiza los trabajos 6, 7 y uno de los trabajos 1-5. La segunda mejor programación para este escenario tiene un makespan de al menos Second2 = 5L. Teorema 5.14 Ningún mecanismo determinístico y veraz para el problema de programación de dos valores puede obtener una proporción de aproximación mejor que 1.14. Prueba. Primero argumentamos que un algoritmo cíclico-monótono no puede elegir el horario óptimo en ambos escenarios. Esto se debe a que de lo contrario se viola la monotonía del ciclo para la máquina II. Tomando p1 II , p2 II como vectores de tiempos de procesamiento de la máquina II para los escenarios 1, 2 respectivamente, obtenemos P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0. Por lo tanto, cualquier mecanismo veraz debe devolver un makespan subóptimo en al menos un escenario, y por lo tanto su ratio de aproximación es al menos min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 para α = 2.364. Observamos que para el caso {Lj, Hj} donde hay una razón común r = Hj Lj para todos los trabajos (esto generaliza el escenario de máquinas restringidas) se puede obtener un mecanismo fraccional veraz (con precios computables eficientemente) que devuelve un horario de makespan de a lo sumo OPT(p) para cada p. Se puede ver cada trabajo j como consistente de Lj subtrabajos de tamaño 1 en una máquina i si pij = Lj, y de tamaño r si pij = Hj. Para esta nueva instancia ˜p, nota que ˜pij ∈ {1, r} para cada i, j. También hay que tener en cuenta que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxij =P j : subtrabajo de j ˜pij ˜xij. Por lo tanto, si utilizamos el Algoritmo 2 para obtener un horario para la instancia ˜p, la ecuación (6) se traduce precisamente a (3) para la asignación x; además, los precios para ˜p se traducen en precios para la instancia p. El número de subtrabajos asignados a máquinas de baja en la fase de flujo es simplemente el trabajo total asignado a las máquinas de baja. Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a las máquinas de baja capacidad. Además, dado que tenemos un dominio fraccional, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p). La asignación x no necesita cumplir la condición de que xij > 0 implica pij ≤ OPT(p) para cualquier r, por lo tanto, el procedimiento de redondeo del Lema 4.2 no produce un mecanismo de aproximación 2-veraz en expectativa. Pero si r > OPT(p) (como en el escenario de máquinas restringidas), esta condición sí se cumple, por lo que obtenemos un mecanismo veraz de aproximación 2. Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda en refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus comentarios útiles. 6. REFERENCIAS [1] N. Andelman, Y. Azar y M. Sorani. Mecanismos de aproximación veraces para la programación de máquinas relacionadas egoístas. En Proc. 22º STACS, 69-82, 2005. [2] A. Archer. Mecanismos para la optimización discreta con agentes racionales. Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´E. This word does not have a meaning in English. Could you please provide more context or clarify the sentence? Mecanismos veraces para agentes de un parámetro. En Proc. 42º FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano. Mecanismos de aproximación veraces determinísticos para máquinas relacionadas con la programación. En Proc. 21º STACS, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani. Asignación de bienes indivisibles. En ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La debilidad de la monotonicidad caracteriza la implementación de estrategias dominantes determinísticas. Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking. Técnicas de aproximación para el diseño de mecanismos utilitarios. En Proc. 37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali. Un límite inferior para los mecanismos de programación. En Proc. 18th SODA, páginas 1163-1170, 2007. [9] E. Clarke. Precios escalonados de bienes públicos. Elección Pública, 8:17-33, 1971. [10] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, y R. V. Vohra. Caracterizando mecanismos de estrategia dominante con tipos multidimensionales, 2004. Documento de trabajo. [12] L. A. Sala. Algoritmos de aproximación para la programación de tareas. En D. Hochbaum, editor, Algoritmos de Aproximación para Problemas NP-Difíciles. PWS Publishing, MA, 1996. [13] A. Kovács. Algoritmo de aproximación rápida y monótona 3 para la programación de máquinas relacionadas. En Proc. 13th ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan. Algoritmos de aproximación para la programación en múltiples máquinas. En Proc. 46th FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan. Hacia una caracterización de subastas combinatorias veraces. En Proc. 44th FOCS, páginas 574-583, 2003. [16] R. Lavi y C. Swamy. Diseño de mecanismos veraz y casi óptimos a través de programación lineal. En Proc. 46th FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. OCallaghan y Y. Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Revista de la ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, y ´E. This word does not have a meaning in English. Could you please provide more context or another sentence for translation? Algoritmos de aproximación para la programación de máquinas paralelas no relacionadas. Matemáticas. Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. \n\nProg., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, y A. Saberi. Sobre asignaciones aproximadamente justas de bienes indivisibles. En Proc. 5to EC, páginas 125-131, 2004. [20] A. Mualem y M. Schapira. Estableciendo límites inferiores en la veracidad. En Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [22] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Economía. Comportamiento, 35:166-196, 2001. [23] J. C. Rochet. Una condición necesaria y suficiente para la racionalización en un contexto cuasilineal. Revista de Economía Matemática, 16:191-200, 1987. [24] M. Saks y L. Yu. La monotonía débil es suficiente para la veracidad en dominios convexos. En Proc. 6to EC, páginas 286-293, 2005. [25] D. B. Shmoys y ´E. This word does not have a specific meaning in English. Could you please provide more context or another sentence for translation? Un algoritmo de aproximación para el problema de asignación generalizada. Programación Matemática, 62:461-474, 1993. [26] W. Vickrey. Contraespeculaciones, subastas y licitaciones selladas competitivas. I'm sorry, but the sentence \"J.\" does not have a clear meaning or context for translation. Could you please provide more information or a complete sentence for me to translate into Spanish? Finanzas, 16:8-37, 1961. 261 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "cycle monotonicity": {
            "translated_key": "monotonicidad del ciclo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via <br>cycle monotonicity</br> Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy <br>cycle monotonicity</br>.",
                "<br>cycle monotonicity</br> [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages <br>cycle monotonicity</br> in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called <br>cycle monotonicity</br>, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that <br>cycle monotonicity</br> can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, <br>cycle monotonicity</br> does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of <br>cycle monotonicity</br> seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that <br>cycle monotonicity</br> is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "<br>cycle monotonicity</br> Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called <br>cycle monotonicity</br>, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "<br>cycle monotonicity</br> is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (<br>cycle monotonicity</br>) A social choice function f satisfies <br>cycle monotonicity</br> if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies <br>cycle monotonicity</br>1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so <br>cycle monotonicity</br> translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using <br>cycle monotonicity</br>.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies <br>cycle monotonicity</br> (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies <br>cycle monotonicity</br>.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies <br>cycle monotonicity</br>.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies <br>cycle monotonicity</br>.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 <br>cycle monotonicity</br> in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies <br>cycle monotonicity</br>.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of <br>cycle monotonicity</br> Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies <br>cycle monotonicity</br>, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies <br>cycle monotonicity</br>.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies <br>cycle monotonicity</br>.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of <br>cycle monotonicity</br>, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on <br>cycle monotonicity</br>, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise <br>cycle monotonicity</br> is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via <br>cycle monotonicity</br> Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy <br>cycle monotonicity</br>.",
                "<br>cycle monotonicity</br> [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages <br>cycle monotonicity</br> in the multidimensional setting.",
                "The monotonicity condition we use, which is sometimes called <br>cycle monotonicity</br>, was first proposed by Rochet [23] (see also [11])."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos veraces para programación multidimensional a través de la <br>monotonía cíclica</br>. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos.",
                "Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la <br>monotonicidad del ciclo</br>.",
                "La <br>monotonía cíclica</br> [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales.",
                "Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la <br>monotonía de ciclo</br> en el entorno multidimensional.",
                "La condición de monotonía que utilizamos, a veces llamada <br>monotonía cíclica</br>, fue propuesta por primera vez por Rochet [23] (ver también [11])."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la <br>monotonía cíclica</br>. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la <br>monotonicidad del ciclo</br>. La <br>monotonía cíclica</br> [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la <br>monotonía de ciclo</br> en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada <br>monotonía cíclica</br>, fue propuesta por primera vez por Rochet [23] (ver también [11]). ",
            "candidates": [],
            "error": [
                [
                    "monotonía cíclica",
                    "monotonicidad del ciclo",
                    "monotonía cíclica",
                    "monotonía de ciclo",
                    "monotonía cíclica"
                ]
            ]
        },
        "makespan minimization": {
            "translated_key": "minimización del makespan",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of <br>makespan minimization</br> on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for <br>makespan minimization</br> in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, <br>makespan minimization</br>.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "<br>makespan minimization</br> is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for <br>makespan minimization</br> is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to <br>makespan minimization</br>, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of <br>makespan minimization</br> on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for <br>makespan minimization</br> in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, <br>makespan minimization</br>.",
                "<br>makespan minimization</br> is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "The possibility of constructing a truthful mechanism for <br>makespan minimization</br> is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de <br>minimización del makespan</br> en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos.",
                "Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la <br>minimización del makespan</br> en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20].",
                "En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la <br>minimización del makespan</br>.",
                "La <br>minimización del makespan</br> es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]).",
                "La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de <br>minimización del makespan</br> en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la <br>minimización del makespan</br> en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la <br>minimización del makespan</br>. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La <br>minimización del makespan</br> es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "algorithm": {
            "translated_key": "algoritmo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation <br>algorithm</br> to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the <br>algorithm</br>.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation <br>algorithm</br> for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation <br>algorithm</br> in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable <br>algorithm</br>, i.e., an <br>algorithm</br> for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation <br>algorithm</br> can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation <br>algorithm</br>, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying <br>algorithm</br> (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation <br>algorithm</br> in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such <br>algorithm</br>.",
                "Shmoys and Tardos [25] later gave a 2approximation <br>algorithm</br> for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding <br>algorithm</br> that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized <br>algorithm</br>, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the <br>algorithm</br> for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an <br>algorithm</br> f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation <br>algorithm</br> for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation <br>algorithm</br> into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the <br>algorithm</br> is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation <br>algorithm</br> given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding <br>algorithm</br> that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation <br>algorithm</br> and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation <br>algorithm</br> returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional <br>algorithm</br> satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any <br>algorithm</br> that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an <br>algorithm</br> that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation <br>algorithm</br> to obtain an <br>algorithm</br> satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation <br>algorithm</br> returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the <br>algorithm</br> precisely.",
                "<br>algorithm</br> 1 Let A be any <br>algorithm</br> that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our <br>algorithm</br>, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose <br>algorithm</br> A satisfies the conditions in <br>algorithm</br> 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation <br>algorithm</br> used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in <br>algorithm</br> 1 converts any c-approximation fractional <br>algorithm</br> into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in <br>algorithm</br> 1 to be the <br>algorithm</br> that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation <br>algorithm</br> that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our <br>algorithm</br> in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation <br>algorithm</br> We now describe an <br>algorithm</br> that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our <br>algorithm</br> will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the <br>algorithm</br>.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "<br>algorithm</br> 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our <br>algorithm</br> needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time <br>algorithm</br> for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths <br>algorithm</br> in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with <br>algorithm</br> 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that <br>algorithm</br> 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the <br>algorithm</br> is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above <br>algorithm</br> returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the <br>algorithm</br>, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our <br>algorithm</br> for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the <br>algorithm</br> on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 <br>algorithm</br> 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our <br>algorithm</br> is a 2approximation <br>algorithm</br> that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time <br>algorithm</br>, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our <br>algorithm</br>.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific <br>algorithm</br>), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone <br>algorithm</br> for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the <br>algorithm</br> chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone <br>algorithm</br> cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use <br>algorithm</br> 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation <br>algorithm</br> for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation <br>algorithm</br> for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "We give a general technique to convert any c-approximation <br>algorithm</br> to a 3capproximation truthful-in-expectation mechanism.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the <br>algorithm</br>.",
                "Our first result is a general method to convert any capproximation <br>algorithm</br> for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation <br>algorithm</br> in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable <br>algorithm</br>, i.e., an <br>algorithm</br> for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability)."
            ],
            "translated_annotated_samples": [
                "Ofrecemos una técnica general para convertir cualquier <br>algoritmo</br> de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación.",
                "INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen <br>los datos de entrada</br> del algoritmo.",
                "Nuestro primer resultado es un método general para convertir cualquier <br>algoritmo</br> de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa.",
                "Este es uno de los pocos resultados conocidos que utilizan un <br>algoritmo de aproximación</br> de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional.",
                "En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un <br>algoritmo</br> implementable, es decir, un <br>algoritmo</br> para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad)."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier <br>algoritmo</br> de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen <br>los datos de entrada</br> del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier <br>algoritmo</br> de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un <br>algoritmo de aproximación</br> de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un <br>algoritmo</br> implementable, es decir, un <br>algoritmo</br> para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). ",
            "candidates": [],
            "error": [
                [
                    "algoritmo",
                    "los datos de entrada",
                    "algoritmo",
                    "algoritmo de aproximación",
                    "algoritmo",
                    "algoritmo"
                ]
            ]
        },
        "randomized mechanism": {
            "translated_key": "mecanismo aleatorio",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our <br>randomized mechanism</br> is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation <br>randomized mechanism</br> [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our <br>randomized mechanism</br>.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a <br>randomized mechanism</br>, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a <br>randomized mechanism</br>, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our <br>randomized mechanism</br> by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Our <br>randomized mechanism</br> is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation <br>randomized mechanism</br> [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "We use their procedure in our <br>randomized mechanism</br>.",
                "For a <br>randomized mechanism</br>, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a <br>randomized mechanism</br>, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i))."
            ],
            "translated_annotated_samples": [
                "Nuestro <br>mecanismo aleatorio</br> se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional.",
                "Esto se ha mejorado en [2, 4, 1, 13] a: un <br>mecanismo aleatorio</br> de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13].",
                "Utilizamos su procedimiento en nuestro <br>mecanismo aleatorio</br>.",
                "Para un <br>mecanismo aleatorio</br>, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento.",
                "La desigualdad (1) también define la veracidad en expectativa para un <br>mecanismo aleatorio</br>, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i))."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro <br>mecanismo aleatorio</br> se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un dominio fraccional nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas. Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación. Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces. Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas. Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz. Esto se ha mejorado en [2, 4, 1, 13] a: un <br>mecanismo aleatorio</br> de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13]. El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro <br>mecanismo aleatorio</br>. La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13]. Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales. Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos. En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia. Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas. Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz. Estos límites inferiores fueron fortalecidos en [20]. PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina. En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos. Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2. El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj. Usaremos los términos horario y tarea indistintamente. Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j. También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional. En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li. El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos. El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados. Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j. El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias. Para un <br>mecanismo aleatorio</br>, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en expectativa para un <br>mecanismo aleatorio</br>, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "usefulness of fractional mechanism": {
            "translated_key": "mecanismos fraccionarios",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the <br>usefulness of fractional mechanism</br>s in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "This builds upon a technique of [16], and shows the <br>usefulness of fractional mechanism</br>s in truthful mechanism design."
            ],
            "translated_annotated_samples": [
                "Esto se basa en una técnica de [16], y muestra la utilidad de los <br>mecanismos fraccionarios</br> en el diseño de mecanismos veraces."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los <br>mecanismos fraccionarios</br> en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un dominio fraccional nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas. Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación. Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces. Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas. Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz. Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorio de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13]. El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro mecanismo aleatorio. La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13]. Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales. Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos. En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia. Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas. Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz. Estos límites inferiores fueron fortalecidos en [20]. PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina. En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos. Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2. El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj. Usaremos los términos horario y tarea indistintamente. Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j. También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional. En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li. El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos. El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados. Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j. El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias. Para un mecanismo aleatorio, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en expectativa para un mecanismo aleatorio, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)). Para nuestros dos dominios de programación, la suposición informativa es que los valores Lj, Hj son de conocimiento público. La información privada de una máquina es qué trabajos tienen valor Lj (o L) y cuáles tienen valor Hj (o H) en ella. Enfatizamos que ambos de nuestros dominios son multidimensionales, ya que cada máquina i necesita especificar un vector que indique qué trabajos son bajos y altos en ella. Aunque la veracidad se define en términos de pagos, resulta que en realidad la veracidad se reduce a una cierta condición algorítmica de monotonicidad. Esto parece haber sido observado por primera vez para dominios multidimensionales por Rochet [23] en 1987, y ha sido utilizado con éxito en el diseño algorítmico de mecanismos varias veces, pero para dominios unidimensionales. Sin embargo, para dominios multidimensionales, la condición de monotonía es más compleja y no ha habido éxito en emplearla en el diseño de mecanismos veraces. La mayoría de los resultados positivos para dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad. Una de las principales contribuciones de este artículo es demostrar que la condición de monotonía para entornos multidimensionales, a veces llamada monotonía cíclica, puede ser efectivamente utilizada para diseñar mecanismos veraces. Incluimos una breve exposición sobre ello para completitud. La exposición aquí se basa en gran medida en [11]. La monotonía cíclica se describe mejor en el marco abstracto de elección social: hay un conjunto finito A de alternativas, hay m jugadores, y cada jugador tiene un tipo privado (función de valoración) v: A → R, donde vi(a) debe interpretarse como su valor para la alternativa a. En el ámbito de la programación, A representa todas las posibles asignaciones de trabajos a máquinas, y vi(a) es el negativo de su carga en el horario a. Que Vi denote el conjunto de todos los posibles tipos de jugador i. Un mecanismo es una tupla (f, {Pi}) donde f : V1 × · · · × Vm → A es el algoritmo para elegir la alternativa, y Pi : V1 × · · · × Vm → A es el precio cobrado al jugador i (en el contexto de programación, el mecanismo paga a los jugadores, lo que corresponde a precios negativos). El mecanismo es veraz si para cada i, cada v−i ∈ V−i = Q i =i Vi, y cualquier vi, vi ∈ Vi, tenemos que vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), donde a = f(vi, v−i) y b = f(vi, v−i). Una pregunta básica que surge es si dado un algoritmo f: V1 × · · · × Vm → A, ¿existen precios que harán que el mecanismo resultante sea veraz? Es bien sabido (ver por ejemplo [15]) que el precio Pi solo puede depender de la alternativa elegida y las otras declaraciones, es decir, podemos escribir Pi : V−i × A → R. Por lo tanto, la veracidad implica que para cada i, cada v−i ∈ V−i, y cualquier vi, vi ∈ Vi con f(vi, v−i) = a y f(vi, v−i) = b, tenemos vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i). Ahora fija un jugador i, y fija las declaraciones v−i de los demás. Buscamos una asignación a las variables {Pa}a∈A tal que vi(a) − vi(b) ≥ Pa − Pb para todo a, b ∈ A y vi ∈ Vi con f(vi, v−i) = a. (Estrictamente hablando, deberíamos usar A = f(Vi, v−i) en lugar de A aquí). Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. \n\nDefina δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {Pa}a∈A tal que Pa − Pb ≤ δa,b ∀a, b ∈ A (2). Esto se resuelve fácilmente al observar el grafo de asignación y aplicar un resultado básico estándar de teoría de grafos. Definición 3.1 (Gui et al. [11]): El grafo de asignación de f es un grafo dirigido ponderado G = (A, E) donde E = A × A y el peso de una arista b → a (para cualquier a, b ∈ A) es δa,b. Teorema 3.2 Existe una asignación factible para (2) si y solo si el grafo de asignación no tiene ciclos de longitud negativa. Además, si todos los ciclos son no negativos, una asignación factible es 255 obtenida de la siguiente manera: fije un nodo arbitrario a∗ ∈ A y establezca Pa como la longitud del camino más corto desde a∗ hasta a. Esto lleva a la siguiente definición, que es otra forma de expresar la condición de que el grafo de asignación no tenga ciclos negativos. Definición 3.3 (Monotonía de ciclo) Una función de elección social f satisface la monotonía de ciclo si para cada jugador i, cada v−i ∈ V−i, cada entero K, y cada v1 i , . . . , vK i ∈ Vi, Σ k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 donde ak = f(vk i , v−i) para 1 ≤ k ≤ K, y aK+1 = a1. Corolario 3.4 Existen precios P tales que el mecanismo (f, P) es veraz si y solo si f satisface la monotonicidad del ciclo. Ahora consideramos nuestro dominio específico de programación. Fija un jugador i, p−i, y cualquier p1 i, . . . , pK i. Sea x(pk i , p−i) = xk para 1 ≤ k ≤ K, y sea xK+1 = x1 , pK+1 = p1 . xk podría ser una asignación {0, 1} o una asignación fraccional. Tenemos vk i (xk ) = − P j xk ijpk ij, por lo que la monotonía del ciclo se traduce en PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0. Reorganizando, obtenemos KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Por lo tanto, (3) reduce nuestro problema de diseño de mecanismos a un problema algorítmico concreto. Para la mayor parte de este documento, ignoraremos consecuentemente cualquier consideración estratégica y nos enfocaremos en diseñar un algoritmo de aproximación para minimizar el makespan que cumpla con (3). 4. Una TÉCNICA GENERAL PARA OBTENER MECANISMOS ALEATORIOS En esta sección, consideramos el caso de valores Lj, Hj dependientes del trabajo (con Lj ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde Hj = ∞). Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se proporciona como una caja negra. Nuestra construcción y demostración son simples, y se basan en dos ideas. Primero, como se ha mencionado anteriormente, demostramos la veracidad utilizando la monotonía de ciclo. Parece poco probable que para un algoritmo de aproximación arbitrario dado solo como una caja negra, se pueda encontrar pagos para demostrar la veracidad; pero la ciclo-monotonía nos permite demostrar precisamente esto. Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un dominio fraccional y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros. Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el uso de mecanismos fraccionarios para obtener mecanismos veraces en expectativa. No está claro si el Teorema 3.2, y por lo tanto, esta afirmación, se cumple si A no es finito. Debemos señalar, sin embargo, que no se puede simplemente ingresar los resultados de [16]. Sus resultados son válidos para problemas de maximización del bienestar social y se basan en el uso de VCG para obtener un mecanismo fraccional veraz. Sin embargo, VCG no se aplica a la minimización del makespan, y en nuestro caso ni siquiera se conoce la existencia de un mecanismo fraccional veraz cercano a óptimo. Utilizamos el siguiente resultado adaptado de [16]. Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, P) un mecanismo fraccional veraz. Sea A un algoritmo de redondeo aleatorio que, dado un asignación fraccional x, produce una asignación aleatoria X tal que E ˆ Xij ˜ = xij para todo i, j. Entonces existen pagos P tales que el mecanismo M = (A, P) es veraz en promedio. Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de lanzamientos de moneda. Sea OPT(p) el makespan óptimo (sobre horarios enteros) para la instancia p. Como primer paso, tomamos un algoritmo de aproximación c y lo convertimos en un mecanismo fraccional de verdad de aproximación 2c. Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (satisfaciendo ciertas propiedades) de makespan a lo sumo c · OPT(p) para cada instancia p. Demostramos la veracidad mostrando que el algoritmo fraccional satisface la monotonía de ciclo (3). Observa que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinito): su cardinalidad es a lo sumo la del dominio de entrada, que es a lo sumo 2mn en el caso de dos valores. Por lo tanto, podemos aplicar el Corolario 3.4 aquí. Para convertir este mecanismo fraccional veraz en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que cumpla con los requisitos del Lema 4.1. Afortunadamente, dicho procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14]. Lema 4.2 (Kumar et al. [14]): Dada una asignación fraccional x y un vector de tiempos de procesamiento p, existe un procedimiento de redondeo aleatorio que produce una asignación X (aleatoria) tal que, 1. para cualquier i, j, E ˆ Xij ˜ = xij. 2. para cualquier i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij con probabilidad 1. La propiedad 1 se utilizará para obtener veracidad en la expectativa, y la propiedad 2 nos permitirá demostrar una garantía de aproximación. Primero demostramos que cualquier algoritmo que devuelva una asignación fraccional con ciertas propiedades satisface la monotonía de ciclo. Lema 4.3 Sea A un algoritmo que, para cualquier entrada p, produce una asignación (fraccional) x tal que, si pij = Hj entonces xij ≤ 1/m, y si pij = Lj entonces xij ≥ 1/m. Entonces A satisface la ciclo-monotonía. Prueba. Fija un jugador i y el vector de tiempos de procesamiento de los otros jugadores p−i. Necesitamos demostrar (3), es decir, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 para cada p1 i , . . . , pK i , donde el índice k = K + 1 se toma como k = 1. Demostraremos que para cada trabajo j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Si pk ij es el mismo para todos los k (ya sea siempre Lj o siempre Hj), entonces la desigualdad anterior claramente se cumple. De lo contrario, podemos dividir los índices 1, . . . , K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos k , k + 1, . . . , k − 1, k (donde K + 1 ≡ 1) tal que pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj. Esto se cumple porque debe haber algún k tal que pk ij = Hj > pk−1 ij = Lj. Tomamos k = k y luego seguimos incluyendo índices en este segmento hasta que alcancemos un k tal que pk ij = Lj y pk+1 ij = Hj. Establecemos k = k, y luego comenzamos un nuevo segmento maximal con índice k + 1. Ten en cuenta que k = k y k + 1 = k − 1. Ahora tenemos un subconjunto de índices y podemos continuar de forma recursiva. Entonces, todos los índices están incluidos en algún segmento maximal. Mostraremos que para cada segmento maximal k, k +1, . . . , k, P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Agregar esto para cada segmento produce la desigualdad deseada. Así que ahora concéntrate en un segmento maximal k, k + 1, . . . , k − 1, k. Por lo tanto, existe un k∗ tal que para k ≤ k < k∗ , tenemos pk ij = Hj, y para k∗ ≤ k ≤ k , tenemos pk ij = Lj. Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk∗ ij dado que pk ij = Hj y pk∗ ij = Lj. Ahora describimos cómo usar un algoritmo de c-aproximación para obtener un algoritmo que cumpla con la propiedad en el Lema 4.3. Para simplificar, primero supongamos que el algoritmo de aproximación devuelve un horario integral. La idea es simplemente difundir este horario. Tomamos cada trabajo j asignado a una máquina de alta y lo asignamos en una extensión de 1/m en todas las máquinas; para cada trabajo j asignado a una máquina de baja, digamos i, asignamos una fracción de 1/m a las otras máquinas donde es baja, y asignamos la fracción restante (que es al menos 1/m) a i. La asignación resultante satisface claramente las propiedades deseadas. También observe que la carga en cualquier máquina ha aumentado como máximo en 1 m · (carga en otras máquinas) ≤ makespan, y por lo tanto el makespan se ha duplicado como máximo. Esta distribución también se puede hacer si el horario inicial es fraccionado. Ahora describimos el algoritmo con precisión. Algoritmo 1 Sea A cualquier algoritmo que, para cualquier entrada p, genere una asignación posiblemente fraccional x tal que xij > 0 implica que pij ≤ T, donde T es el makespan de x. (En particular, cabe destacar que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades). Nuestro algoritmo, al que llamamos A, devuelve la siguiente asignación xF. Inicializar xF ij = 0 para todos los i, j. Para cada i, j, 1. si pij = Hj, establezca xF ij = P i :pi j =Hj xi j/m; 2. si pij = Lj, establezca xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m. Teorema 4.4 Supongamos que el algoritmo A cumple las condiciones del Algoritmo 1 y devuelve un makespan de a lo sumo c·OPT(p) para cada p. Entonces, el algoritmo A construido anteriormente es una aproximación 2c, algoritmo fraccional cíclico-monótono. Además, si xF ij > 0 en la entrada p, entonces pij ≤ c · OPT(p). Prueba. Primero, nota que xF es una asignación válida: para cada trabajo j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1. También tenemos que si pij = Hj, entonces xFij = Pi: pij = Hj xij/m ≤ 1/m. Si pij = Lj, entonces xF ij = xij(1 − /m) + P i =i xi j/m donde = |{i = i : pi j = Lj}| ≤ m − 1; por lo tanto, xF ij ≥ P i xi j/m ≥ 1/m. Por lo tanto, según el Lema 4.3, A satisface la monotonía de ciclo. La carga total en cualquier máquina i bajo xF es a lo sumo P j: pij = Hj P i: pij = Hj Hj · xi j m + P j: pij = Lj Lj ` xij + P i = i xi j m ´, que es a lo sumo P j pijxij + P i = i P j pijxi j/m ≤ 2c · OPT(p). Finalmente, si xF ij > 0 y pij = Lj, entonces pij ≤ OPT(p). Si pij = Hj, entonces para algún i (posiblemente i) con pij = Hj, tenemos xi j > 0, por lo tanto, por suposición, pij = Hj = pij ≤ c · OPT(p). El Teorema 4.4 combinado con los Lemas 4.1 y 4.2, proporciona un mecanismo de aproximación 3c, veraz en expectativa. La computación de los pagos dependerá del algoritmo de aproximación actual utilizado. La Sección 3, sin embargo, proporciona un procedimiento explícito para calcular los pagos garantizando la veracidad, aunque quizás no en tiempo polinómico. Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Tomando A en el Algoritmo 1 como el algoritmo que devuelve una asignación óptima de LP que cumple las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de aproximación 3. Corolario 4.6 Existe un mecanismo veraz-en-expectativa con una proporción de aproximación de 3 para el escenario Lj-Hj. 5. Un MECANISMO DETERMINISTA PARA EL CASO DE DOS VALORES Presentamos ahora un mecanismo determinista de aproximación 2-veraz para el caso donde pij ∈ {L, H} para todo i, j. En la secuela, a menudo diremos que j está asignado a una máquina de baja carga para indicar que j está asignado a una máquina i donde pij = L. Llamaremos a un trabajo j un trabajo de baja carga de la máquina i si pij = L; la carga baja de i es la carga en i debido a sus trabajos de baja carga, es decir, P j:pij = L xijpij. Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que cumpla con la monotonía de ciclo. Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar. Describimos nuestro algoritmo en la Sección 5.1. En la Sección 5.2, acotamos su garantía de aproximación y demostramos que cumple con la ciclo-monotonía. En la Sección 5.3, calculamos los pagos explícitos proporcionando un mecanismo veraz. Finalmente, en la Sección 5.4 demostramos que ningún mecanismo determinista puede lograr el makespan óptimo. Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).\n\nDefina nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Entonces, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L). Sustituyendo esto en (3) y dividiendo por (H − L), obtenemos lo siguiente. Proposición 5.1 La monotonía cíclica en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador i, cada p−i, cada entero K, y cada p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación cíclicamente monótono A continuación describimos un algoritmo que satisface la condición (6) y logra una aproximación de 2. Supondremos que L, H son enteros, lo cual no limita la generalidad. Un componente fundamental de nuestro algoritmo será un procedimiento que tome un umbral de carga entero T y calcule una asignación parcial entera x de trabajos a máquinas de manera que (a) un trabajo solo se asigna a una máquina de baja carga; (b) la carga en cualquier máquina sea como máximo T; y (c) se maximice el número de trabajos asignados. Tal asignación se puede calcular resolviendo un problema de flujo máximo: construimos un grafo bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y una arista (j, i) de capacidad infinita si pij = L. También agregamos un nodo fuente s con aristas (s, j) de capacidad 1, y un nodo sumidero t con aristas (i, t) de capacidad T/L. Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de makespan de a lo sumo T, donde xij = 1 si y solo si hay un flujo de 1 en la arista de j a i. Por lo tanto, utilizaremos los términos asignación y flujo indistintamente. Además, siempre hay un flujo máximo integral (ya que todas las capacidades son números enteros). A menudo nos referiremos a dicho flujo máximo como el flujo máximo para (p, T). Necesitamos un concepto adicional antes de describir el algoritmo. Podría haber potencialmente muchos flujos máximos y estaremos interesados en los más equilibrados, los cuales definimos formalmente de la siguiente manera. Arregla algún flujo máximo. Deje que ni p,T sea la cantidad de flujo en el borde (i, t) (o equivalentemente el número de trabajos asignados a i en el horario correspondiente), y deje que np,T sea el tamaño total del flujo máximo, es decir, np,T = Σ i ni p,T. Para cualquier T ≤ T, definimos ni p,T |T = min(ni p,T , T ), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo T. Define np,T |T = P i ni p,T |T . \n\nDefina np,T |T = P i ni p,T |T. Definimos un flujo o asignación de prefijo-maximal para T de la siguiente manera. Definición 5.2 (Flujo prefijo-maximal) Un flujo para la red anterior con umbral T es prefijo-maximal si para cada entero T ≤ T, tenemos np,T |T = np,T. Es decir, en un flujo de prefijo máximo para (p, T), si truncamos el flujo en algún T ≤ T, nos queda un flujo máximo para (p, T). Un hecho elemental sobre los flujos es que si una asignación/flujo x no es un flujo máximo para (p, T) entonces debe existir un camino de aumento P = (s, j1, i1, . . . , jK , iK , t) en el grafo residual que nos permita aumentar el tamaño del flujo. La interpretación es que en la asignación actual, j1 no está asignado, xi j = 0, lo cual se denota por las aristas directas (j , i), y xi j +1 = 1, lo cual se denota por las aristas inversas (i, j +1). Aumentar x usando P cambia la asignación de manera que cada j se asigna a i en la nueva asignación, lo que aumenta el valor del flujo en 1. Un camino de aumento simple no disminuye la carga de ninguna máquina; por lo tanto, se puede argumentar que siempre existe un flujo maximal de prefijo para un umbral T. Primero calculamos un flujo máximo para el umbral 1, utilizamos caminos de aumento simples para aumentarlo a un flujo máximo para el umbral 2, y repetimos el proceso, cada vez aumentando el flujo máximo para el umbral anterior t a un flujo máximo para el umbral t + 1 utilizando caminos de aumento simples. Algoritmo 2 Dado un vector de tiempos de procesamiento p, construir una asignación de trabajos a máquinas de la siguiente manera. 1. Calcular T∗ (p) = min ˘ T ≥ H, T múltiplo de L : np,T · L + (n − np,T ) · H ≤ m · T ¯ . Se observa que np,T ·L+(n−np,T )·H −m·T es una función decreciente de T, por lo que T∗ (p) se puede calcular en tiempo polinómico mediante búsqueda binaria. Calcular un flujo prefijo-maximal para el umbral T∗ (p) y la asignación parcial correspondiente (es decir, j se asigna a i si hay 1 unidad de flujo en el borde (j, i)). 3. Asigna los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera. Considera estos trabajos en un orden arbitrario y asigna cada trabajo a la máquina con la carga actual más baja (donde la carga incluye los trabajos asignados en la fase de flujo). Nuestro algoritmo necesita calcular una asignación prefijo-maximal para el umbral T∗ (p). La prueba que muestra la existencia de un flujo maximal de prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo. Pero hay que tener en cuenta que el flujo máximo permanece igual para cualquier T ≥ T = n · L. Por lo tanto, un flujo maximal de prefijo para T también es maximal de prefijo para cualquier T ≥ T. Por lo tanto, solo necesitamos calcular un flujo maximal de prefijo para T = min{T∗ (p), T }. Esto se puede hacer en tiempo polinómico utilizando el algoritmo de caminos aumentantes iterativos en la prueba de existencia para calcular de forma iterativa el flujo máximo para los múltiplos polinomialmente muchos de L hasta (e incluyendo) T. Teorema 5.3 Se pueden calcular eficientemente pagos que, combinados con el Algoritmo 2, producen un mecanismo veraz de aproximación determinística 2 para el dominio de programación de dos valores. 5.2 Análisis Sea OPT(p) la duración óptima para p. Ahora demostramos que el Algoritmo 2 es un algoritmo de aproximación 2 que cumple con la monotonía cíclica. Esto nos permitirá calcular los pagos en la Sección 5.3 y demostrar el Teorema 5.3. 5.2.1 Prueba de la Aproximación Reclamo 5.4 Si OPT(p) < H, el makespan es a lo sumo OPT(p). Prueba. Si OPT(p) < H, debe ser que el horario óptimo asigna todos los trabajos a máquinas de baja velocidad, por lo que np,OPT(p) = n. Por lo tanto, tenemos T∗ (p) = L · H L. Además, dado que calculamos un flujo maximal de prefijo para el umbral T∗(p), tenemos np,T∗(p)|OPT(p) = np,OPT(p) = n, lo que implica que la carga en cada máquina es a lo sumo OPT(p). Por lo tanto, en este caso el makespan es como máximo (y por lo tanto exactamente) OPT(p). Reclamo 5.5 Si OPT(p) ≥ H, entonces T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Prueba. Sea nOPT(p) el número de trabajos asignados a las máquinas de baja en un horario óptimo. La carga total en todas las máquinas es exactamente nOPT(p) · L + (n − nOPT(p)) · H, y como máximo es m · OPT(p), ya que cada máquina tiene una carga de como máximo OPT(p). Entonces, tomando T = L · OPT(p) L ≥ H, dado que np,T ≥ nOPT(p) tenemos que np,T ·L+(n−np,T )·H ≤ m·T. Por lo tanto, T∗ (p), el T más pequeño de este tipo, es a lo sumo L · OPT(p) L. Reclamo 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina de alta calidad. 258 Prueba. Supongamos que j se asigna a la máquina i en el paso 3. Si pij = L, entonces debemos tener ni p,T ∗(p) = T∗ (p), de lo contrario podríamos haber asignado j a i en el paso 2 para obtener un flujo de valor mayor. Por lo tanto, en el punto justo antes de que se asigne j en el paso 3, la carga de cada máquina debe ser al menos T∗ (p). Por lo tanto, la carga total después de que se asigna j es al menos m · T∗ (p) + L > m · T∗ (p). Pero la carga total es como máximo np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), lo que resulta en una contradicción. Lema 5.7 El algoritmo anterior devuelve un horario con un makespan de a lo sumo OPT(p) + max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p). Prueba. Si OPT(p) < H, entonces, según la Afirmación 5.4, hemos terminado. Entonces supongamos que OPT(p) ≥ H. Por la Afirmación 5.5, sabemos que T∗ (p) ≤ OPT(p) + L. Si no hay trabajos sin asignar después del paso 2 del algoritmo, entonces el tiempo de ejecución es a lo sumo T∗ (p) y hemos terminado. Así que supongamos que hay algunos trabajos no asignados después del paso 2. Mostraremos que el makespan después del paso 3 es a lo sumo T +H ` 1− 1 m ´ donde T = min ˘ T∗ (p), OPT(p) ¯ . Supongamos que la afirmación es falsa. Sea i la máquina con la carga máxima, entonces li > T + H ` 1 − 1 m ´ . Deja que j sea el último trabajo asignado a i en el paso 3, y considera el punto justo antes de que se le asigne a i. Entonces li > T − H/m en este punto. También, dado que j está asignado a i, según nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos li. Por lo tanto, la carga total después de que j sea asignado, es al menos H + m · li > m · T (ya que pij = H según la Reclamación 5.6). Además, para cualquier asignación de trabajos a máquinas en el paso 3, la carga total es a lo sumo np,T ∗(p) · L + (n − np,T ∗(p)) · H ya que hay np,T ∗(p) trabajos asignados a máquinas de baja prioridad. Por lo tanto, debemos tener m · T < np,T ∗(p) · L + (n - np,T ∗(p)) · H. Pero argumentaremos que m · T ≥ np,T ∗(p) · L + (n - np,T ∗(p)) · H, lo cual conduce a una contradicción. Si T = T∗ (p), esto se deduce de la definición de T∗ (p). Si T = OPT(p), entonces dejando que nOPT(p) denote el número de trabajos asignados a las máquinas de baja en un horario óptimo, tenemos np,T ∗(p) ≥ nOPT(p). Entonces, np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H. Este es exactamente la carga total en un horario óptimo, que es a lo sumo m · OPT(p). 5.2.2 Prueba de la monotonía del ciclo. Lema 5.8 Considere dos instancias p = (pi, p−i) y p = (pi, p−i) donde pi ≥ pi, es decir, pij ≥ pij ∀j. Si T es un umbral tal que np,T > np,T, entonces todo flujo máximo x para (p, T) debe asignar todos los trabajos j tales que pij = L. Demostración. Que Gp denote el grafo residual para (p, T) y el flujo x. Supongamos por contradicción que existe un trabajo j∗ con pij∗ = L que no está asignado por x. Dado que pi ≥ pi, todos los bordes (j, i) que están presentes en la red para (p, T) también están presentes en la red para (p, T). Por lo tanto, x es un flujo válido para (p, T). Pero no es un flujo máximo, ya que np,T > np,T. Entonces existe un camino de aumento P en el grafo residual para (p, T) y flujo x. Observa que el nodo i debe estar incluido en P, de lo contrario P también sería un camino de aumento en el grafo residual Gp, lo que contradiría el hecho de que x es un flujo máximo. En particular, esto implica que hay un camino P ⊂ P desde i hasta el sumidero t. Sea P = (i, j1, i1, . . . , jK , iK , t). Todos los bordes de P también están presentes como bordes en Gp: todos los bordes inversos (i, j +1) están presentes ya que dicho borde implica que xi j +1 = 1; todos los bordes directos (j, i) están presentes ya que i = i, por lo que pi j = pi j = L, y xi j +1 = 0. Pero luego hay un camino de aumento (j∗ , i, j1, i1, . . . , jK , iK , t) en Gp que contradice la maximalidad de x. Que L denote el vector de tiempo de procesamiento todo bajo. Define TL i (p−i) = T∗ (L, p−i). \n\nDefina TL i (p−i) = T∗ (L, p−i). Dado que nos estamos enfocando en la máquina i, y p−i está fijo en todo momento, abreviamos TL i (p−i) como TL. Además, sea pL = (L, p−i). Ten en cuenta que T∗ (p) ≥ TL para cada instancia p = (pi, p−i). Corolario 5.9 Sea p = (pi, p−i) cualquier instancia y sea x cualquier flujo prefijo-maximal para (p, T∗ (p)). Entonces, la carga baja en la máquina i es como máximo TL. Prueba. Que T∗ = T∗ (p). Si T∗ = TL, entonces esto es claramente cierto. De lo contrario, considera la asignación x truncada en TL. Dado que x es prefijo-maximal, sabemos que esto constituye un flujo máximo para (p, TL). Además, np,T L < npL,T L porque T∗ > TL. Entonces, según el Lema 5.8, este flujo truncado debe asignar todos los trabajos de baja prioridad de i. Por lo tanto, no puede haber un trabajo j con pij = L que se asigne a i después del umbral TL, ya que entonces j no sería asignado por este flujo truncado. Por lo tanto, la carga baja de i es como máximo TL. Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p−i, p1 i ) y p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) donde n2,1 H y n2,1 L están definidos en (4) y (5), respectivamente. Observa que esto implica inmediatamente la monotonía del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L; sumando esto sobre todos los k = 1, . . . , K da como resultado (6). Lema 5.10 Si T∗ (p1) > TL, entonces se cumple la ecuación (7). Prueba. Que T1 = T∗ (p1) y T2 = T∗ (p2). Toma el flujo máximo de prefijo x2 para (p2, T2), trúnquelo en TL y elimine todos los trabajos de esta asignación que se cuentan en n2,1 H, es decir, todos los trabajos j tales que x2 ij = 1, p2 ij = L, p1 ij = H. Denomina este flujo como x. Observe que x es un flujo válido para (p1, TL), y el tamaño de este flujo es exactamente np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H. Además, ninguno de los trabajos que se cuentan en n2,1 L está asignado por x, ya que cada trabajo j de este tipo tiene prioridad sobre i en p2. Dado que T1 > TL, debemos tener np1,TL < npTL,TL. Por lo tanto, si aumentamos x a un flujo máximo para (p1, TL), entonces, por el Lema 5.8 (con p = pL y p = p1), todos los trabajos correspondientes a n2,1 L deben asignarse en este flujo máximo. Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1,T L ≥ np2,T L − n2,1 H + n2,1 L, como se afirma. Lema 5.11 Supongamos que T∗ (p1 ) = TL. Entonces se cumple (7). Prueba. Nuevamente, dejemos que T1 = T∗ (p1) = TL y T2 = T∗ (p2). Que x1, x2 sean la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculada por nuestro algoritmo para p1, p2 respectivamente. Sea S = {j : x2 ij = 1 y p2 ij = L} y S = {j : x2 ij = 1 y p1 ij = L}. Por lo tanto, |S | = |S| − n2,1 H + n2,1 L y |S| = ni p2,T 2 = ni p2,T 2 |T L (por el Corolario 5.9). Sea T = |S| · L. Consideramos dos casos. Supongamos primero que T ≤ TL. Considera el siguiente flujo para (p1, TL): asigna a cada máquina que no sea i la asignación baja de x2 truncada en TL, y asigna los trabajos en S a la máquina i. Este es un flujo válido para (p1, TL) ya que la carga en i es T ≤ TL. Su tamaño es igual a P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L. El tamaño del flujo máximo para (p1, TL) no es menor, y se sigue la afirmación. Ahora supongamos que T > TL. Dado que |S| · L ≤ TL (por el Corolario 5.9), se sigue que n2,1 L > n2,1 H ≥ 0. Sea ˆT = T − L ≥ TL ya que T, TL son ambos múltiplos de L. Sea M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2. Primero demostramos que m · ˆT < M · L + (n − M) · H. (8) Sea N el número de trabajos asignados a la máquina i en x2. La carga en la máquina i es |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H, lo cual es al menos |S |·L > ˆT ya que n2,1 L ≤ N− |S|. Así obtenemos la desigualdad |S|·L+(N−|S|)·H > ˆT. Ahora considera el punto en la ejecución del algoritmo en la instancia p2 justo antes de que el último trabajo de alta prioridad sea asignado a i en el Paso 3 (debe haber tal trabajo ya que n2,1 L > 0). La carga en i en este punto es |S| · L + (N − |S| − 1) · H, que es al menos |S| · L − L = ˆT por un argumento similar al anterior. Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆT. Sumando estas desigualdades para todos los i = i, y la desigualdad anterior para i, obtenemos que |S| · L + (N − |S|) · H + Σ i = i Σ j p2 i jx2 i j > m ˆT. Pero el lado izquierdo es exactamente M · L + (n − M) · H. Por otro lado, dado que T1 = TL, tenemos m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L) · H. (9) Combinando (8) y (9), obtenemos que np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L. El Lema 5.12 del Algoritmo 2 satisface la monotonía del ciclo. Prueba. Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L. Sumando esto sobre todos los k = 1, . . . , K (donde K + 1 ≡ 1) se obtiene (6). 5.3 Cálculo de precios Los lemas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de aproximación 2 que satisface la monotonía de ciclo. Por lo tanto, según la discusión en la Sección 3, existen precios que generan un mecanismo veraz. Para obtener un mecanismo de tiempo polinómico, también necesitamos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico. No está claro si el procedimiento descrito en la Sección 3, basado en calcular los caminos más cortos en el grafo de asignación, produce un algoritmo de tiempo polinómico, ya que el grafo de asignación tiene un número exponencial de nodos (uno por cada asignación de salida). En lugar de analizar el grafo de asignación, aprovecharemos nuestra prueba de monotonía del ciclo, en particular, la desigualdad (7), y simplemente detallaremos los pagos. Recuerda que la utilidad de un jugador es ui = Pi − li, donde Pi es el pago realizado al jugador i. Para mayor comodidad, primero especificaremos los pagos negativos (es decir, los PIs serán los precios cobrados a los jugadores) y luego mostraremos que estos pueden ser modificados para que los jugadores tengan utilidades no negativas (si actúan de manera veraz). Que Hi denote el número de trabajos asignados a la máquina i en el paso 3. Por el Corolario 5.6, sabemos que todos estos trabajos están asignados a máquinas de alta calidad (según los pis declarados). Deja que H−i = P i =i Hi y n−i p,T = P i =i ni p,T. El pago Pi al jugador i se define como: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10). Podemos interpretar nuestros pagos como igualar el costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios VCG). Los primeros y segundos términos en (10), al restarse de la carga li, igualan el costo al total de la carga. El término np,T ∗(p) − np,T L i (p−i) es de hecho igual a n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) ya que la carga baja en i es a lo sumo TL i (p−i) (según la Reclamación 5.9). Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos de baja prioridad que fueron asignados más allá del umbral TL i (p−i) (a máquinas distintas de i) efectivamente como trabajos de alta prioridad para el cálculo total de utilidad desde su punto de vista. No está claro cómo se podrían haber ideado estos pagos de antemano para demostrar la veracidad de nuestro algoritmo. Sin embargo, al depender de la monotonía del ciclo, no solo pudimos argumentar la existencia de pagos, sino que nuestra prueba allanó el camino para inferir realmente estos pagos. El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan lugar a un mecanismo veraz. Lema 5.13 Fija un jugador i y las declaraciones de los otros jugadores p−i. Deje que su tipo verdadero sea p1 i. Entonces, bajo los pagos definidos en (10), la utilidad cuando declara su verdadero tipo p1 i es al menos su utilidad cuando declara cualquier otro tipo p2 i. Prueba. Que c1 i, c2 i denoten su costo total, definido como el negativo de su utilidad, cuando ella declara p1 y p2, respectivamente (y los demás declaran p−i). Dado que p−i está fijo, omitimos p−i de las expresiones a continuación para mayor claridad notacional. La verdadera carga de i cuando declara su verdadero tipo p1 i es L · ni p1,T ∗(p1) + H · Hi (p1), y por lo tanto c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) Por otro lado, la verdadera carga cuando declara p2 i es L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L) + H · (Hi + n2,1 H − n2,1 L) (ya que el vector de tiempo de procesamiento verdadero es p1 i), y así c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L. Por lo tanto, (7) implica que c1 i ≤ c2 i. Las especificaciones de precios suelen requerirse para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de un jugador debe ser no negativa si revela su valor real. Los pagos dados por (10) no son individualmente racionales ya que en realidad le cobran a un jugador una cierta cantidad. Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficientemente grande a la definición del precio. En nuestro caso, por ejemplo, dejando que H denote el vector de todas las H, podemos añadir el término n·H −(H −L)n(H,p−i),T L i (p−i) a (10). Ten en cuenta que esto es una constante para el jugador i. Por lo tanto, los nuevos pagos son Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ . Como se muestra en (11), esto resultará en una utilidad no negativa para i (ya que n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) para cualquier tipo pi del jugador i). Esta modificación también garantiza la propiedad de normalización adicional deseada de que si un jugador no recibe trabajos, entonces recibe un pago de cero: si el jugador i recibe el conjunto vacío para algún tipo pi, entonces también recibirá el conjunto vacío para el tipo H (esto es fácil de verificar para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero; por lo tanto, por veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que i reciba el conjunto vacío. Esto completa la demostración del Teorema 5.3. 260 5.4 Imposibilidad de implementación exacta. Ahora mostramos que, independientemente de consideraciones computacionales, no existe un algoritmo cíclico-monótono para el caso L-H con una proporción de aproximación mejor que 1.14. Sea H = α·L para algún 2 < α < 2.5 que elegiremos más tarde. Hay dos máquinas I, II y siete trabajos. Considera los siguientes dos escenarios: Escenario 1. Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5 son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna los trabajos 1-5 a una máquina y los trabajos 6, 7 a la otra, y tiene un makespan OPT1 = 5L. El segundo mejor horario tiene un tiempo de ejecución de al menos Second1 = 2H + L. Escenario 2. Si el algoritmo elige un horario óptimo para el escenario 1, asuma sin pérdida de generalidad que los trabajos 6 y 7 están asignados a la máquina II. En el escenario 2, la máquina I tiene el mismo vector de tiempos de procesamiento. La Máquina II reduce los trabajos 6 y 7 a L y aumenta los trabajos 1-5 a H. Un horario óptimo tiene un tiempo de ejecución de 2L + H, donde la Máquina II realiza los trabajos 6, 7 y uno de los trabajos 1-5. La segunda mejor programación para este escenario tiene un makespan de al menos Second2 = 5L. Teorema 5.14 Ningún mecanismo determinístico y veraz para el problema de programación de dos valores puede obtener una proporción de aproximación mejor que 1.14. Prueba. Primero argumentamos que un algoritmo cíclico-monótono no puede elegir el horario óptimo en ambos escenarios. Esto se debe a que de lo contrario se viola la monotonía del ciclo para la máquina II. Tomando p1 II , p2 II como vectores de tiempos de procesamiento de la máquina II para los escenarios 1, 2 respectivamente, obtenemos P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0. Por lo tanto, cualquier mecanismo veraz debe devolver un makespan subóptimo en al menos un escenario, y por lo tanto su ratio de aproximación es al menos min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 para α = 2.364. Observamos que para el caso {Lj, Hj} donde hay una razón común r = Hj Lj para todos los trabajos (esto generaliza el escenario de máquinas restringidas) se puede obtener un mecanismo fraccional veraz (con precios computables eficientemente) que devuelve un horario de makespan de a lo sumo OPT(p) para cada p. Se puede ver cada trabajo j como consistente de Lj subtrabajos de tamaño 1 en una máquina i si pij = Lj, y de tamaño r si pij = Hj. Para esta nueva instancia ˜p, nota que ˜pij ∈ {1, r} para cada i, j. También hay que tener en cuenta que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxij =P j : subtrabajo de j ˜pij ˜xij. Por lo tanto, si utilizamos el Algoritmo 2 para obtener un horario para la instancia ˜p, la ecuación (6) se traduce precisamente a (3) para la asignación x; además, los precios para ˜p se traducen en precios para la instancia p. El número de subtrabajos asignados a máquinas de baja en la fase de flujo es simplemente el trabajo total asignado a las máquinas de baja. Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a las máquinas de baja capacidad. Además, dado que tenemos un dominio fraccional, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p). La asignación x no necesita cumplir la condición de que xij > 0 implica pij ≤ OPT(p) para cualquier r, por lo tanto, el procedimiento de redondeo del Lema 4.2 no produce un mecanismo de aproximación 2-veraz en expectativa. Pero si r > OPT(p) (como en el escenario de máquinas restringidas), esta condición sí se cumple, por lo que obtenemos un mecanismo veraz de aproximación 2. Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda en refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus comentarios útiles. 6. REFERENCIAS [1] N. Andelman, Y. Azar y M. Sorani. Mecanismos de aproximación veraces para la programación de máquinas relacionadas egoístas. En Proc. 22º STACS, 69-82, 2005. [2] A. Archer. Mecanismos para la optimización discreta con agentes racionales. Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´E. This word does not have a meaning in English. Could you please provide more context or clarify the sentence? Mecanismos veraces para agentes de un parámetro. En Proc. 42º FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano. Mecanismos de aproximación veraces determinísticos para máquinas relacionadas con la programación. En Proc. 21º STACS, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani. Asignación de bienes indivisibles. En ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La debilidad de la monotonicidad caracteriza la implementación de estrategias dominantes determinísticas. Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking. Técnicas de aproximación para el diseño de mecanismos utilitarios. En Proc. 37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali. Un límite inferior para los mecanismos de programación. En Proc. 18th SODA, páginas 1163-1170, 2007. [9] E. Clarke. Precios escalonados de bienes públicos. Elección Pública, 8:17-33, 1971. [10] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, y R. V. Vohra. Caracterizando mecanismos de estrategia dominante con tipos multidimensionales, 2004. Documento de trabajo. [12] L. A. Sala. Algoritmos de aproximación para la programación de tareas. En D. Hochbaum, editor, Algoritmos de Aproximación para Problemas NP-Difíciles. PWS Publishing, MA, 1996. [13] A. Kovács. Algoritmo de aproximación rápida y monótona 3 para la programación de máquinas relacionadas. En Proc. 13th ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan. Algoritmos de aproximación para la programación en múltiples máquinas. En Proc. 46th FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan. Hacia una caracterización de subastas combinatorias veraces. En Proc. 44th FOCS, páginas 574-583, 2003. [16] R. Lavi y C. Swamy. Diseño de mecanismos veraz y casi óptimos a través de programación lineal. En Proc. 46th FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. OCallaghan y Y. Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Revista de la ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, y ´E. This word does not have a meaning in English. Could you please provide more context or another sentence for translation? Algoritmos de aproximación para la programación de máquinas paralelas no relacionadas. Matemáticas. Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. \n\nProg., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, y A. Saberi. Sobre asignaciones aproximadamente justas de bienes indivisibles. En Proc. 5to EC, páginas 125-131, 2004. [20] A. Mualem y M. Schapira. Estableciendo límites inferiores en la veracidad. En Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [22] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Economía. Comportamiento, 35:166-196, 2001. [23] J. C. Rochet. Una condición necesaria y suficiente para la racionalización en un contexto cuasilineal. Revista de Economía Matemática, 16:191-200, 1987. [24] M. Saks y L. Yu. La monotonía débil es suficiente para la veracidad en dominios convexos. En Proc. 6to EC, páginas 286-293, 2005. [25] D. B. Shmoys y ´E. This word does not have a specific meaning in English. Could you please provide more context or another sentence for translation? Un algoritmo de aproximación para el problema de asignación generalizada. Programación Matemática, 62:461-474, 1993. [26] W. Vickrey. Contraespeculaciones, subastas y licitaciones selladas competitivas. I'm sorry, but the sentence \"J.\" does not have a clear meaning or context for translation. Could you please provide more information or a complete sentence for me to translate into Spanish? Finanzas, 16:8-37, 1961. 261 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "fractional mechanism usefulness": {
            "translated_key": "utilidad del mecanismo fraccional",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "truthful mechanism design": {
            "translated_key": "Diseño de mecanismos veraces",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>truthful mechanism design</br> for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in <br>truthful mechanism design</br>.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of <br>truthful mechanism design</br> for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of <br>truthful mechanism design</br> for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for <br>truthful mechanism design</br> in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in <br>truthful mechanism design</br>.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in <br>truthful mechanism design</br> for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "<br>truthful mechanism design</br> for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in <br>truthful mechanism design</br>.",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of <br>truthful mechanism design</br> for multidimensional domains.",
                "Thus, they retain the core property underlying the hardness of <br>truthful mechanism design</br> for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our work is the first to leverage monotonicity conditions for <br>truthful mechanism design</br> in arbitrary domains."
            ],
            "translated_annotated_samples": [
                "<br>Diseño de mecanismos veraces</br> para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos.",
                "Esto se basa en una técnica de [16], y muestra la utilidad de los <br>mecanismos fraccionarios</br> en el diseño de mecanismos veraces.",
                "Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del <br>diseño de mecanismos veraces</br> para dominios multidimensionales.",
                "Por lo tanto, conservan la propiedad central que subyace a la dificultad del <br>diseño de mecanismos veraces</br> para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general.",
                "Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el <br>diseño de mecanismos veraces</br> en dominios arbitrarios."
            ],
            "translated_text": "<br>Diseño de mecanismos veraces</br> para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los <br>mecanismos fraccionarios</br> en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del <br>diseño de mecanismos veraces</br> para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del <br>diseño de mecanismos veraces</br> para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el <br>diseño de mecanismos veraces</br> en dominios arbitrarios. ",
            "candidates": [],
            "error": [
                [
                    "Diseño de mecanismos veraces",
                    "mecanismos fraccionarios",
                    "diseño de mecanismos veraces",
                    "diseño de mecanismos veraces",
                    "diseño de mecanismos veraces"
                ]
            ]
        },
        "fractional domain": {
            "translated_key": "dominio fraccional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule.",
                "Moving to a <br>fractional domain</br> allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms schedule and assignment interchangeably.",
                "We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a schedule that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the schedule a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a <br>fractional domain</br>, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral schedule.",
                "The idea is to simply spread this schedule.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial schedule is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding schedule), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum schedule, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal schedule assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest schedule has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal schedule for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal schedule has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best schedule for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal schedule in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a schedule of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a schedule for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a <br>fractional domain</br>, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Moving to a <br>fractional domain</br> allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "Second, we obtain our randomized mechanism by (a) first moving to a <br>fractional domain</br>, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules.",
                "Moreover, since we have a <br>fractional domain</br>, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p)."
            ],
            "translated_annotated_samples": [
                "Moverse a un <br>dominio fraccional</br> nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación.",
                "Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un <br>dominio fraccional</br> y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros.",
                "Además, dado que tenemos un <br>dominio fraccional</br>, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p)."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un <br>dominio fraccional</br> nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas. Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación. Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces. Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas. Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz. Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorio de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13]. El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro mecanismo aleatorio. La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13]. Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales. Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos. En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia. Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas. Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz. Estos límites inferiores fueron fortalecidos en [20]. PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina. En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos. Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2. El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj. Usaremos los términos horario y tarea indistintamente. Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j. También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional. En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li. El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos. El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados. Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j. El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias. Para un mecanismo aleatorio, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en expectativa para un mecanismo aleatorio, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)). Para nuestros dos dominios de programación, la suposición informativa es que los valores Lj, Hj son de conocimiento público. La información privada de una máquina es qué trabajos tienen valor Lj (o L) y cuáles tienen valor Hj (o H) en ella. Enfatizamos que ambos de nuestros dominios son multidimensionales, ya que cada máquina i necesita especificar un vector que indique qué trabajos son bajos y altos en ella. Aunque la veracidad se define en términos de pagos, resulta que en realidad la veracidad se reduce a una cierta condición algorítmica de monotonicidad. Esto parece haber sido observado por primera vez para dominios multidimensionales por Rochet [23] en 1987, y ha sido utilizado con éxito en el diseño algorítmico de mecanismos varias veces, pero para dominios unidimensionales. Sin embargo, para dominios multidimensionales, la condición de monotonía es más compleja y no ha habido éxito en emplearla en el diseño de mecanismos veraces. La mayoría de los resultados positivos para dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad. Una de las principales contribuciones de este artículo es demostrar que la condición de monotonía para entornos multidimensionales, a veces llamada monotonía cíclica, puede ser efectivamente utilizada para diseñar mecanismos veraces. Incluimos una breve exposición sobre ello para completitud. La exposición aquí se basa en gran medida en [11]. La monotonía cíclica se describe mejor en el marco abstracto de elección social: hay un conjunto finito A de alternativas, hay m jugadores, y cada jugador tiene un tipo privado (función de valoración) v: A → R, donde vi(a) debe interpretarse como su valor para la alternativa a. En el ámbito de la programación, A representa todas las posibles asignaciones de trabajos a máquinas, y vi(a) es el negativo de su carga en el horario a. Que Vi denote el conjunto de todos los posibles tipos de jugador i. Un mecanismo es una tupla (f, {Pi}) donde f : V1 × · · · × Vm → A es el algoritmo para elegir la alternativa, y Pi : V1 × · · · × Vm → A es el precio cobrado al jugador i (en el contexto de programación, el mecanismo paga a los jugadores, lo que corresponde a precios negativos). El mecanismo es veraz si para cada i, cada v−i ∈ V−i = Q i =i Vi, y cualquier vi, vi ∈ Vi, tenemos que vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), donde a = f(vi, v−i) y b = f(vi, v−i). Una pregunta básica que surge es si dado un algoritmo f: V1 × · · · × Vm → A, ¿existen precios que harán que el mecanismo resultante sea veraz? Es bien sabido (ver por ejemplo [15]) que el precio Pi solo puede depender de la alternativa elegida y las otras declaraciones, es decir, podemos escribir Pi : V−i × A → R. Por lo tanto, la veracidad implica que para cada i, cada v−i ∈ V−i, y cualquier vi, vi ∈ Vi con f(vi, v−i) = a y f(vi, v−i) = b, tenemos vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i). Ahora fija un jugador i, y fija las declaraciones v−i de los demás. Buscamos una asignación a las variables {Pa}a∈A tal que vi(a) − vi(b) ≥ Pa − Pb para todo a, b ∈ A y vi ∈ Vi con f(vi, v−i) = a. (Estrictamente hablando, deberíamos usar A = f(Vi, v−i) en lugar de A aquí). Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. \n\nDefina δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {Pa}a∈A tal que Pa − Pb ≤ δa,b ∀a, b ∈ A (2). Esto se resuelve fácilmente al observar el grafo de asignación y aplicar un resultado básico estándar de teoría de grafos. Definición 3.1 (Gui et al. [11]): El grafo de asignación de f es un grafo dirigido ponderado G = (A, E) donde E = A × A y el peso de una arista b → a (para cualquier a, b ∈ A) es δa,b. Teorema 3.2 Existe una asignación factible para (2) si y solo si el grafo de asignación no tiene ciclos de longitud negativa. Además, si todos los ciclos son no negativos, una asignación factible es 255 obtenida de la siguiente manera: fije un nodo arbitrario a∗ ∈ A y establezca Pa como la longitud del camino más corto desde a∗ hasta a. Esto lleva a la siguiente definición, que es otra forma de expresar la condición de que el grafo de asignación no tenga ciclos negativos. Definición 3.3 (Monotonía de ciclo) Una función de elección social f satisface la monotonía de ciclo si para cada jugador i, cada v−i ∈ V−i, cada entero K, y cada v1 i , . . . , vK i ∈ Vi, Σ k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 donde ak = f(vk i , v−i) para 1 ≤ k ≤ K, y aK+1 = a1. Corolario 3.4 Existen precios P tales que el mecanismo (f, P) es veraz si y solo si f satisface la monotonicidad del ciclo. Ahora consideramos nuestro dominio específico de programación. Fija un jugador i, p−i, y cualquier p1 i, . . . , pK i. Sea x(pk i , p−i) = xk para 1 ≤ k ≤ K, y sea xK+1 = x1 , pK+1 = p1 . xk podría ser una asignación {0, 1} o una asignación fraccional. Tenemos vk i (xk ) = − P j xk ijpk ij, por lo que la monotonía del ciclo se traduce en PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0. Reorganizando, obtenemos KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Por lo tanto, (3) reduce nuestro problema de diseño de mecanismos a un problema algorítmico concreto. Para la mayor parte de este documento, ignoraremos consecuentemente cualquier consideración estratégica y nos enfocaremos en diseñar un algoritmo de aproximación para minimizar el makespan que cumpla con (3). 4. Una TÉCNICA GENERAL PARA OBTENER MECANISMOS ALEATORIOS En esta sección, consideramos el caso de valores Lj, Hj dependientes del trabajo (con Lj ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde Hj = ∞). Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se proporciona como una caja negra. Nuestra construcción y demostración son simples, y se basan en dos ideas. Primero, como se ha mencionado anteriormente, demostramos la veracidad utilizando la monotonía de ciclo. Parece poco probable que para un algoritmo de aproximación arbitrario dado solo como una caja negra, se pueda encontrar pagos para demostrar la veracidad; pero la ciclo-monotonía nos permite demostrar precisamente esto. Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un <br>dominio fraccional</br> y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros. Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el uso de mecanismos fraccionarios para obtener mecanismos veraces en expectativa. No está claro si el Teorema 3.2, y por lo tanto, esta afirmación, se cumple si A no es finito. Debemos señalar, sin embargo, que no se puede simplemente ingresar los resultados de [16]. Sus resultados son válidos para problemas de maximización del bienestar social y se basan en el uso de VCG para obtener un mecanismo fraccional veraz. Sin embargo, VCG no se aplica a la minimización del makespan, y en nuestro caso ni siquiera se conoce la existencia de un mecanismo fraccional veraz cercano a óptimo. Utilizamos el siguiente resultado adaptado de [16]. Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, P) un mecanismo fraccional veraz. Sea A un algoritmo de redondeo aleatorio que, dado un asignación fraccional x, produce una asignación aleatoria X tal que E ˆ Xij ˜ = xij para todo i, j. Entonces existen pagos P tales que el mecanismo M = (A, P) es veraz en promedio. Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de lanzamientos de moneda. Sea OPT(p) el makespan óptimo (sobre horarios enteros) para la instancia p. Como primer paso, tomamos un algoritmo de aproximación c y lo convertimos en un mecanismo fraccional de verdad de aproximación 2c. Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (satisfaciendo ciertas propiedades) de makespan a lo sumo c · OPT(p) para cada instancia p. Demostramos la veracidad mostrando que el algoritmo fraccional satisface la monotonía de ciclo (3). Observa que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinito): su cardinalidad es a lo sumo la del dominio de entrada, que es a lo sumo 2mn en el caso de dos valores. Por lo tanto, podemos aplicar el Corolario 3.4 aquí. Para convertir este mecanismo fraccional veraz en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que cumpla con los requisitos del Lema 4.1. Afortunadamente, dicho procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14]. Lema 4.2 (Kumar et al. [14]): Dada una asignación fraccional x y un vector de tiempos de procesamiento p, existe un procedimiento de redondeo aleatorio que produce una asignación X (aleatoria) tal que, 1. para cualquier i, j, E ˆ Xij ˜ = xij. 2. para cualquier i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij con probabilidad 1. La propiedad 1 se utilizará para obtener veracidad en la expectativa, y la propiedad 2 nos permitirá demostrar una garantía de aproximación. Primero demostramos que cualquier algoritmo que devuelva una asignación fraccional con ciertas propiedades satisface la monotonía de ciclo. Lema 4.3 Sea A un algoritmo que, para cualquier entrada p, produce una asignación (fraccional) x tal que, si pij = Hj entonces xij ≤ 1/m, y si pij = Lj entonces xij ≥ 1/m. Entonces A satisface la ciclo-monotonía. Prueba. Fija un jugador i y el vector de tiempos de procesamiento de los otros jugadores p−i. Necesitamos demostrar (3), es decir, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 para cada p1 i , . . . , pK i , donde el índice k = K + 1 se toma como k = 1. Demostraremos que para cada trabajo j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Si pk ij es el mismo para todos los k (ya sea siempre Lj o siempre Hj), entonces la desigualdad anterior claramente se cumple. De lo contrario, podemos dividir los índices 1, . . . , K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos k , k + 1, . . . , k − 1, k (donde K + 1 ≡ 1) tal que pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj. Esto se cumple porque debe haber algún k tal que pk ij = Hj > pk−1 ij = Lj. Tomamos k = k y luego seguimos incluyendo índices en este segmento hasta que alcancemos un k tal que pk ij = Lj y pk+1 ij = Hj. Establecemos k = k, y luego comenzamos un nuevo segmento maximal con índice k + 1. Ten en cuenta que k = k y k + 1 = k − 1. Ahora tenemos un subconjunto de índices y podemos continuar de forma recursiva. Entonces, todos los índices están incluidos en algún segmento maximal. Mostraremos que para cada segmento maximal k, k +1, . . . , k, P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Agregar esto para cada segmento produce la desigualdad deseada. Así que ahora concéntrate en un segmento maximal k, k + 1, . . . , k − 1, k. Por lo tanto, existe un k∗ tal que para k ≤ k < k∗ , tenemos pk ij = Hj, y para k∗ ≤ k ≤ k , tenemos pk ij = Lj. Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk∗ ij dado que pk ij = Hj y pk∗ ij = Lj. Ahora describimos cómo usar un algoritmo de c-aproximación para obtener un algoritmo que cumpla con la propiedad en el Lema 4.3. Para simplificar, primero supongamos que el algoritmo de aproximación devuelve un horario integral. La idea es simplemente difundir este horario. Tomamos cada trabajo j asignado a una máquina de alta y lo asignamos en una extensión de 1/m en todas las máquinas; para cada trabajo j asignado a una máquina de baja, digamos i, asignamos una fracción de 1/m a las otras máquinas donde es baja, y asignamos la fracción restante (que es al menos 1/m) a i. La asignación resultante satisface claramente las propiedades deseadas. También observe que la carga en cualquier máquina ha aumentado como máximo en 1 m · (carga en otras máquinas) ≤ makespan, y por lo tanto el makespan se ha duplicado como máximo. Esta distribución también se puede hacer si el horario inicial es fraccionado. Ahora describimos el algoritmo con precisión. Algoritmo 1 Sea A cualquier algoritmo que, para cualquier entrada p, genere una asignación posiblemente fraccional x tal que xij > 0 implica que pij ≤ T, donde T es el makespan de x. (En particular, cabe destacar que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades). Nuestro algoritmo, al que llamamos A, devuelve la siguiente asignación xF. Inicializar xF ij = 0 para todos los i, j. Para cada i, j, 1. si pij = Hj, establezca xF ij = P i :pi j =Hj xi j/m; 2. si pij = Lj, establezca xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m. Teorema 4.4 Supongamos que el algoritmo A cumple las condiciones del Algoritmo 1 y devuelve un makespan de a lo sumo c·OPT(p) para cada p. Entonces, el algoritmo A construido anteriormente es una aproximación 2c, algoritmo fraccional cíclico-monótono. Además, si xF ij > 0 en la entrada p, entonces pij ≤ c · OPT(p). Prueba. Primero, nota que xF es una asignación válida: para cada trabajo j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1. También tenemos que si pij = Hj, entonces xFij = Pi: pij = Hj xij/m ≤ 1/m. Si pij = Lj, entonces xF ij = xij(1 − /m) + P i =i xi j/m donde = |{i = i : pi j = Lj}| ≤ m − 1; por lo tanto, xF ij ≥ P i xi j/m ≥ 1/m. Por lo tanto, según el Lema 4.3, A satisface la monotonía de ciclo. La carga total en cualquier máquina i bajo xF es a lo sumo P j: pij = Hj P i: pij = Hj Hj · xi j m + P j: pij = Lj Lj ` xij + P i = i xi j m ´, que es a lo sumo P j pijxij + P i = i P j pijxi j/m ≤ 2c · OPT(p). Finalmente, si xF ij > 0 y pij = Lj, entonces pij ≤ OPT(p). Si pij = Hj, entonces para algún i (posiblemente i) con pij = Hj, tenemos xi j > 0, por lo tanto, por suposición, pij = Hj = pij ≤ c · OPT(p). El Teorema 4.4 combinado con los Lemas 4.1 y 4.2, proporciona un mecanismo de aproximación 3c, veraz en expectativa. La computación de los pagos dependerá del algoritmo de aproximación actual utilizado. La Sección 3, sin embargo, proporciona un procedimiento explícito para calcular los pagos garantizando la veracidad, aunque quizás no en tiempo polinómico. Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Tomando A en el Algoritmo 1 como el algoritmo que devuelve una asignación óptima de LP que cumple las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de aproximación 3. Corolario 4.6 Existe un mecanismo veraz-en-expectativa con una proporción de aproximación de 3 para el escenario Lj-Hj. 5. Un MECANISMO DETERMINISTA PARA EL CASO DE DOS VALORES Presentamos ahora un mecanismo determinista de aproximación 2-veraz para el caso donde pij ∈ {L, H} para todo i, j. En la secuela, a menudo diremos que j está asignado a una máquina de baja carga para indicar que j está asignado a una máquina i donde pij = L. Llamaremos a un trabajo j un trabajo de baja carga de la máquina i si pij = L; la carga baja de i es la carga en i debido a sus trabajos de baja carga, es decir, P j:pij = L xijpij. Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que cumpla con la monotonía de ciclo. Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar. Describimos nuestro algoritmo en la Sección 5.1. En la Sección 5.2, acotamos su garantía de aproximación y demostramos que cumple con la ciclo-monotonía. En la Sección 5.3, calculamos los pagos explícitos proporcionando un mecanismo veraz. Finalmente, en la Sección 5.4 demostramos que ningún mecanismo determinista puede lograr el makespan óptimo. Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).\n\nDefina nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Entonces, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L). Sustituyendo esto en (3) y dividiendo por (H − L), obtenemos lo siguiente. Proposición 5.1 La monotonía cíclica en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador i, cada p−i, cada entero K, y cada p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación cíclicamente monótono A continuación describimos un algoritmo que satisface la condición (6) y logra una aproximación de 2. Supondremos que L, H son enteros, lo cual no limita la generalidad. Un componente fundamental de nuestro algoritmo será un procedimiento que tome un umbral de carga entero T y calcule una asignación parcial entera x de trabajos a máquinas de manera que (a) un trabajo solo se asigna a una máquina de baja carga; (b) la carga en cualquier máquina sea como máximo T; y (c) se maximice el número de trabajos asignados. Tal asignación se puede calcular resolviendo un problema de flujo máximo: construimos un grafo bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y una arista (j, i) de capacidad infinita si pij = L. También agregamos un nodo fuente s con aristas (s, j) de capacidad 1, y un nodo sumidero t con aristas (i, t) de capacidad T/L. Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de makespan de a lo sumo T, donde xij = 1 si y solo si hay un flujo de 1 en la arista de j a i. Por lo tanto, utilizaremos los términos asignación y flujo indistintamente. Además, siempre hay un flujo máximo integral (ya que todas las capacidades son números enteros). A menudo nos referiremos a dicho flujo máximo como el flujo máximo para (p, T). Necesitamos un concepto adicional antes de describir el algoritmo. Podría haber potencialmente muchos flujos máximos y estaremos interesados en los más equilibrados, los cuales definimos formalmente de la siguiente manera. Arregla algún flujo máximo. Deje que ni p,T sea la cantidad de flujo en el borde (i, t) (o equivalentemente el número de trabajos asignados a i en el horario correspondiente), y deje que np,T sea el tamaño total del flujo máximo, es decir, np,T = Σ i ni p,T. Para cualquier T ≤ T, definimos ni p,T |T = min(ni p,T , T ), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo T. Define np,T |T = P i ni p,T |T . \n\nDefina np,T |T = P i ni p,T |T. Definimos un flujo o asignación de prefijo-maximal para T de la siguiente manera. Definición 5.2 (Flujo prefijo-maximal) Un flujo para la red anterior con umbral T es prefijo-maximal si para cada entero T ≤ T, tenemos np,T |T = np,T. Es decir, en un flujo de prefijo máximo para (p, T), si truncamos el flujo en algún T ≤ T, nos queda un flujo máximo para (p, T). Un hecho elemental sobre los flujos es que si una asignación/flujo x no es un flujo máximo para (p, T) entonces debe existir un camino de aumento P = (s, j1, i1, . . . , jK , iK , t) en el grafo residual que nos permita aumentar el tamaño del flujo. La interpretación es que en la asignación actual, j1 no está asignado, xi j = 0, lo cual se denota por las aristas directas (j , i), y xi j +1 = 1, lo cual se denota por las aristas inversas (i, j +1). Aumentar x usando P cambia la asignación de manera que cada j se asigna a i en la nueva asignación, lo que aumenta el valor del flujo en 1. Un camino de aumento simple no disminuye la carga de ninguna máquina; por lo tanto, se puede argumentar que siempre existe un flujo maximal de prefijo para un umbral T. Primero calculamos un flujo máximo para el umbral 1, utilizamos caminos de aumento simples para aumentarlo a un flujo máximo para el umbral 2, y repetimos el proceso, cada vez aumentando el flujo máximo para el umbral anterior t a un flujo máximo para el umbral t + 1 utilizando caminos de aumento simples. Algoritmo 2 Dado un vector de tiempos de procesamiento p, construir una asignación de trabajos a máquinas de la siguiente manera. 1. Calcular T∗ (p) = min ˘ T ≥ H, T múltiplo de L : np,T · L + (n − np,T ) · H ≤ m · T ¯ . Se observa que np,T ·L+(n−np,T )·H −m·T es una función decreciente de T, por lo que T∗ (p) se puede calcular en tiempo polinómico mediante búsqueda binaria. Calcular un flujo prefijo-maximal para el umbral T∗ (p) y la asignación parcial correspondiente (es decir, j se asigna a i si hay 1 unidad de flujo en el borde (j, i)). 3. Asigna los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera. Considera estos trabajos en un orden arbitrario y asigna cada trabajo a la máquina con la carga actual más baja (donde la carga incluye los trabajos asignados en la fase de flujo). Nuestro algoritmo necesita calcular una asignación prefijo-maximal para el umbral T∗ (p). La prueba que muestra la existencia de un flujo maximal de prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo. Pero hay que tener en cuenta que el flujo máximo permanece igual para cualquier T ≥ T = n · L. Por lo tanto, un flujo maximal de prefijo para T también es maximal de prefijo para cualquier T ≥ T. Por lo tanto, solo necesitamos calcular un flujo maximal de prefijo para T = min{T∗ (p), T }. Esto se puede hacer en tiempo polinómico utilizando el algoritmo de caminos aumentantes iterativos en la prueba de existencia para calcular de forma iterativa el flujo máximo para los múltiplos polinomialmente muchos de L hasta (e incluyendo) T. Teorema 5.3 Se pueden calcular eficientemente pagos que, combinados con el Algoritmo 2, producen un mecanismo veraz de aproximación determinística 2 para el dominio de programación de dos valores. 5.2 Análisis Sea OPT(p) la duración óptima para p. Ahora demostramos que el Algoritmo 2 es un algoritmo de aproximación 2 que cumple con la monotonía cíclica. Esto nos permitirá calcular los pagos en la Sección 5.3 y demostrar el Teorema 5.3. 5.2.1 Prueba de la Aproximación Reclamo 5.4 Si OPT(p) < H, el makespan es a lo sumo OPT(p). Prueba. Si OPT(p) < H, debe ser que el horario óptimo asigna todos los trabajos a máquinas de baja velocidad, por lo que np,OPT(p) = n. Por lo tanto, tenemos T∗ (p) = L · H L. Además, dado que calculamos un flujo maximal de prefijo para el umbral T∗(p), tenemos np,T∗(p)|OPT(p) = np,OPT(p) = n, lo que implica que la carga en cada máquina es a lo sumo OPT(p). Por lo tanto, en este caso el makespan es como máximo (y por lo tanto exactamente) OPT(p). Reclamo 5.5 Si OPT(p) ≥ H, entonces T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Prueba. Sea nOPT(p) el número de trabajos asignados a las máquinas de baja en un horario óptimo. La carga total en todas las máquinas es exactamente nOPT(p) · L + (n − nOPT(p)) · H, y como máximo es m · OPT(p), ya que cada máquina tiene una carga de como máximo OPT(p). Entonces, tomando T = L · OPT(p) L ≥ H, dado que np,T ≥ nOPT(p) tenemos que np,T ·L+(n−np,T )·H ≤ m·T. Por lo tanto, T∗ (p), el T más pequeño de este tipo, es a lo sumo L · OPT(p) L. Reclamo 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina de alta calidad. 258 Prueba. Supongamos que j se asigna a la máquina i en el paso 3. Si pij = L, entonces debemos tener ni p,T ∗(p) = T∗ (p), de lo contrario podríamos haber asignado j a i en el paso 2 para obtener un flujo de valor mayor. Por lo tanto, en el punto justo antes de que se asigne j en el paso 3, la carga de cada máquina debe ser al menos T∗ (p). Por lo tanto, la carga total después de que se asigna j es al menos m · T∗ (p) + L > m · T∗ (p). Pero la carga total es como máximo np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), lo que resulta en una contradicción. Lema 5.7 El algoritmo anterior devuelve un horario con un makespan de a lo sumo OPT(p) + max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p). Prueba. Si OPT(p) < H, entonces, según la Afirmación 5.4, hemos terminado. Entonces supongamos que OPT(p) ≥ H. Por la Afirmación 5.5, sabemos que T∗ (p) ≤ OPT(p) + L. Si no hay trabajos sin asignar después del paso 2 del algoritmo, entonces el tiempo de ejecución es a lo sumo T∗ (p) y hemos terminado. Así que supongamos que hay algunos trabajos no asignados después del paso 2. Mostraremos que el makespan después del paso 3 es a lo sumo T +H ` 1− 1 m ´ donde T = min ˘ T∗ (p), OPT(p) ¯ . Supongamos que la afirmación es falsa. Sea i la máquina con la carga máxima, entonces li > T + H ` 1 − 1 m ´ . Deja que j sea el último trabajo asignado a i en el paso 3, y considera el punto justo antes de que se le asigne a i. Entonces li > T − H/m en este punto. También, dado que j está asignado a i, según nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos li. Por lo tanto, la carga total después de que j sea asignado, es al menos H + m · li > m · T (ya que pij = H según la Reclamación 5.6). Además, para cualquier asignación de trabajos a máquinas en el paso 3, la carga total es a lo sumo np,T ∗(p) · L + (n − np,T ∗(p)) · H ya que hay np,T ∗(p) trabajos asignados a máquinas de baja prioridad. Por lo tanto, debemos tener m · T < np,T ∗(p) · L + (n - np,T ∗(p)) · H. Pero argumentaremos que m · T ≥ np,T ∗(p) · L + (n - np,T ∗(p)) · H, lo cual conduce a una contradicción. Si T = T∗ (p), esto se deduce de la definición de T∗ (p). Si T = OPT(p), entonces dejando que nOPT(p) denote el número de trabajos asignados a las máquinas de baja en un horario óptimo, tenemos np,T ∗(p) ≥ nOPT(p). Entonces, np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H. Este es exactamente la carga total en un horario óptimo, que es a lo sumo m · OPT(p). 5.2.2 Prueba de la monotonía del ciclo. Lema 5.8 Considere dos instancias p = (pi, p−i) y p = (pi, p−i) donde pi ≥ pi, es decir, pij ≥ pij ∀j. Si T es un umbral tal que np,T > np,T, entonces todo flujo máximo x para (p, T) debe asignar todos los trabajos j tales que pij = L. Demostración. Que Gp denote el grafo residual para (p, T) y el flujo x. Supongamos por contradicción que existe un trabajo j∗ con pij∗ = L que no está asignado por x. Dado que pi ≥ pi, todos los bordes (j, i) que están presentes en la red para (p, T) también están presentes en la red para (p, T). Por lo tanto, x es un flujo válido para (p, T). Pero no es un flujo máximo, ya que np,T > np,T. Entonces existe un camino de aumento P en el grafo residual para (p, T) y flujo x. Observa que el nodo i debe estar incluido en P, de lo contrario P también sería un camino de aumento en el grafo residual Gp, lo que contradiría el hecho de que x es un flujo máximo. En particular, esto implica que hay un camino P ⊂ P desde i hasta el sumidero t. Sea P = (i, j1, i1, . . . , jK , iK , t). Todos los bordes de P también están presentes como bordes en Gp: todos los bordes inversos (i, j +1) están presentes ya que dicho borde implica que xi j +1 = 1; todos los bordes directos (j, i) están presentes ya que i = i, por lo que pi j = pi j = L, y xi j +1 = 0. Pero luego hay un camino de aumento (j∗ , i, j1, i1, . . . , jK , iK , t) en Gp que contradice la maximalidad de x. Que L denote el vector de tiempo de procesamiento todo bajo. Define TL i (p−i) = T∗ (L, p−i). \n\nDefina TL i (p−i) = T∗ (L, p−i). Dado que nos estamos enfocando en la máquina i, y p−i está fijo en todo momento, abreviamos TL i (p−i) como TL. Además, sea pL = (L, p−i). Ten en cuenta que T∗ (p) ≥ TL para cada instancia p = (pi, p−i). Corolario 5.9 Sea p = (pi, p−i) cualquier instancia y sea x cualquier flujo prefijo-maximal para (p, T∗ (p)). Entonces, la carga baja en la máquina i es como máximo TL. Prueba. Que T∗ = T∗ (p). Si T∗ = TL, entonces esto es claramente cierto. De lo contrario, considera la asignación x truncada en TL. Dado que x es prefijo-maximal, sabemos que esto constituye un flujo máximo para (p, TL). Además, np,T L < npL,T L porque T∗ > TL. Entonces, según el Lema 5.8, este flujo truncado debe asignar todos los trabajos de baja prioridad de i. Por lo tanto, no puede haber un trabajo j con pij = L que se asigne a i después del umbral TL, ya que entonces j no sería asignado por este flujo truncado. Por lo tanto, la carga baja de i es como máximo TL. Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p−i, p1 i ) y p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) donde n2,1 H y n2,1 L están definidos en (4) y (5), respectivamente. Observa que esto implica inmediatamente la monotonía del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L; sumando esto sobre todos los k = 1, . . . , K da como resultado (6). Lema 5.10 Si T∗ (p1) > TL, entonces se cumple la ecuación (7). Prueba. Que T1 = T∗ (p1) y T2 = T∗ (p2). Toma el flujo máximo de prefijo x2 para (p2, T2), trúnquelo en TL y elimine todos los trabajos de esta asignación que se cuentan en n2,1 H, es decir, todos los trabajos j tales que x2 ij = 1, p2 ij = L, p1 ij = H. Denomina este flujo como x. Observe que x es un flujo válido para (p1, TL), y el tamaño de este flujo es exactamente np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H. Además, ninguno de los trabajos que se cuentan en n2,1 L está asignado por x, ya que cada trabajo j de este tipo tiene prioridad sobre i en p2. Dado que T1 > TL, debemos tener np1,TL < npTL,TL. Por lo tanto, si aumentamos x a un flujo máximo para (p1, TL), entonces, por el Lema 5.8 (con p = pL y p = p1), todos los trabajos correspondientes a n2,1 L deben asignarse en este flujo máximo. Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1,T L ≥ np2,T L − n2,1 H + n2,1 L, como se afirma. Lema 5.11 Supongamos que T∗ (p1 ) = TL. Entonces se cumple (7). Prueba. Nuevamente, dejemos que T1 = T∗ (p1) = TL y T2 = T∗ (p2). Que x1, x2 sean la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculada por nuestro algoritmo para p1, p2 respectivamente. Sea S = {j : x2 ij = 1 y p2 ij = L} y S = {j : x2 ij = 1 y p1 ij = L}. Por lo tanto, |S | = |S| − n2,1 H + n2,1 L y |S| = ni p2,T 2 = ni p2,T 2 |T L (por el Corolario 5.9). Sea T = |S| · L. Consideramos dos casos. Supongamos primero que T ≤ TL. Considera el siguiente flujo para (p1, TL): asigna a cada máquina que no sea i la asignación baja de x2 truncada en TL, y asigna los trabajos en S a la máquina i. Este es un flujo válido para (p1, TL) ya que la carga en i es T ≤ TL. Su tamaño es igual a P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L. El tamaño del flujo máximo para (p1, TL) no es menor, y se sigue la afirmación. Ahora supongamos que T > TL. Dado que |S| · L ≤ TL (por el Corolario 5.9), se sigue que n2,1 L > n2,1 H ≥ 0. Sea ˆT = T − L ≥ TL ya que T, TL son ambos múltiplos de L. Sea M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2. Primero demostramos que m · ˆT < M · L + (n − M) · H. (8) Sea N el número de trabajos asignados a la máquina i en x2. La carga en la máquina i es |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H, lo cual es al menos |S |·L > ˆT ya que n2,1 L ≤ N− |S|. Así obtenemos la desigualdad |S|·L+(N−|S|)·H > ˆT. Ahora considera el punto en la ejecución del algoritmo en la instancia p2 justo antes de que el último trabajo de alta prioridad sea asignado a i en el Paso 3 (debe haber tal trabajo ya que n2,1 L > 0). La carga en i en este punto es |S| · L + (N − |S| − 1) · H, que es al menos |S| · L − L = ˆT por un argumento similar al anterior. Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆT. Sumando estas desigualdades para todos los i = i, y la desigualdad anterior para i, obtenemos que |S| · L + (N − |S|) · H + Σ i = i Σ j p2 i jx2 i j > m ˆT. Pero el lado izquierdo es exactamente M · L + (n − M) · H. Por otro lado, dado que T1 = TL, tenemos m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L) · H. (9) Combinando (8) y (9), obtenemos que np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L. El Lema 5.12 del Algoritmo 2 satisface la monotonía del ciclo. Prueba. Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L. Sumando esto sobre todos los k = 1, . . . , K (donde K + 1 ≡ 1) se obtiene (6). 5.3 Cálculo de precios Los lemas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de aproximación 2 que satisface la monotonía de ciclo. Por lo tanto, según la discusión en la Sección 3, existen precios que generan un mecanismo veraz. Para obtener un mecanismo de tiempo polinómico, también necesitamos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico. No está claro si el procedimiento descrito en la Sección 3, basado en calcular los caminos más cortos en el grafo de asignación, produce un algoritmo de tiempo polinómico, ya que el grafo de asignación tiene un número exponencial de nodos (uno por cada asignación de salida). En lugar de analizar el grafo de asignación, aprovecharemos nuestra prueba de monotonía del ciclo, en particular, la desigualdad (7), y simplemente detallaremos los pagos. Recuerda que la utilidad de un jugador es ui = Pi − li, donde Pi es el pago realizado al jugador i. Para mayor comodidad, primero especificaremos los pagos negativos (es decir, los PIs serán los precios cobrados a los jugadores) y luego mostraremos que estos pueden ser modificados para que los jugadores tengan utilidades no negativas (si actúan de manera veraz). Que Hi denote el número de trabajos asignados a la máquina i en el paso 3. Por el Corolario 5.6, sabemos que todos estos trabajos están asignados a máquinas de alta calidad (según los pis declarados). Deja que H−i = P i =i Hi y n−i p,T = P i =i ni p,T. El pago Pi al jugador i se define como: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10). Podemos interpretar nuestros pagos como igualar el costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios VCG). Los primeros y segundos términos en (10), al restarse de la carga li, igualan el costo al total de la carga. El término np,T ∗(p) − np,T L i (p−i) es de hecho igual a n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) ya que la carga baja en i es a lo sumo TL i (p−i) (según la Reclamación 5.9). Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos de baja prioridad que fueron asignados más allá del umbral TL i (p−i) (a máquinas distintas de i) efectivamente como trabajos de alta prioridad para el cálculo total de utilidad desde su punto de vista. No está claro cómo se podrían haber ideado estos pagos de antemano para demostrar la veracidad de nuestro algoritmo. Sin embargo, al depender de la monotonía del ciclo, no solo pudimos argumentar la existencia de pagos, sino que nuestra prueba allanó el camino para inferir realmente estos pagos. El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan lugar a un mecanismo veraz. Lema 5.13 Fija un jugador i y las declaraciones de los otros jugadores p−i. Deje que su tipo verdadero sea p1 i. Entonces, bajo los pagos definidos en (10), la utilidad cuando declara su verdadero tipo p1 i es al menos su utilidad cuando declara cualquier otro tipo p2 i. Prueba. Que c1 i, c2 i denoten su costo total, definido como el negativo de su utilidad, cuando ella declara p1 y p2, respectivamente (y los demás declaran p−i). Dado que p−i está fijo, omitimos p−i de las expresiones a continuación para mayor claridad notacional. La verdadera carga de i cuando declara su verdadero tipo p1 i es L · ni p1,T ∗(p1) + H · Hi (p1), y por lo tanto c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) Por otro lado, la verdadera carga cuando declara p2 i es L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L) + H · (Hi + n2,1 H − n2,1 L) (ya que el vector de tiempo de procesamiento verdadero es p1 i), y así c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L. Por lo tanto, (7) implica que c1 i ≤ c2 i. Las especificaciones de precios suelen requerirse para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de un jugador debe ser no negativa si revela su valor real. Los pagos dados por (10) no son individualmente racionales ya que en realidad le cobran a un jugador una cierta cantidad. Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficientemente grande a la definición del precio. En nuestro caso, por ejemplo, dejando que H denote el vector de todas las H, podemos añadir el término n·H −(H −L)n(H,p−i),T L i (p−i) a (10). Ten en cuenta que esto es una constante para el jugador i. Por lo tanto, los nuevos pagos son Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ . Como se muestra en (11), esto resultará en una utilidad no negativa para i (ya que n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) para cualquier tipo pi del jugador i). Esta modificación también garantiza la propiedad de normalización adicional deseada de que si un jugador no recibe trabajos, entonces recibe un pago de cero: si el jugador i recibe el conjunto vacío para algún tipo pi, entonces también recibirá el conjunto vacío para el tipo H (esto es fácil de verificar para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero; por lo tanto, por veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que i reciba el conjunto vacío. Esto completa la demostración del Teorema 5.3. 260 5.4 Imposibilidad de implementación exacta. Ahora mostramos que, independientemente de consideraciones computacionales, no existe un algoritmo cíclico-monótono para el caso L-H con una proporción de aproximación mejor que 1.14. Sea H = α·L para algún 2 < α < 2.5 que elegiremos más tarde. Hay dos máquinas I, II y siete trabajos. Considera los siguientes dos escenarios: Escenario 1. Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5 son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna los trabajos 1-5 a una máquina y los trabajos 6, 7 a la otra, y tiene un makespan OPT1 = 5L. El segundo mejor horario tiene un tiempo de ejecución de al menos Second1 = 2H + L. Escenario 2. Si el algoritmo elige un horario óptimo para el escenario 1, asuma sin pérdida de generalidad que los trabajos 6 y 7 están asignados a la máquina II. En el escenario 2, la máquina I tiene el mismo vector de tiempos de procesamiento. La Máquina II reduce los trabajos 6 y 7 a L y aumenta los trabajos 1-5 a H. Un horario óptimo tiene un tiempo de ejecución de 2L + H, donde la Máquina II realiza los trabajos 6, 7 y uno de los trabajos 1-5. La segunda mejor programación para este escenario tiene un makespan de al menos Second2 = 5L. Teorema 5.14 Ningún mecanismo determinístico y veraz para el problema de programación de dos valores puede obtener una proporción de aproximación mejor que 1.14. Prueba. Primero argumentamos que un algoritmo cíclico-monótono no puede elegir el horario óptimo en ambos escenarios. Esto se debe a que de lo contrario se viola la monotonía del ciclo para la máquina II. Tomando p1 II , p2 II como vectores de tiempos de procesamiento de la máquina II para los escenarios 1, 2 respectivamente, obtenemos P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0. Por lo tanto, cualquier mecanismo veraz debe devolver un makespan subóptimo en al menos un escenario, y por lo tanto su ratio de aproximación es al menos min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 para α = 2.364. Observamos que para el caso {Lj, Hj} donde hay una razón común r = Hj Lj para todos los trabajos (esto generaliza el escenario de máquinas restringidas) se puede obtener un mecanismo fraccional veraz (con precios computables eficientemente) que devuelve un horario de makespan de a lo sumo OPT(p) para cada p. Se puede ver cada trabajo j como consistente de Lj subtrabajos de tamaño 1 en una máquina i si pij = Lj, y de tamaño r si pij = Hj. Para esta nueva instancia ˜p, nota que ˜pij ∈ {1, r} para cada i, j. También hay que tener en cuenta que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxij =P j : subtrabajo de j ˜pij ˜xij. Por lo tanto, si utilizamos el Algoritmo 2 para obtener un horario para la instancia ˜p, la ecuación (6) se traduce precisamente a (3) para la asignación x; además, los precios para ˜p se traducen en precios para la instancia p. El número de subtrabajos asignados a máquinas de baja en la fase de flujo es simplemente el trabajo total asignado a las máquinas de baja. Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a las máquinas de baja capacidad. Además, dado que tenemos un <br>dominio fraccional</br>, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p). La asignación x no necesita cumplir la condición de que xij > 0 implica pij ≤ OPT(p) para cualquier r, por lo tanto, el procedimiento de redondeo del Lema 4.2 no produce un mecanismo de aproximación 2-veraz en expectativa. Pero si r > OPT(p) (como en el escenario de máquinas restringidas), esta condición sí se cumple, por lo que obtenemos un mecanismo veraz de aproximación 2. Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda en refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus comentarios útiles. 6. REFERENCIAS [1] N. Andelman, Y. Azar y M. Sorani. Mecanismos de aproximación veraces para la programación de máquinas relacionadas egoístas. En Proc. 22º STACS, 69-82, 2005. [2] A. Archer. Mecanismos para la optimización discreta con agentes racionales. Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´E. This word does not have a meaning in English. Could you please provide more context or clarify the sentence? Mecanismos veraces para agentes de un parámetro. En Proc. 42º FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano. Mecanismos de aproximación veraces determinísticos para máquinas relacionadas con la programación. En Proc. 21º STACS, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani. Asignación de bienes indivisibles. En ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La debilidad de la monotonicidad caracteriza la implementación de estrategias dominantes determinísticas. Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking. Técnicas de aproximación para el diseño de mecanismos utilitarios. En Proc. 37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali. Un límite inferior para los mecanismos de programación. En Proc. 18th SODA, páginas 1163-1170, 2007. [9] E. Clarke. Precios escalonados de bienes públicos. Elección Pública, 8:17-33, 1971. [10] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, y R. V. Vohra. Caracterizando mecanismos de estrategia dominante con tipos multidimensionales, 2004. Documento de trabajo. [12] L. A. Sala. Algoritmos de aproximación para la programación de tareas. En D. Hochbaum, editor, Algoritmos de Aproximación para Problemas NP-Difíciles. PWS Publishing, MA, 1996. [13] A. Kovács. Algoritmo de aproximación rápida y monótona 3 para la programación de máquinas relacionadas. En Proc. 13th ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan. Algoritmos de aproximación para la programación en múltiples máquinas. En Proc. 46th FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan. Hacia una caracterización de subastas combinatorias veraces. En Proc. 44th FOCS, páginas 574-583, 2003. [16] R. Lavi y C. Swamy. Diseño de mecanismos veraz y casi óptimos a través de programación lineal. En Proc. 46th FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. OCallaghan y Y. Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Revista de la ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, y ´E. This word does not have a meaning in English. Could you please provide more context or another sentence for translation? Algoritmos de aproximación para la programación de máquinas paralelas no relacionadas. Matemáticas. Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. \n\nProg., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, y A. Saberi. Sobre asignaciones aproximadamente justas de bienes indivisibles. En Proc. 5to EC, páginas 125-131, 2004. [20] A. Mualem y M. Schapira. Estableciendo límites inferiores en la veracidad. En Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [22] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Economía. Comportamiento, 35:166-196, 2001. [23] J. C. Rochet. Una condición necesaria y suficiente para la racionalización en un contexto cuasilineal. Revista de Economía Matemática, 16:191-200, 1987. [24] M. Saks y L. Yu. La monotonía débil es suficiente para la veracidad en dominios convexos. En Proc. 6to EC, páginas 286-293, 2005. [25] D. B. Shmoys y ´E. This word does not have a specific meaning in English. Could you please provide more context or another sentence for translation? Un algoritmo de aproximación para el problema de asignación generalizada. Programación Matemática, 62:461-474, 1993. [26] W. Vickrey. Contraespeculaciones, subastas y licitaciones selladas competitivas. I'm sorry, but the sentence \"J.\" does not have a clear meaning or context for translation. Could you please provide more information or a complete sentence for me to translate into Spanish? Finanzas, 16:8-37, 1961. 261 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "schedule": {
            "translated_key": "horario",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Truthful Mechanism Design for Multi-Dimensional Scheduling via Cycle Monotonicity Ron Lavi Industrial Engineering and Management The Technion - Israel Institute of Technology ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca ABSTRACT We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players.",
                "This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m)-approximation truthful mechanisms [22, 20].",
                "We study a well-motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job-dependent.",
                "This preserves the multidimensionality of the domain, and generalizes the restricted-machines (i.e., {pj, ∞}) setting in scheduling.",
                "We give a general technique to convert any c-approximation algorithm to a 3capproximation truthful-in-expectation mechanism.",
                "This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black-box fashion.",
                "When the low and high values are the same for all jobs, we devise a deterministic 2-approximation truthful mechanism.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Our constructions are novel in two respects.",
                "First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity.",
                "Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains.",
                "However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting.",
                "Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin-expectation mechanism.",
                "This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]; J.4 [Social and Behavioral Sciences]: Economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm.",
                "Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal.",
                "Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention.",
                "In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization.",
                "There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine.",
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to <br>schedule</br> the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the <br>schedule</br>.",
                "Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]).",
                "Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost).",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a <br>schedule</br>, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "Such a mechanism is called a truthful mechanism.",
                "The makespan-minimization objective is quite different from the classic goal of social-welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players.",
                "Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max-min fairness, and appears to be a much harder problem from the viewpoint of mechanism design.",
                "In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques.",
                "The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players processing times, in particular, the dimensionality of the domain.",
                "Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary.",
                "This is a multidimensional domain, since a players private value is its entire vector of processing times (pij)j.",
                "Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m)-approximation truthful mechanisms [22, 20].",
                "We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain.",
                "On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms.",
                "Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound.",
                "In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines.",
                "Here, we have pij = pj/si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i.",
                "This assumption makes the domain of players types single-dimensional.",
                "Truthfulness in such domains is equivalent to a convenient value-monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains.",
                "Archer and Tardos [3] first considered the related machines setting and gave a randomized 3-approximation truthful-in-expectation mechanism.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal <br>schedule</br>. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Various follow-up results [2, 4, 1, 13] have strengthened the notion of truthfulness and/or improved the approximation ratio.",
                "Such difficulties in moving from the single-dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions).",
                "Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains.",
                "In this paper, we consider the makespan-minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine.",
                "More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high).",
                "We call this model the jobdependent two-values case.",
                "This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well-studied algorithmically.",
                "A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two-values scheduling model.",
                "Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern.",
                "Thus, the private information of each machine is a vector specifying which jobs are low and high on it.",
                "Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem.",
                "Our Results and Techniques We present various positive results for our multidimensional scheduling domains.",
                "Our first result is a general method to convert any capproximation algorithm for the job-dependent two values setting into a 3c-approximation truthful-in-expectation mechanism.",
                "This is one of the very few known results that use an approximation algorithm in a black-box fashion to obtain a truthful mechanism for a multidimensional problem.",
                "Our result implies that there exists a 3-approximation truthfulin-expectation mechanism for the Lj-Hj setting.",
                "Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently-computable prices (but the allocation rule is efficiently computable).",
                "Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness.",
                "We obtain a deterministic 2-approximation truthful mechanism (along with prices) for this problem.",
                "These are the first truthful mechanisms with non-trivial performance guarantees for a multidimensional scheduling domain.",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal <br>schedule</br> (unlike in the case of related machines).",
                "By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations).",
                "The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms.",
                "Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability).",
                "This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value-monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]).",
                "But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single-minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs. single-dimensional domains.",
                "Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains.",
                "The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]).",
                "It is a generalization of value-monotonicity and completely characterizes truthfulness in every domain.",
                "Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains.",
                "Consider, for example, our first result showing that any c-approximation algorithm can be exported to a 3c-approximation truthful-in-expectation mechanism.",
                "At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism.",
                "But, cycle monotonicity does allow us to prove such a statement.",
                "In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement.",
                "The method for converting approximation algorithms into truthful mechanisms involves another novel idea.",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional <br>schedule</br>.",
                "Moving to a fractional domain allows us to plug-in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio.",
                "We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment.",
                "For this, we use a recent rounding procedure of Kumar et al. [14] that is tailored for unrelated-machine scheduling.",
                "This preserves truthfulness, but we lose another additive factor equal to the approximation ratio.",
                "Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design.",
                "Related Work Nisan and Ronen [22] first considered the makespan-minimization problem for unrelated machines.",
                "They gave an m-approximation positive result and proved various lower bounds.",
                "Recently, Mualem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful-in-expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2)-lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related-machines problem and gave a 3-approximation truthful-in-expectation mechanism.",
                "This been improved in [2, 4, 1, 13] to: a 2-approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3-approximation deterministic mechanism by Kov´acs [13].",
                "The algorithmic problem (i.e., without requiring truthfulness) of makespan-minimization on unrelated machines is well understood and various 2-approximation algorithms are known.",
                "Lenstra, Shmoys and Tardos [18] gave the first such algorithm.",
                "Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan.",
                "Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds.",
                "We use their procedure in our randomized mechanism.",
                "The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al. [11]).",
                "This generalizes the value-monotonicity condition for single-dimensional domains which was given by Myerson [21] and rediscovered by [3].",
                "As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single-dimensional domains [3, 7, 4, 1, 13].",
                "For convex domains (i.e., each players set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24].",
                "But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems.",
                "Objectives other than social-welfare maximization and revenue maximization have received very little attention in mechanism design.",
                "In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy-minimizing allocation have been studied briefly.",
                "Lavi, Mualem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5-approximation mechanism for two players with additive valuations.",
                "Lipton et al. [19] showed that the latter objective cannot be implemented truthfully.",
                "These lower bounds were strengthened in [20]. 2.",
                "PRELIMINARIES 2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine.",
                "In the unrelated-machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes is processing time for job j with the value ∞ specifying that i cannot process j.",
                "We consider two special cases of this problem: 1.",
                "The job-dependent two-values case, where pij ∈ {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known.",
                "This generalizes the classic scheduling model of restricted machines, where Hj = ∞. 2.",
                "The two-values case, which is a special case of above where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j.",
                "We say that a job j is low on machine i if pij = Lj, and high if pij = Hj.",
                "We will use the terms <br>schedule</br> and assignment interchangeably.",
                "We represent a deterministic <br>schedule</br> by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j.",
                "We will also consider randomized algorithms and algorithms that return a fractional assignment.",
                "In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j.",
                "For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments).",
                "We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a <br>schedule</br> is defined as the maximum load on any machine, i.e., maxi li.",
                "The goal in the makespan-minimization problem is to assign the jobs to the machines so as to minimize the makespan of the <br>schedule</br>. 2.2 Mechanism design We consider the makespan-minimization problem in the above scheduling domains in the context of mechanism design.",
                "Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure.",
                "Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents.",
                "The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines.",
                "Each machine is a selfish entity, that privately knows its own processing time for each job. on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost.",
                "We consider direct-revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a <br>schedule</br> and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs.",
                "A (direct-revelation) mechanism thus consists of a tuple (x, P): x specifies the <br>schedule</br>, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j.",
                "The mechanisms goal is to compute a <br>schedule</br> that has near-optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility.",
                "The mechanism must therefore incentivize the machines/players to truthfully reveal their processing times via the payments.",
                "This is made precise using the notion of dominant-strategy truthfulness.",
                "Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing-time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the <br>schedule</br> and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i).",
                "To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare.",
                "We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables.",
                "The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments.",
                "For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing-time vector.",
                "Inequality (1) also defines truthfulness-in-expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithms <br>schedule</br> (i.e., xk ij is the probability that j is assigned to i in the <br>schedule</br> output for (pk i , p−i)).",
                "For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known.",
                "The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it.",
                "We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. 3.",
                "CYCLE MONOTONICITY Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity.",
                "This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains.",
                "However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms.",
                "Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness.",
                "One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms.",
                "We include a brief exposition on it for completeness.",
                "The exposition here is largely based on [11].",
                "Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as is value for alternative a.",
                "In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of is load in the <br>schedule</br> a.",
                "Let Vi denote the set of all possible types of player i.",
                "A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices).",
                "The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i).",
                "A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful?",
                "It is well known (see e.g. [15]) that the price Pi can only depend on the alternative chosen and the others declarations, that is, we may write Pi : V−i × A → R. Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i).",
                "Now fix a player i, and fix the declarations v−i of the others.",
                "We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a. (Strictly speaking, we should use A = f(Vi, v−i) instead of A here.)",
                "Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}.",
                "We can now rephrase the above price-assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory.",
                "Definition 3.1 (Gui et al. [11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b.",
                "Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative-length cycles.",
                "Furthermore, if all cycles are non-negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a.",
                "This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles.",
                "Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , . . . , vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1.",
                "Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain.",
                "Fix a player i, p−i, and any p1 i , . . . , pK i .",
                "Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 . xk could be a {0, 1}-assignment or a fractional assignment.",
                "We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0.",
                "Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem.",
                "For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). 4.",
                "A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS In this section, we consider the case of job-dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted-machines model (where Hj = ∞).",
                "We show the power of randomization, by providing a general technique that converts any c-approximation algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box.",
                "Our construction and proof are simple, and based on two ideas.",
                "First, as outlined above, we prove truthfulness using cycle monotonicity.",
                "It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle-monotonicity allows us to prove precisely this.",
                "Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional <br>schedule</br> as a convex combination of integer schedules.",
                "This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful-in-expectation mechanisms. 1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite.",
                "We should point out however that one cannot simply plug in the results of [16].",
                "Their results hold for social-welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism.",
                "VCG however does not apply to makespan minimization, and in our case even the existence of a near-optimal fractional truthful mechanism is not known.",
                "We use the following result adapted from [16].",
                "Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism.",
                "Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j.",
                "Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation.",
                "Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses.",
                "Let OPT(p) denote the optimal makespan (over integer schedules) for instance p. As our first step, we take a capproximation algorithm and convert it to a 2c-approximation fractional truthful mechanism.",
                "This conversion works even when the approximation algorithm returns only a fractional <br>schedule</br> (satisfying certain properties) of makespan at most c · OPT(p) for every instance p. We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3).",
                "Notice that the alternative-set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two-value case.",
                "Thus, we can apply Corollary 3.4 here.",
                "To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1.",
                "Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14].",
                "Lemma 4.2 (Kumar et al. [14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, 1. for any i, j, E ˆ Xij ˜ = xij. 2. for any i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1.",
                "Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee.",
                "We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity.",
                "Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1/m, and if pij = Lj then xij ≥ 1/m.",
                "Then A satisfies cycle-monotonicity.",
                "Proof.",
                "Fix a player i, and the vector of processing times of the other players p−i.",
                "We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , . . . , pK i , where index k = K + 1 is taken to be k = 1.",
                "We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds.",
                "Otherwise we can 256 divide the indices 1, . . . , K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, . . . , k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj.",
                "This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj.",
                "We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj.",
                "We set k = k, and then start a new maximal segment with index k + 1.",
                "Note that k = k and k + 1 = k − 1.",
                "We now have a subset of indices and we can continue recursively.",
                "So all indices are included in some maximal segment.",
                "We will show that for every such maximal segment k , k +1, . . . , k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0.",
                "Adding this for each segment yields the desired inequality.",
                "So now focus on a maximal segment k , k + 1, . . . , k − 1, k .",
                "Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj.",
                "Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj.",
                "We now describe how to use a c-approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3.",
                "For simplicity, first suppose that the approximation algorithm returns an integral <br>schedule</br>.",
                "The idea is to simply spread this <br>schedule</br>.",
                "We take each job j assigned to a high machine and assign it to an extent 1/m on all machines; for each job j assigned to a low machine, say i, we assign 1/m-fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1/m) to i.",
                "The resulting assignment clearly satisfies the desired properties.",
                "Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled.",
                "This spreading out can also be done if the initial <br>schedule</br> is fractional.",
                "We now describe the algorithm precisely.",
                "Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x. (In particular, note that any algorithm that returns an integral assignment has these properties.)",
                "Our algorithm, which we call A , returns the following assignment xF .",
                "Initialize xF ij = 0 for all i, j.",
                "For every i, j, 1. if pij = Hj, set xF ij = P i :pi j =Hj xi j/m; 2. if pij = Lj, set xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m.",
                "Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p. Then, the algorithm A constructed above is a 2c-approximation, cycle-monotone fractional algorithm.",
                "Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p).",
                "Proof.",
                "First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1.",
                "We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j/m ≤ 1/m.",
                "If pij = Lj, then xF ij = xij(1 − /m) + P i =i xi j/m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j/m ≥ 1/m.",
                "Thus, by Lemma 4.3, A satisfies cycle monotonicity.",
                "The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j/m ≤ 2c · OPT(p).",
                "Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p).",
                "If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p).",
                "Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c-approximation, truthful-in-expectation mechanism.",
                "The computation of payments will depend on the actual approximation algorithm used.",
                "Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial-time.",
                "Theorem 4.5 The procedure in Algorithm 1 converts any c-approximation fractional algorithm into a 3c-approximation, truthful-in-expectation mechanism.",
                "Taking A in Algorithm 1 to be the algorithm that returns an LP-optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3-approximation mechanism.",
                "Corollary 4.6 There is a truthful-in-expectation mechanism with approximation ratio 3 for the Lj-Hj setting. 5.",
                "A DETERMINISTIC MECHANISM FOR THE TWO-VALUES CASE We now present a deterministic 2-approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j.",
                "In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L. We will call a job j a low job of machine i if pij = L; the low-load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij.",
                "As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity.",
                "We first obtain a simplification of condition (3) for our two-values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with.",
                "We describe our algorithm in Section 5.1.",
                "In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle-monotonicity.",
                "In Section 5.3, we compute explicit payments giving a truthful mechanism.",
                "Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan.",
                "Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).",
                "Plugging this into (3) and dividing by (H − L), we get the following.",
                "Proposition 5.1 Cycle monotonicity in the two-values scheduling domain is equivalent to the condition that, for every player i, every p−i, every integer K, and every p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Acycle-monotone approximation algorithm We now describe an algorithm that satisfies condition (6) and achieves a 2-approximation.",
                "We will assume that L, H are integers, which is without loss of generality.",
                "A core component of our algorithm will be a procedure that takes an integer load threshold T and computes an integer partial assignment x of jobs to machines such that (a) a job is only assigned to a low machine; (b) the load on any machine is at most T; and (c) the number of jobs assigned is maximized.",
                "Such an assignment can be computed by solving a max-flow problem: we construct a directed bipartite graph with a node for every job j and every machine i, and an edge (j, i) of infinite capacity if pij = L. We also add a source node s with edges (s, j) having capacity 1, and sink node t with edges (i, t) having capacity T/L .",
                "Clearly any integer flow in this network corresponds to a valid integer partial assignment x of makespan at most T, where xij = 1 iff there is a flow of 1 on the edge from j to i.",
                "We will therefore use the terms assignment and flow interchangeably.",
                "Moreover, there is always an integral max-flow (since all capacities are integers).",
                "We will often refer to such a max-flow as the max-flow for (p, T).",
                "We need one additional concept before describing the algorithm.",
                "There could potentially be many max-flows and we will be interested in the most balanced ones, which we formally define as follows.",
                "Fix some max-flow.",
                "Let ni p,T be the amount of flow on edge (i, t) (or equivalently the number of jobs assigned to i in the corresponding <br>schedule</br>), and let np,T be the total size of the max-flow, i.e., np,T = P i ni p,T .",
                "For any T ≤ T, define ni p,T |T = min(ni p,T , T ), that is, we truncate the flow/assignment on i so that the total load on i is at most T .",
                "Define np,T |T = P i ni p,T |T .",
                "We define a prefix-maximal flow or assignment for T as follows.",
                "Definition 5.2 (Prefix-maximal flow) A flow for the above network with threshold T is prefix-maximal if for every integer T ≤ T, we have np,T |T = np,T .",
                "That is, in a prefix-maximal flow for (p, T), if we truncate the flow at some T ≤ T, we are left with a max-flow for (p, T ).",
                "An elementary fact about flows is that if an assignment/flow x is not a maximum flow for (p, T) then there must be an augmenting path P = (s, j1, i1, . . . , jK , iK , t) in the residual graph that allows us to increase the size of the flow.",
                "The interpretation is that in the current assignment, j1 is unassigned, xi j = 0, which is denoted by the forward edges (j , i ), and xi j +1 = 1, which is denoted by the reverse edges (i , j +1).",
                "Augmenting x using P changes the assignment so that each j is assigned to i in the new assignment, which increases the value of the flow by 1.",
                "A simple augmenting path does not decrease the load of any machine; thus, one can argue that a prefix-maximal flow for a threshold T always exists.",
                "We first compute a max-flow for threshold 1, use simple augmenting paths to augment it to a max-flow for threshold 2, and repeat, each time augmenting the max-flow for the previous threshold t to a max-flow for threshold t + 1 using simple augmenting paths.",
                "Algorithm 2 Given a vector of processing times p, construct an assignment of jobs to machines as follows. 1.",
                "Compute T∗ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯ .",
                "Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search. 2.",
                "Compute a prefix-maximal flow for threshold T∗ (p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i)). 3.",
                "Assign the remaining jobs, i.e., the jobs unassigned in the flow-phase, in a greedy manner as follows.",
                "Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow-phase).",
                "Our algorithm needs to compute a prefix-maximal assignment for the threshold T∗ (p).",
                "The proof showing the existence of a prefix-maximal flow only yields a pseudopolynomial time algorithm for computing it.",
                "But notice that the max-flow remains the same for any T ≥ T = n · L. So a prefix-maximal flow for T is also prefix-maximal for any T ≥ T .",
                "Thus, we only need to compute a prefix-maximal flow for T = min{T∗ (p), T }.",
                "This can be be done in polynomial time by using the iterative-augmenting-paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T .",
                "Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two-values scheduling domain. 5.2 Analysis Let OPT(p) denote the optimal makespan for p. We now prove that Algorithm 2 is a 2-approximation algorithm that satisfies cycle monotonicity.",
                "This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3. 5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p).",
                "Proof.",
                "If OPT(p) < H, it must be that the optimal <br>schedule</br> assigns all jobs to low machines, so np,OPT(p) = n. Thus, we have T∗ (p) = L · H L .",
                "Furthermore, since we compute a prefix-maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p).",
                "So in this case the makespan is at most (and hence exactly) OPT(p).",
                "Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Proof.",
                "Let nOPT(p) be the number of jobs assigned to low machines in an optimum <br>schedule</br>.",
                "The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p).",
                "So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T.",
                "Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L .",
                "Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine. 258 Proof.",
                "Suppose j is assigned to machine i in step 3.",
                "If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value.",
                "So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p).",
                "Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p).",
                "But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction.",
                "Lemma 5.7 The above algorithm returns a <br>schedule</br> with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p).",
                "Proof.",
                "If OPT(p) < H, then by Claim 5.4, we are done.",
                "So suppose OPT(p) ≥ H. By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L. If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done.",
                "So assume that there are some unassigned jobs after step 2.",
                "We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯ .",
                "Suppose the claim is false.",
                "Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´ .",
                "Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i.",
                "So li > T − H/m at this point.",
                "Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li.",
                "So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6).",
                "Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines.",
                "Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H. But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction.",
                "If T = T∗ (p), this follows from the definition of T∗ (p).",
                "If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum <br>schedule</br>, we have np,T ∗(p) ≥ nOPT(p).",
                "So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H.",
                "This is exactly the total load in an optimum <br>schedule</br>, which is at most m · OPT(p). 5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j.",
                "If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L. Proof.",
                "Let Gp denote the residual graph for (p , T) and flow x .",
                "Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x .",
                "Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T).",
                "Thus, x is a valid flow for (p, T).",
                "But it is not a max-flow, since np,T > np ,T .",
                "So there exists an augmenting path P in the residual graph for (p, T) and flow x .",
                "Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow.",
                "In particular, this implies that there is a path P ⊂ P from i to the sink t. Let P = (i, j1, i1, . . . , jK , iK , t).",
                "All the edges of P are also present as edges in Gp - all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0.",
                "But then there is an augmenting path (j∗ , i, j1, i1, . . . , jK , iK , t) in Gp which contradicts the maximality of x .",
                "Let L denote the all-low processing time vector.",
                "Define TL i (p−i) = T∗ (L, p−i).",
                "Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL .",
                "Also, let pL = (L, p−i).",
                "Note that T∗ (p) ≥ TL for every instance p = (pi, p−i).",
                "Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix-maximal flow for (p, T∗ (p)).",
                "Then, the low-load on machine i is at most TL .",
                "Proof.",
                "Let T∗ = T∗ (p).",
                "If T∗ = TL , then this is clearly true.",
                "Otherwise, consider the assignment x truncated at TL .",
                "Since x is prefix-maximal, we know that this constitutes a max-flow for (p, TL ).",
                "Also, np,T L < npL,T L because T∗ > TL .",
                "So by Lemma 5.8, this truncated flow must assign all the low jobs of i.",
                "Hence, there cannot be a job j with pij = L that is assigned to i after the TL -threshold since then j would not be assigned by this truncated flow.",
                "Thus, the low-load of i is at most TL .",
                "Using these properties, we will prove the following key inequality: for any p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) where n2,1 H and n2,1 L are as defined in (4) and (5), respectively.",
                "Notice that this immediately implies cycle monotonicity, since if we take p1 = pk and p2 = pk+1 , then (7) implies that npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L ; summing this over all k = 1, . . . , K gives (6).",
                "Lemma 5.10 If T∗ (p1 ) > TL , then (7) holds.",
                "Proof.",
                "Let T1 = T∗ (p1 ) and T2 = T∗ (p2 ).",
                "Take the prefix-maximal flow x2 for (p2 , T2 ), truncate it at TL , and remove all the jobs from this assignment that are counted in n2,1 H , that is, all jobs j such that x2 ij = 1, p2 ij = L, p1 ij = H. Denote this flow by x.",
                "Observe that x is a valid flow for (p1 , TL ), and the size of this flow is exactly np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H .",
                "Also none of the jobs that are counted in n2,1 L are assigned by x since each such job j is high on i in p2 .",
                "Since T1 > TL , we must have np1,T L < npL,T L .",
                "So if we augment x to a max-flow for (p1 , TL ), then by Lemma 5.8 (with p = pL and p = p1 ), all the jobs corresponding to n2,1 L must be assigned in this max-flow.",
                "Thus, the size of this max-flow is at least (size of x) + n2,1 L , that is, np1,T L ≥ np2,T L − n2,1 H + n2,1 L , as claimed.",
                "Lemma 5.11 Suppose T∗ (p1 ) = TL .",
                "Then (7) holds.",
                "Proof.",
                "Again let T1 = T∗ (p1 ) = TL and T2 = T∗ (p2 ).",
                "Let x1 , x2 be the complete assignment, i.e., the assignment after both steps 2 and 3, computed by our algorithm for p1 , p2 respectively.",
                "Let S = {j : x2 ij = 1 and p2 ij = L} and S = {j : x2 ij = 1 and p1 ij = L}.",
                "Therefore, |S | = |S| − n2,1 H + n2,1 L and |S| = ni p2,T 2 = ni p2,T 2 |T L (by Corollary 5.9).",
                "Let T = |S | · L. We consider two cases.",
                "Suppose first that T ≤ TL .",
                "Consider the following flow for (p1 , TL ): assign to every machine other than i the lowassignment of x2 truncated at TL , and assign the jobs in S to machine i.",
                "This is a valid flow for (p1 , TL ) since the load on i is T ≤ TL .",
                "Its size is equal to P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L .",
                "The size of the max-flow for (p1 , TL ) is no smaller, and the claim follows. 259 Now suppose T > TL .",
                "Since |S| · L ≤ TL (by Corollary 5.9), it follows that n2,1 L > n2,1 H ≥ 0.",
                "Let ˆT = T − L ≥ TL since T , TL are both multiples of L. Let M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2 .",
                "We first show that m · ˆT < M · L + (n − M) · H. (8) Let N be the number of jobs assigned to machine i in x2 .",
                "The load on machine i is |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H which is at least |S |·L > ˆT since n2,1 L ≤ N− |S|.",
                "Thus we get the inequality |S |·L+(N −|S |)·H > ˆT.",
                "Now consider the point in the execution of the algorithm on instance p2 just before the last high job is assigned to i in Step 3 (there must be such a job since n2,1 L > 0).",
                "The load on i at this point is |S| · L + (N − |S| − 1) · H which is least |S | · L − L = ˆT by a similar argument as above.",
                "By the greedy property, every i = i also has at least this load at this point, so P j p2 i jx2 i j ≥ ˆT.",
                "Adding these inequalities for all i = i, and the earlier inequality for i, we get that |S | · L + (N − |S |) · H + P i =i P j p2 i jx2 i j > m ˆT.",
                "But the left-hand-side is exactly M · L + (n − M) · H. On the other hand, since T1 = TL , we have m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L ) · H. (9) Combining (8) and (9), we get that np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L .",
                "Lemma 5.12 Algorithm 2 satisfies cycle monotonicity.",
                "Proof.",
                "Taking p1 = pk and p2 = pk+1 in (7), we get that npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L .",
                "Summing this over all k = 1, . . . , K (where K + 1 ≡ 1) yields (6). 5.3 Computation of prices Lemmas 5.7 and 5.12 show that our algorithm is a 2approximation algorithm that satisfies cycle monotonicity.",
                "Thus, by the discussion in Section 3, there exist prices that yield a truthful mechanism.",
                "To obtain a polynomial-time mechanism, we also need to show how to compute these prices (or payments) in polynomial-time.",
                "It is not clear, if the procedure outlined in Section 3 based on computing shortest paths in the allocation graph yields a polynomial time algorithm, since the allocation graph has an exponential number of nodes (one for each output assignment).",
                "Instead of analyzing the allocation graph, we will leverage our proof of cycle monotonicity, in particular, inequality (7), and simply spell out the payments.",
                "Recall that the utility of a player is ui = Pi − li, where Pi is the payment made to player i.",
                "For convenience, we will first specify negative payments (i.e., the Pis will actually be prices charged to the players) and then show that these can be modified so that players have non-negative utilities (if they act truthfully).",
                "Let Hi denote the number of jobs assigned to machine i in step 3.",
                "By Corollary 5.6, we know that all these jobs are assigned to high machines (according to the declared pis).",
                "Let H−i = P i =i Hi and n−i p,T = P i =i ni p,T .",
                "The payment Pi to player i is defined as: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10) We can interpret our payments as equating the players cost to a careful modification of the total load (in the spirit of VCG prices).",
                "The first and second terms in (10), when subtracted from is load li equate is cost to the total load.",
                "The term np,T ∗(p) − np,T L i (p−i) is in fact equal to n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) since the low-load on i is at most TL i (p−i) (by Claim 5.9).",
                "Thus the last term in equation (10) implies that we treat the low jobs that were assigned beyond the TL i (p−i) threshold (to machines other than i) effectively as high jobs for the total utility calculation from is point of view.",
                "It is not clear how one could have conjured up these payments a priori in order to prove the truthfulness of our algorithm.",
                "However, by relying on cycle monotonicity, we were not only able to argue the existence of payments, but also our proof paved the way for actually inferring these payments.",
                "The following lemma explicitly verifies that the payments defined above do indeed give a truthful mechanism.",
                "Lemma 5.13 Fix a player i and the other players declarations p−i.",
                "Let is true type be p1 i .",
                "Then, under the payments defined in (10), is utility when she declares her true type p1 i is at least her utility when she declares any other type p2 i .",
                "Proof.",
                "Let c1 i , c2 i denote is total cost, defined as the negative of her utility, when she declares p1 , and p2 , respectively (and the others declare p−i).",
                "Since p−i is fixed, we omit p−i from the expressions below for notational clarity.",
                "The true load of i when she declares her true type p1 i is L · ni p1,T ∗(p1) + H · Hi (p1 ), and therefore c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) On the other hand, is true load when she declares p2 i is L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L ) + H · (Hi + n2,1 H − n2,1 L ) (since is true processing time vector is p1 i ), and thus c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L .",
                "Thus, (7) implies that c1 i ≤ c2 i .",
                "Price specifications are commonly required to satisfy, in addition to truthfulness, individual rationality, i.e., a players utility should be non-negative if she reveals her true value.",
                "The payments given by (10) are not individually rational as they actually charge a player a certain amount.",
                "However, it is well-known that this problem can be easily solved by adding a large-enough constant to the price definition.",
                "In our case, for example, letting H denote the vector of all Hs, we can add the term n·H −(H −L)n(H,p−i),T L i (p−i) to (10).",
                "Note that this is a constant for player i.",
                "Thus, the new payments are Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ .",
                "As shown by (11), this will indeed result in a non-negative utility for i (since n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) for any type pi of player i).",
                "This modification also ensures the additionally desired normalization property that if a player receives no jobs then she receives zero payment: if player i receives the empty set for some type pi then she will also receive the empty set for the type H (this is easy to verify for our specific algorithm), and for the type H, her utility equals zero; thus, by truthfulness this must also be the utility of every other declaration that results in i receiving the empty set.",
                "This completes the proof of Theorem 5.3. 260 5.4 Impossibility of exact implementation We now show that irrespective of computational considerations, there does not exist a cycle-monotone algorithm for the L-H case with an approximation ratio better than 1.14.",
                "Let H = α·L for some 2 < α < 2.5 that we will choose later.",
                "There are two machines I, II and seven jobs.",
                "Consider the following two scenarios: Scenario 1.",
                "Every job has the same processing time on both machines: jobs 1-5, are L, and jobs 6, 7 are H. Any optimal <br>schedule</br> assigns jobs 1-5 to one machine and jobs 6, 7 to the other, and has makespan OPT1 = 5L.",
                "The secondbest <br>schedule</br> has makespan at least Second1 = 2H + L. Scenario 2.",
                "If the algorithm chooses an optimal <br>schedule</br> for scenario 1, assume without loss of generality that jobs 6, 7 are assigned to machine II.",
                "In scenario 2, machine I has the same processing-time vector.",
                "Machine II lowers jobs 6, 7 to L and increases 1-5 to H. An optimal <br>schedule</br> has makespan 2L + H, where machine II gets jobs 6, 7 and one of the jobs 1-5.",
                "The second-best <br>schedule</br> for this scenario has makespan at least Second2 = 5L.",
                "Theorem 5.14 No deterministic truthful mechanism for the two-value scheduling problem can obtain an approximation ratio better than 1.14.",
                "Proof.",
                "We first argue that a cycle-monotone algorithm cannot choose the optimal <br>schedule</br> in both scenarios.",
                "This follows because otherwise cycle monotonicity is violated for machine II.",
                "Taking p1 II , p2 II to be machine IIs processingtime vectors for scenarios 1, 2 respectively, we get P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0.",
                "Thus, any truthful mechanism must return a sub-optimal makespan in at least one scenario, and therefore its approximation ratio is at least min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 for α = 2.364.",
                "We remark that for the {Lj, Hj}-case where there is a common ratio r = Hj Lj for all jobs (this generalizes the restricted-machines setting) one can obtain a fractional truthful mechanism (with efficiently computable prices) that returns a <br>schedule</br> of makespan at most OPT(p) for every p. One can view each job j as consisting of Lj sub-jobs of size 1 on a machine i if pij = Lj, and size r if pij = Hj.",
                "For this new instance ˜p, note that ˜pij ∈ {1, r} for every i, j.",
                "Notice also that any assignment ˜x for the instance ˜p translates to a fractional assignment x for p, where pijxij =P j : sub-job of j ˜pij ˜xij .",
                "Thus, if we use Algorithm 2 to obtain a <br>schedule</br> for the instance ˜p, equation (6) translates precisely to (3) for the assignment x; moreover, the prices for ˜p translate to prices for the instance p. The number of sub-jobs assigned to low-machines in the flow-phase is simply the total work assigned to low-machines.",
                "Thus, we can implement the above reduction by setting up a max-flow problem that seems to maximize the total work assigned to low machines.",
                "Moreover, since we have a fractional domain, we can use a more efficient greedy rule for packing the unassigned portions of jobs and argue that the fractional assignment has makespan at most OPT(p).",
                "The assignment x need not however satisfy the condition that xij > 0 implies pij ≤ OPT(p) for arbitrary r, therefore, the rounding procedure of Lemma 4.2 does not yield a 2-approximation truthful-in-expectation mechanism.",
                "But if r > OPT(p) (as in the restricted-machines setting), this condition does hold, so we get a 2-approximation truthful mechanism.",
                "Acknowledgments We thank Elias Koutsoupias for his help in refining the analysis of the lower bound in Section 5.4, and the reviewers for their helpful comments. 6.",
                "REFERENCES [1] N. Andelman, Y. Azar, and M. Sorani.",
                "Truthful approximation mechanisms for scheduling selfish related machines.",
                "In Proc. 22nd STACS, 69-82, 2005. [2] A. Archer.",
                "Mechanisms for discrete optimization with rational agents.",
                "PhD thesis, Cornell University, 2004. [3] A. Archer and ´E.",
                "Tardos.",
                "Truthful mechanisms for one-parameter agents.",
                "In Proc. 42nd FOCS, pages 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna, and G. Persiano.",
                "Deterministic truthful approximation mechanisms for scheduling related machines.",
                "In Proc. 21st STACS, pages 608-619, 2004. [5] I. Bez´akov´a and V. Dani.",
                "Allocating indivisible goods.",
                "In ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan, and A. Sen. Weak monotonicity characterizes deterministic dominant-strategy implementation.",
                "Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta, and B. Vocking.",
                "Approximation techniques for utilitarian mechanism design.",
                "In Proc. 37th STOC, pages 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias, and A. Vidali.",
                "A lower bound for scheduling mechanisms.",
                "In Proc. 18th SODA, pages 1163-1170, 2007. [9] E. Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 8:17-33, 1971. [10] T. Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, and R. V. Vohra.",
                "Characterizing dominant strategy mechanisms with multi-dimensional types, 2004.",
                "Working paper. [12] L. A.",
                "Hall.",
                "Approximation algorithms for scheduling.",
                "In D. Hochbaum, editor, Approximation Algorithms for NP-Hard Problems.",
                "PWS Publishing, MA, 1996. [13] A. Kov´acs.",
                "Fast monotone 3-approximation algorithm for scheduling related machines.",
                "In Proc. 13th ESA, pages 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy, and A. Srinivasan.",
                "Approximation algorithms for scheduling on multiple machines.",
                "In Proc. 46th FOCS, pages 254-263, 2005. [15] R. Lavi, A. Mualem, and N. Nisan.",
                "Towards a characterization of truthful combinatorial auctions.",
                "In Proc. 44th FOCS, pages 574-583, 2003. [16] R. Lavi and C. Swamy.",
                "Truthful and near-optimal mechanism design via linear programming.",
                "In Proc. 46th FOCS, pages 595-604, 2005. [17] D. Lehmann, L. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of the ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, and ´E.",
                "Tardos.",
                "Approximation algorithms for scheduling unrelated parallel machines.",
                "Math.",
                "Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi.",
                "On approximately fair allocations of indivisible goods.",
                "In Proc. 5th EC, pages 125-131, 2004. [20] A. Mualem and M. Schapira.",
                "Setting lower bounds on truthfulness.",
                "In Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson.",
                "Optimal auction design.",
                "Mathematics of Operations Research, 6:58-73, 1981. [22] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Econ.",
                "Behavior, 35:166-196, 2001. [23] J. C. Rochet.",
                "A necessary and sufficient condition for rationalizability in a quasilinear context.",
                "Journal of Mathematical Economics, 16:191-200, 1987. [24] M. Saks and L. Yu.",
                "Weak monotonicity suffices for truthfulness on convex domains.",
                "In Proc. 6th EC, pages 286-293, 2005. [25] D. B. Shmoys and ´E.",
                "Tardos.",
                "An approximation algorithm for the generalized assignment problem.",
                "Mathematical Programming, 62:461-474, 1993. [26] W. Vickrey.",
                "Counterspeculations, auctions, and competitive sealed tenders.",
                "J.",
                "Finance, 16:8-37, 1961. 261"
            ],
            "original_annotated_samples": [
                "Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to <br>schedule</br> the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the <br>schedule</br>.",
                "Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a <br>schedule</br>, suitable payments to the players in order to incentivize them to reveal their true processing times.",
                "The gap between the single-dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal <br>schedule</br>. (Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.)",
                "Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal <br>schedule</br> (unlike in the case of related machines).",
                "Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional <br>schedule</br>."
            ],
            "translated_annotated_samples": [
                "Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario.",
                "Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un <br>horario</br>, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento.",
                "La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un <br>horario</br> óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2).",
                "Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un <br>horario</br> óptimo (a diferencia del caso de máquinas relacionadas).",
                "Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un <br>horario</br> fraccional."
            ],
            "translated_text": "Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un <br>horario</br>, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un <br>horario</br> óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un <br>horario</br> óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un <br>horario</br> fraccional. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}