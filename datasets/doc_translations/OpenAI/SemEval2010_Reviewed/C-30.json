{
    "id": "C-30",
    "original_text": "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet. Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network. In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers. Applications include large-file transfers and real-time multimedia streaming. For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures. This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh. We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network. Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel. Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances. In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing. In a tree, it is critical that a nodes parent delivers a high rate of application data to each child. In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1. INTRODUCTION In this paper, we consider the following general problem. Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers? Our problem domain includes software or video distribution and real-time multimedia streaming. Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion. However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast. Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree. More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery. Typical overlay structures attempt to mimic the structure of multicast routing trees. In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility. Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree. Overlays have shown tremendous promise for multicast-style applications. However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability. One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree. Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree. A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6]. However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree. Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined. Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network. Here, the sender splits data into sequential blocks. Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network. Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects. We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants. In this way, we avoid the problem of locating the last object, which may only be available at a few nodes. One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure. To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B. However, there is also 1 Mbps of available bandwidth between A and B. In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B. A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps. On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data. Any solution for achieving the above model must maintain a number of properties. First, it must be TCP friendly [15]. No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate. Second, it must impose low control overhead. There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources. Third, the algorithm should be decentralized and scalable to thousands of participants. No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes. Finally, the approach must be robust to individual failures. For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree. In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties. Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34]. Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants. The level of disjointness is determined by the bandwidth available to each of its children. Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node. Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree. Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses. Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers. This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions. One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree. One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol. In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent). Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions. While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results. Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system. Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree. Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh. We have completed a prototype of Bullet running on top of a number of overlay trees. Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly. We also deployed our prototype across the PlanetLab [31] wide-area testbed. For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements. In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios. The remainder of this paper is organized as follows. Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC. Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications. Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques. Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2. SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1. First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects. Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient. Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client. We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner. Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree. Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree. Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers. In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree. In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent. However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit. Locating appropriate remote peers cannot require global state or global communication. Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period. This random subset contains summary tickets of the objects available at a subset of the nodes in the system. Each node uses this information to request data objects from remote nodes that have significant divergence in object membership. It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it. In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work. Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency. For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream. For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet. Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream. Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system. In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach. Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets. Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05. In return, they provide significantly faster encoding and decoding times. Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived. Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree. RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree. A number of such techniques are described in [1, 18, 21, 24, 34]. RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages. Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root. Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants. Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch. The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree. For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness. As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children. The contents of the distribute set are constructed using the collect set gathered during the previous collect phase. During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants. After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch. One of the key features of RanSub is the Compact operation. This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node. Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset. The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch. The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root. The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members. RanSub offers several ways of constructing distribute sets. For our system, we choose the RanSub-nondescendants option. In this case, each node receives a random subset consisting of all nodes excluding its descendants. This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases. A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set. The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child. We depict an example of RanSubs collect-distribute process in Figure 2. In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data. Additionally, we require a bandwidth-efficient method with low computational overhead. We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet. To describe the content, nodes maintain working sets. The working set contains sequence numbers of packets that have been successfully received by each node over some period of time. We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial. Summary tickets, or min-wise sketches [5], serve this purpose. The main idea is to create a summary ticket that is an unbiased random sample of the working set. A summary ticket is a small fixed-size array. Each entry in this array is maintained by a specific permutation function. The goal is to have each entry populated by the element with the smallest permuted value. To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate. The permutation function can be thought of as a specialized hash function. The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions. Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme). To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets. Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set. To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest. For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions. An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values. To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set. If at least one is not set, we know that the Bloom filter does not contain x. When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero. In this case, we have a false positive. Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it. On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives. The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k . We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe. TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15]. TCP halves the sending rate as soon as one packet loss is detected. Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time. Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion. To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC. The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds. TFRC senders and receivers must cooperate to achieve a smooth transmission rate. The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O. In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP. The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver. The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver. Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start. The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets. To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals. A loss interval is defined as the number of packets received correctly between two loss events. The array is continually updated as losses are detected. A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC. We wanted a transport protocol that was congestion aware and TCP friendly. Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender. Hence, we eliminate retransmissions from TFRC. Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links. For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree. By using TFRC we were able to avoid these scenarios. 3. BULLET Bullet is an efficient data distribution system for bandwidth intensive applications. While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree. Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay. This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node. Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent. While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay. As a result, Bullet is capable of functioning on top of essentially any overlay tree. In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge). Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay. As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC. For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery. For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers. Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay. Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth. RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains. RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default). Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers. Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far. Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it. This allows us to keep the Bloom filter population n from growing at an unbounded rate. The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate. Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket. We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree. In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet. Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs. In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies. In essence, during an epoch a node receives a summarized partial view of the systems state at that time. Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket. This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4). Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter. Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver. Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node. The requesting node will refresh its installed Bloom filters at each of its sending peers periodically. Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders. In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources. A node divides the sequence space in its current working set among each of its senders uniformly. As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers. A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter. This identifies the range of packets that the receiver is currently interested in recovering. Over time, this range shifts as depicted in Figure 4-b). In addition, the receiving node assigns to each sender a row from the matrix, labeled mod. A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has. It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number. In this fashion, receivers register to receive disjoint data from their sending peers. By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth. A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants). In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers. In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents. We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover. Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied. This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained. On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability. In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network. Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network. As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data. If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems. In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport. If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child. In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes. That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet. While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost. To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same. A node p maintains for each child, i, a limiting and sending factor, lfi and sfi. These factors determine the proportion of ps received data rate that it will forward to each child. The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has. The more descendants a child has, the larger the portion of received data it should own. The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle. For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor. Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it. Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children. For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj . In addition, a node tracks the data successfully transmitted via the transport. That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport. If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt. When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch. It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5. Having chosen the target of a particular packet, the parent attempts to forward the packet to the child. If the send is not successful, the node must find an alternate child to own the packet. This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi). To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet). The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth. In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream. While making data more difficult to recover, Bullet still allows for recovery of such data to its children. The sending node will cache the data packet and serve it to its requesting peers. This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available. Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi. For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero. Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each. If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch. If the transmission fails, lfi is decreased by the same amount. This allows children limiting factors to be continuously adjusted in response to changing network conditions. It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream. In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns. In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0. In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships. That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation). A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing. For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data. In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility. Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers. A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received. This threshold is set to 50% by default. If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it. It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list. In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions. Likewise, a Bullet sender will periodically evaluate its receivers. Each receiver updates senders of the total received bandwidth. The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender. This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender. The sender drops this receiver, creating an empty slot for some other trial receiver. This is similar to the concept of weans presented in [24]. 4. EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework. While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31]. In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute. Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1. All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language. It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment. As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies. Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure. Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches. For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine). In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology. In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators. This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts. For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10]. We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology. We randomly select one of these participants to act as the source of the data stream. Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET. Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network. We restrict topological bandwidth by setting the bandwidth for each link depending on its type. Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random. By changing these ranges, we vary bandwidth constraints in our topologies. For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1. While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior. We do not implement any particular coding scheme for our experiments. Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology. This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree. While we have not yet proven this, we believe that this problem is NP-hard. Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth. In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm. At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming). In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps. Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes? We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree. We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link. Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT). In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23]. In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses. For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates. We make the following assumptions: 1. The routing path between any two overlay participants is fixed. This closely models the existing overlay network model with IP for unicast routing. 2. The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3. In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4. When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link. Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay. We start by calculating the throughput using the steady-state formula. We then route the flow in the network, and consider the physical links one at a time. On each physical link, we compute the fair-share for each of the competing flows. The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate. If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute. We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links. More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT). Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)). We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1). Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm. This algorithm is non-optimal, but a similar approach was found to perform well [12]. Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32]. During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes. To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes. We greedily pick the node with the highest throughput overlay link. Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows. Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated. However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing. With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree. In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP. Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis. In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior). In these experiments, streaming begins 100 seconds into each run. While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data. For this experiment, bandwidths were set to the medium range from Table 1. We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay. Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm. To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6. Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation. The graph also plots the total amount of data received and the amount of data a node receives from its parent. For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm. Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources. Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout. The average per-node control overhead is approximately 30 Kbps. By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system. Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet. For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22. The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links. We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity. A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives. The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained. The distribution rises sharply starting at approximately 500 Kbps. The vast majority of nodes receive a stream of 500-600 Kbps. We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology. Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps. The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted. Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range. In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology. In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example). In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree. For all other topologies, Bullets benefits are somewhere in between. In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%. Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information. For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21]. The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy. That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated. A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree. It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits. Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links). Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance). By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing. We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view. This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]). We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission. We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree. The idea here is that nodes are expected to obtain most of their data from their parent. Nodes then attempt to retrieve any missing data items through gossiping with random peers. Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items. To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership. While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree. Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc. To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10). For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead. In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system. To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds. For these experiments, we use a 5000-node INET topology with no explicit physical link losses. We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants. The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping. Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches. As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy. The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node. More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio. Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses. ModelNet allows the specification of a packet loss rate in the description of a network link. Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic. To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%. Transit links are likewise modified, but with a maximum loss rate of 0.1%. Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%. Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree. Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network. In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree. Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure. In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming. While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage. Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree. For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery. In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started. By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure. In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers. That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run. Figure 13 shows Bullets achieved bandwidth over time for this case. While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate. Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test). In this case, the root simply initiates the next distribute phase upon RanSub timeout. The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions. As shown in Figure 14, the failure causes a negligible disruption in performance. With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data. Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure. Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed. For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site. Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd. We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth. The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe. Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison. We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps. We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree. We compare the performance of Bullet to data streaming over multiple handcrafted trees. Figure 15 shows our results for two such trees. The good tree has all nodes in Europe located high in the tree, close to the root. We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes. Nodes with high bandwidth measurements were placed close to the root. In this case, we are able to achieve a bandwidth of approximately 300 Kbps. The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload. All subsequent levels in the tree were set in this fashion. For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics. As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case. A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5. RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data. In this system, every node chooses n parents from which to receive duplicate packet streams. Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level. Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number. The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network. Kazaa nodes are organized into a scalable, hierarchical structure. Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it. Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure. Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet. It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file. The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file. Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date. Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns. Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source. FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs). In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node. To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members. Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution. However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system. Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming. There are numerous protocols that aim to add reliability to IP multicast. In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets. Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups. However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used. One recent study [2] shows that SRM may have significant overhead due to retransmission requests. Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree. In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets. A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion. Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node. The average size of the views is engineered to allow a message to reach all participants with high probability. Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high. Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers. Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content. Further, a Bullet node splits the retransmission load between all of its peers. We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest. However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates. More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree. Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links. It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source. Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes. Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent. On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers. Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm. In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth. Bullet is expected to be more resilient to node departures than any tree, including Overcast. Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers. This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters. Overcast convergence time is limited by probes to immediate siblings and ancestors. Bullet is able to provide approximately a target bandwidth without having a fully converged tree. In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination. It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34]. The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system. The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe. Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe. To some extent, Bullet and SplitStream are complementary. For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe. CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn. Consequently, the system favors resilience over network efficiency. It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers. In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content. Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6. CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree. In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth. Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers. This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures. Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming. As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner. RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree. Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations. In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7. REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy. Scalable Application Layer Multicast. In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky. Bimodal Multicast. ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Space/Time Trade-offs in Hash Coding with Allowable Errors. Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder. On the Resemblance and Containment of Documents. In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost. Informed Content Delivery Across Adaptive Overlay Networks. In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege. A Digital Fountain Approach to Reliable Distribution of Bulk Data. In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura. Modeling Internet Topology. IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh. Splitstream: High-bandwidth Content Distribution in Cooperative Environments. In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger. Towards Capturing Representative AS-Level Internet Topologies. In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee. FastReplica: Efficient Large File Distribution within Content Delivery Networks. In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer. A Unicast-based Approach for Streaming Multicast. In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov. Lightweight Probabilistic Broadcast. To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov. Lightweight Probabilistic Broadcast. In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer. Equation-based congestion control for unicast applications. In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang. A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Multiple Description Coding: Compression Meets the Network. IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang. A Case For End System Multicast. In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang. Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture. In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis. End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput. In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole. Overcast: Reliable Multicasting with an Overlay Network. In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media. Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat. Using Random Subsets to Build Scalable Network Services. In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby. LT Codes. In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann. Practical Loss-Resilient Codes. In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997. Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe. Modeling TCP Throughput: A Simple Model and its Empirical Validation. In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang. Server-based Inference of Internet Link Lossiness. In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou. Resilient Peer-to-Peer Streaming. In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai. Distributing Streaming Media Content Using Cooperative Networking. In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe. A Blueprint for Introducing Disruptive Technology into the Internet. In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim. Shortest Connection Networks and Some Generalizations. In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat. MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks. Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel. SCRIBE: The Design of a Large-scale Event Notification Infrastructure. In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage. Sting: A TCP-based Network Measurement Tool. In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999. USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford. Mesh-Based Content Routing Using XML. In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker. Scalability and Accuracy in a Large-Scale Network Emulator. In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297",
    "original_translation": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297",
    "original_sentences": [
        "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
        "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
        "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
        "Applications include large-file transfers and real-time multimedia streaming.",
        "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
        "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
        "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
        "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
        "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
        "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
        "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
        "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
        "INTRODUCTION In this paper, we consider the following general problem.",
        "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
        "Our problem domain includes software or video distribution and real-time multimedia streaming.",
        "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
        "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
        "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
        "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
        "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
        "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
        "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
        "Overlays have shown tremendous promise for multicast-style applications.",
        "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
        "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
        "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
        "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
        "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
        "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
        "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
        "Here, the sender splits data into sequential blocks.",
        "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
        "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
        "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
        "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
        "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
        "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
        "However, there is also 1 Mbps of available bandwidth between A and B.",
        "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
        "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
        "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
        "Any solution for achieving the above model must maintain a number of properties.",
        "First, it must be TCP friendly [15].",
        "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
        "Second, it must impose low control overhead.",
        "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
        "Third, the algorithm should be decentralized and scalable to thousands of participants.",
        "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
        "Finally, the approach must be robust to individual failures.",
        "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
        "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
        "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
        "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
        "The level of disjointness is determined by the bandwidth available to each of its children.",
        "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
        "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
        "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
        "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
        "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
        "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
        "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
        "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
        "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
        "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
        "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
        "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
        "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
        "We have completed a prototype of Bullet running on top of a number of overlay trees.",
        "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
        "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
        "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
        "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
        "The remainder of this paper is organized as follows.",
        "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
        "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
        "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
        "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
        "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
        "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
        "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
        "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
        "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
        "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
        "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
        "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
        "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
        "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
        "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
        "Locating appropriate remote peers cannot require global state or global communication.",
        "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
        "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
        "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
        "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
        "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
        "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
        "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
        "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
        "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
        "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
        "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
        "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
        "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
        "In return, they provide significantly faster encoding and decoding times.",
        "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
        "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
        "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
        "A number of such techniques are described in [1, 18, 21, 24, 34].",
        "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
        "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
        "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
        "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
        "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
        "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
        "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
        "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
        "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
        "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
        "One of the key features of RanSub is the Compact operation.",
        "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
        "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
        "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
        "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
        "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
        "RanSub offers several ways of constructing distribute sets.",
        "For our system, we choose the RanSub-nondescendants option.",
        "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
        "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
        "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
        "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
        "We depict an example of RanSubs collect-distribute process in Figure 2.",
        "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
        "Additionally, we require a bandwidth-efficient method with low computational overhead.",
        "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
        "To describe the content, nodes maintain working sets.",
        "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
        "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
        "Summary tickets, or min-wise sketches [5], serve this purpose.",
        "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
        "A summary ticket is a small fixed-size array.",
        "Each entry in this array is maintained by a specific permutation function.",
        "The goal is to have each entry populated by the element with the smallest permuted value.",
        "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
        "The permutation function can be thought of as a specialized hash function.",
        "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
        "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
        "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
        "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
        "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
        "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
        "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
        "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
        "If at least one is not set, we know that the Bloom filter does not contain x.",
        "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
        "In this case, we have a false positive.",
        "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
        "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
        "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
        "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
        "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
        "TCP halves the sending rate as soon as one packet loss is detected.",
        "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
        "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
        "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
        "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
        "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
        "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
        "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
        "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
        "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
        "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
        "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
        "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
        "A loss interval is defined as the number of packets received correctly between two loss events.",
        "The array is continually updated as losses are detected.",
        "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
        "We wanted a transport protocol that was congestion aware and TCP friendly.",
        "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
        "Hence, we eliminate retransmissions from TFRC.",
        "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
        "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
        "By using TFRC we were able to avoid these scenarios. 3.",
        "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
        "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
        "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
        "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
        "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
        "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
        "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
        "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
        "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
        "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
        "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
        "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
        "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
        "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
        "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
        "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
        "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
        "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
        "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
        "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
        "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
        "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
        "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
        "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
        "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
        "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
        "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
        "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
        "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
        "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
        "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
        "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
        "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
        "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
        "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
        "A node divides the sequence space in its current working set among each of its senders uniformly.",
        "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
        "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
        "This identifies the range of packets that the receiver is currently interested in recovering.",
        "Over time, this range shifts as depicted in Figure 4-b).",
        "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
        "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
        "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
        "In this fashion, receivers register to receive disjoint data from their sending peers.",
        "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
        "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
        "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
        "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
        "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
        "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
        "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
        "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
        "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
        "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
        "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
        "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
        "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
        "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
        "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
        "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
        "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
        "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
        "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
        "These factors determine the proportion of ps received data rate that it will forward to each child.",
        "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
        "The more descendants a child has, the larger the portion of received data it should own.",
        "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
        "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
        "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
        "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
        "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
        "In addition, a node tracks the data successfully transmitted via the transport.",
        "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
        "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
        "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
        "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
        "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
        "If the send is not successful, the node must find an alternate child to own the packet.",
        "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
        "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
        "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
        "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
        "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
        "The sending node will cache the data packet and serve it to its requesting peers.",
        "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
        "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
        "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
        "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
        "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
        "If the transmission fails, lfi is decreased by the same amount.",
        "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
        "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
        "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
        "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
        "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
        "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
        "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
        "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
        "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
        "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
        "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
        "This threshold is set to 50% by default.",
        "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
        "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
        "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
        "Likewise, a Bullet sender will periodically evaluate its receivers.",
        "Each receiver updates senders of the total received bandwidth.",
        "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
        "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
        "The sender drops this receiver, creating an empty slot for some other trial receiver.",
        "This is similar to the concept of weans presented in [24]. 4.",
        "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
        "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
        "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
        "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
        "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
        "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
        "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
        "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
        "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
        "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
        "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
        "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
        "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
        "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
        "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
        "We randomly select one of these participants to act as the source of the data stream.",
        "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
        "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
        "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
        "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
        "By changing these ranges, we vary bandwidth constraints in our topologies.",
        "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
        "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
        "We do not implement any particular coding scheme for our experiments.",
        "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
        "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
        "While we have not yet proven this, we believe that this problem is NP-hard.",
        "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
        "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
        "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
        "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
        "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
        "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
        "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
        "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
        "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
        "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
        "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
        "We make the following assumptions: 1.",
        "The routing path between any two overlay participants is fixed.",
        "This closely models the existing overlay network model with IP for unicast routing. 2.",
        "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
        "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
        "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
        "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
        "We start by calculating the throughput using the steady-state formula.",
        "We then route the flow in the network, and consider the physical links one at a time.",
        "On each physical link, we compute the fair-share for each of the competing flows.",
        "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
        "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
        "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
        "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
        "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
        "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
        "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
        "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
        "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
        "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
        "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
        "We greedily pick the node with the highest throughput overlay link.",
        "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
        "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
        "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
        "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
        "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
        "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
        "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
        "In these experiments, streaming begins 100 seconds into each run.",
        "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
        "For this experiment, bandwidths were set to the medium range from Table 1.",
        "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
        "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
        "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
        "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
        "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
        "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
        "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
        "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
        "The average per-node control overhead is approximately 30 Kbps.",
        "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
        "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
        "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
        "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
        "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
        "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
        "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
        "The distribution rises sharply starting at approximately 500 Kbps.",
        "The vast majority of nodes receive a stream of 500-600 Kbps.",
        "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
        "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
        "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
        "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
        "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
        "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
        "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
        "For all other topologies, Bullets benefits are somewhere in between.",
        "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
        "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
        "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
        "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
        "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
        "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
        "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
        "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
        "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
        "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
        "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
        "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
        "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
        "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
        "The idea here is that nodes are expected to obtain most of their data from their parent.",
        "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
        "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
        "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
        "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
        "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
        "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
        "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
        "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
        "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
        "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
        "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
        "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
        "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
        "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
        "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
        "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
        "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
        "ModelNet allows the specification of a packet loss rate in the description of a network link.",
        "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
        "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
        "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
        "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
        "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
        "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
        "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
        "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
        "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
        "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
        "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
        "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
        "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
        "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
        "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
        "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
        "Figure 13 shows Bullets achieved bandwidth over time for this case.",
        "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
        "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
        "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
        "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
        "As shown in Figure 14, the failure causes a negligible disruption in performance.",
        "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
        "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
        "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
        "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
        "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
        "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
        "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
        "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
        "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
        "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
        "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
        "Figure 15 shows our results for two such trees.",
        "The good tree has all nodes in Europe located high in the tree, close to the root.",
        "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
        "Nodes with high bandwidth measurements were placed close to the root.",
        "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
        "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
        "All subsequent levels in the tree were set in this fashion.",
        "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
        "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
        "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
        "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
        "In this system, every node chooses n parents from which to receive duplicate packet streams.",
        "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
        "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
        "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
        "Kazaa nodes are organized into a scalable, hierarchical structure.",
        "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
        "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
        "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
        "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
        "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
        "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
        "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
        "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
        "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
        "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
        "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
        "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
        "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
        "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
        "There are numerous protocols that aim to add reliability to IP multicast.",
        "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
        "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
        "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
        "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
        "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
        "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
        "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
        "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
        "The average size of the views is engineered to allow a message to reach all participants with high probability.",
        "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
        "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
        "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
        "Further, a Bullet node splits the retransmission load between all of its peers.",
        "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
        "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
        "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
        "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
        "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
        "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
        "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
        "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
        "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
        "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
        "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
        "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
        "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
        "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
        "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
        "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
        "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
        "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
        "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
        "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
        "To some extent, Bullet and SplitStream are complementary.",
        "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
        "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
        "Consequently, the system favors resilience over network efficiency.",
        "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
        "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
        "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
        "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
        "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
        "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
        "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
        "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
        "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
        "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
        "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
        "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
        "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
        "Scalable Application Layer Multicast.",
        "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
        "Bimodal Multicast.",
        "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
        "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
        "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
        "On the Resemblance and Containment of Documents.",
        "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
        "Informed Content Delivery Across Adaptive Overlay Networks.",
        "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
        "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
        "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
        "Modeling Internet Topology.",
        "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
        "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
        "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
        "Towards Capturing Representative AS-Level Internet Topologies.",
        "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
        "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
        "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
        "A Unicast-based Approach for Streaming Multicast.",
        "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
        "Lightweight Probabilistic Broadcast.",
        "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
        "Lightweight Probabilistic Broadcast.",
        "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
        "Equation-based congestion control for unicast applications.",
        "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
        "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
        "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
        "Multiple Description Coding: Compression Meets the Network.",
        "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
        "A Case For End System Multicast.",
        "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
        "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
        "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
        "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
        "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
        "Overcast: Reliable Multicasting with an Overlay Network.",
        "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
        "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
        "Using Random Subsets to Build Scalable Network Services.",
        "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
        "LT Codes.",
        "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
        "Practical Loss-Resilient Codes.",
        "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
        "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
        "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
        "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
        "Server-based Inference of Internet Link Lossiness.",
        "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
        "Resilient Peer-to-Peer Streaming.",
        "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
        "Distributing Streaming Media Content Using Cooperative Networking.",
        "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
        "A Blueprint for Introducing Disruptive Technology into the Internet.",
        "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
        "Shortest Connection Networks and Some Generalizations.",
        "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
        "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
        "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
        "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
        "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
        "Sting: A TCP-based Network Measurement Tool.",
        "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
        "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
        "Mesh-Based Content Routing Using XML.",
        "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
        "Scalability and Accuracy in a Large-Scale Network Emulator.",
        "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
    ],
    "translated_text_sentences": [
        "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet.",
        "Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente.",
        "En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores.",
        "Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real.",
        "Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas.",
        "Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda.",
        "Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red.",
        "Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo.",
        "Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias.",
        "Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas.",
        "En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo.",
        "En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión.",
        "Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1.",
        "INTRODUCCIÓN En este documento, consideramos el siguiente problema general.",
        "Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores?",
        "Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real.",
        "Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable.",
        "Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP.",
        "Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución.",
        "Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red.",
        "Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast.",
        "En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad.",
        "Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol.",
        "Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión.",
        "Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad.",
        "Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol.",
        "Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol.",
        "Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6].",
        "Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol.",
        "Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado.",
        "En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red.",
        "Aquí, el remitente divide los datos en bloques secuenciales.",
        "Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red.",
        "Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes.",
        "Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición.",
        "De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos.",
        "Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo.",
        "Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B.",
        "Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B.",
        "En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B.",
        "A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps.",
        "Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos.",
        "Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades.",
        "Primero, debe ser amigable con TCP [15].",
        "Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión.",
        "Segundo, debe imponer una baja sobrecarga de control.",
        "Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes.",
        "Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes.",
        "Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos.",
        "Finalmente, el enfoque debe ser robusto ante fallos individuales.",
        "Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión.",
        "En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente.",
        "Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34].",
        "Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes.",
        "El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos.",
        "Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo.",
        "Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario.",
        "Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas.",
        "Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares.",
        "Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes.",
        "Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente.",
        "Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol.",
        "En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre).",
        "Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente.",
        "Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados.",
        "Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema.",
        "Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda.",
        "Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet.",
        "Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos.",
        "Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP.",
        "También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31].",
        "Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda.",
        "En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo.",
        "El resto de este documento está organizado de la siguiente manera.",
        "La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC.",
        "La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda.",
        "La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes.",
        "La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones.",
        "COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1.",
        "Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete).",
        "Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos.",
        "A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente.",
        "Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP.",
        "Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición.",
        "Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol.",
        "Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares.",
        "En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol.",
        "En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre.",
        "Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo.",
        "Localizar pares remotos adecuados no puede requerir un estado global o comunicación global.",
        "Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable.",
        "Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema.",
        "Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos.",
        "Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él.",
        "En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo.",
        "La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema.",
        "Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable.",
        "Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido.",
        "Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos.",
        "Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema.",
        "En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7].",
        "Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales.",
        "Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05.",
        "A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos.",
        "Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes.",
        "Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición.",
        "RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente.",
        "Un número de tales técnicas se describen en [1, 18, 21, 24, 34].",
        "RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución.",
        "Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz.",
        "Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes.",
        "Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época.",
        "El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol.",
        "Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección.",
        "Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos.",
        "Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior.",
        "Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes.",
        "Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época.",
        "Una de las características clave de RanSub es la operación compacta.",
        "Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo.",
        "Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo.",
        "La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época.",
        "La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz.",
        "La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada.",
        "RanSub ofrece varias formas de construir conjuntos distribuidos.",
        "Para nuestro sistema, elegimos la opción RanSub-no descendientes.",
        "En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes.",
        "Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos.",
        "Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución.",
        "El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular.",
        "Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2.",
        "En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos.",
        "Además, necesitamos un método eficiente en ancho de banda con baja carga computacional.",
        "Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet.",
        "Para describir el contenido, los nodos mantienen conjuntos de trabajo.",
        "El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo.",
        "Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa.",
        "Los tickets de resumen, o bocetos min-wise, cumplen con este propósito.",
        "La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo.",
        "Un boleto de resumen es una matriz de tamaño fijo pequeño.",
        "Cada entrada en este arreglo es mantenida por una función de permutación específica.",
        "El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño.",
        "Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda.",
        "La función de permutación se puede considerar como una función hash especializada.",
        "La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación.",
        "Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos).",
        "Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen.",
        "La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo.",
        "Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen.",
        "Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes.",
        "Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash.",
        "Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas.",
        "Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x.",
        "Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero.",
        "En este caso, tenemos un falso positivo.",
        "Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando.",
        "Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos.",
        "La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k.",
        "Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa.",
        "El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15].",
        "TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes.",
        "Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta.",
        "A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión.",
        "Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC.",
        "La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos.",
        "Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida.",
        "El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O.",
        "En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP.",
        "El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor.",
        "El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor.",
        "Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento.",
        "El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación.",
        "Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida.",
        "Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida.",
        "La matriz se actualiza continuamente a medida que se detectan pérdidas.",
        "Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC.",
        "Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP.",
        "Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial.",
        "Por lo tanto, eliminamos las retransmisiones de TFRC.",
        "Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces.",
        "Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol.",
        "Al utilizar TFRC pudimos evitar estos escenarios.",
        "BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda.",
        "Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol.",
        "Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición.",
        "Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor.",
        "Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos.",
        "Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición.",
        "Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición.",
        "En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global).",
        "Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición.",
        "Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC.",
        "Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden.",
        "Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes.",
        "Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición.",
        "Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda.",
        "Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo.",
        "RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto).",
        "Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia.",
        "Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento.",
        "Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él.",
        "Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada.",
        "El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes.",
        "De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen.",
        "Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol.",
        "En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado.",
        "Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones.",
        "En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red.",
        "En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento.",
        "Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket.",
        "Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4).",
        "Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes.",
        "Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante.",
        "De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante.",
        "El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente.",
        "Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores.",
        "De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red.",
        "Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme.",
        "Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores.",
        "Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom.",
        "Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar.",
        "Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b).",
        "Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod.",
        "Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente.",
        "Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo.",
        "De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores.",
        "Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda.",
        "Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes).",
        "En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares.",
        "En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres.",
        "Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar.",
        "Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha.",
        "Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda.",
        "Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema.",
        "En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red.",
        "Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red.",
        "Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos.",
        "Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad.",
        "Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente.",
        "Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido.",
        "Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes.",
        "Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular.",
        "Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido.",
        "Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo.",
        "Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi.",
        "Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo.",
        "El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga.",
        "Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea.",
        "El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar.",
        "Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto.",
        "Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos.",
        "Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos.",
        "Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj.",
        "Además, un nodo rastrea los datos transmitidos con éxito a través del transporte.",
        "Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante.",
        "Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido.",
        "Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época.",
        "Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5.",
        "Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo.",
        "Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete.",
        "Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi).",
        "Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete).",
        "El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente.",
        "En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas.",
        "Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos.",
        "El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes.",
        "Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional.",
        "Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi.",
        "Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero.",
        "Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno.",
        "Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época.",
        "Si la transmisión falla, el lfi se reduce en la misma cantidad.",
        "Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red.",
        "Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre.",
        "En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee.",
        "En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0.",
        "En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares.",
        "Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación).",
        "Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente.",
        "Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados).",
        "En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad.",
        "Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores.",
        "Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos.",
        "Este umbral está configurado por defecto en un 50%.",
        "Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles.",
        "Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes.",
        "De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red.",
        "Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores.",
        "Cada receptor actualiza a los emisores sobre el ancho de banda total recibido.",
        "El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente.",
        "Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor.",
        "El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba.",
        "Esto es similar al concepto de destetes presentado en [24]. 4.",
        "EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37].",
        "Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31].",
        "Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse.",
        "Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1.",
        "Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple.",
        "Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración.",
        "Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación.",
        "Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura.",
        "Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps.",
        "Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina).",
        "En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red.",
        "En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores.",
        "Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales.",
        "Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10].",
        "Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología.",
        "Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos.",
        "Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET.",
        "Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red.",
        "Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo.",
        "Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar.",
        "Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías.",
        "Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1.",
        "Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar.",
        "No implementamos ningún esquema de codificación particular para nuestros experimentos.",
        "Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada.",
        "Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible.",
        "Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro.",
        "Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda.",
        "En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión.",
        "Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia).",
        "Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps.",
        "Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados?",
        "Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol.",
        "Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo.",
        "En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT).",
        "En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23].",
        "En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace.",
        "Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo.",
        "Hacemos las siguientes suposiciones: 1.",
        "La ruta de enrutamiento entre dos participantes de la superposición es fija.",
        "Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2.",
        "El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3.",
        "En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4.",
        "Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace.",
        "Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición.",
        "Empezamos calculando el rendimiento utilizando la fórmula de estado estable.",
        "Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno.",
        "En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia.",
        "El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula.",
        "Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos.",
        "No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados.",
        "Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT).",
        "Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)).",
        "Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1).",
        "Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso.",
        "Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12].",
        "Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32].",
        "Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes.",
        "Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes.",
        "Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento.",
        "El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol.",
        "Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente.",
        "Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho.",
        "Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado.",
        "En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP.",
        "La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x.",
        "En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar).",
        "En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución.",
        "Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos.",
        "Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1.",
        "Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio.",
        "Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión.",
        "Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6.",
        "La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar.",
        "El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre.",
        "Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea.",
        "Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red.",
        "El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento.",
        "El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps.",
        "Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema.",
        "Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado.",
        "Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22.",
        "La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub.",
        "Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada.",
        "Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo.",
        "El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda.",
        "La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps.",
        "La gran mayoría de los nodos reciben un flujo de 500-600 Kbps.",
        "Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente.",
        "La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps.",
        "La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido.",
        "La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango.",
        "En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente.",
        "En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo).",
        "En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella.",
        "Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio.",
        "En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%.",
        "Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global.",
        "Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21].",
        "Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta.",
        "Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos.",
        "Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol.",
        "Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite.",
        "La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos).",
        "Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad).",
        "Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico.",
        "Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local.",
        "Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]).",
        "No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta.",
        "También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos.",
        "La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre.",
        "Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios.",
        "En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente.",
        "Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo.",
        "Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente.",
        "Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc.",
        "Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10).",
        "Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto.",
        "En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema.",
        "Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos.",
        "Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos.",
        "Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición.",
        "La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping.",
        "La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos.",
        "Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía.",
        "Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo.",
        "Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud.",
        "Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes.",
        "ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red.",
        "Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo.",
        "Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%.",
        "Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%.",
        "Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%.",
        "La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea.",
        "Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas.",
        "En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella.",
        "Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos.",
        "A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares).",
        "Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción.",
        "Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente.",
        "Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos.",
        "En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos.",
        "Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo.",
        "En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales.",
        "Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución.",
        "La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso.",
        "Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos.",
        "A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba).",
        "En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub.",
        "El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red.",
        "Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento.",
        "Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos.",
        "Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros.",
        "Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31].",
        "Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio.",
        "Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina.",
        "Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo.",
        "El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa.",
        "Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación.",
        "Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps.",
        "Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol.",
        "Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano.",
        "La Figura 15 muestra nuestros resultados para dos árboles de este tipo.",
        "El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz.",
        "Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa.",
        "Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz.",
        "En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps.",
        "El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload.",
        "Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera.",
        "Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto.",
        "Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso.",
        "Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado.",
        "TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión.",
        "En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados.",
        "Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel.",
        "Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel.",
        "El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer.",
        "Los nodos de Kazaa están organizados en una estructura escalable y jerárquica.",
        "Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen.",
        "Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet.",
        "Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet.",
        "Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo.",
        "El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema.",
        "Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada.",
        "Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes.",
        "Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular.",
        "FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs).",
        "En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo.",
        "Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo.",
        "Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol.",
        "Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema.",
        "Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha.",
        "Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP.",
        "En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast.",
        "Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación.",
        "Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas.",
        "Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión.",
        "Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable.",
        "En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos.",
        "Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir.",
        "Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo.",
        "El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad.",
        "Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta.",
        "En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares.",
        "En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto.",
        "Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares.",
        "Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen.",
        "Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados.",
        "Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol.",
        "Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición.",
        "Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen.",
        "Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos.",
        "Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre.",
        "Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares.",
        "Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda.",
        "En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda.",
        "Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast.",
        "En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares.",
        "Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros.",
        "El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros.",
        "Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido.",
        "En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad.",
        "Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34].",
        "El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema.",
        "El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe.",
        "Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe.",
        "Hasta cierto punto, Bullet y SplitStream son complementarios.",
        "Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja.",
        "CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos.",
        "En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red.",
        "Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores.",
        "En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido.",
        "En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6.",
        "CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución.",
        "En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor.",
        "Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares.",
        "Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales.",
        "Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional.",
        "Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente.",
        "RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional.",
        "Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet.",
        "Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7.",
        "REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy.",
        "Multidifusión en la capa de aplicación escalable.",
        "En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky.",
        "Multidifusión bimodal.",
        "ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
        "Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos.",
        "Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder.",
        "Sobre la semejanza y contención de documentos.",
        "En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost.",
        "Entrega de contenido informada a través de redes superpuestas adaptativas.",
        "En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege.",
        "Un enfoque de fuente digital para la distribución confiable de datos a granel.",
        "En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura.",
        "Modelado de la topología de Internet.",
        "Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh.",
        "Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos.",
        "En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger.",
        "Hacia la captura de topologías de Internet a nivel AS representativas.",
        "En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee.",
        "FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido.",
        "En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer.",
        "Un enfoque basado en Unicast para la transmisión de Multicast.",
        "En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov.",
        "Transmisión probabilística ligera.",
        "Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov.",
        "Transmisión probabilística ligera.",
        "En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer.",
        "Control de congestión basado en ecuaciones para aplicaciones unicast.",
        "En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang.",
        "Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación.",
        "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
        "Codificación de múltiples descripciones: la compresión se encuentra con la red.",
        "Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang.",
        "Un caso a favor de la multidifusión en el sistema final.",
        "En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang.",
        "Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta.",
        "En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis.",
        "Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP.",
        "En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole.",
        "Nublado: Multidifusión confiable con una red superpuesta.",
        "En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet.",
        "Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat.",
        "Utilizando subconjuntos aleatorios para construir servicios de red escalables.",
        "En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby.",
        "Códigos LT.",
        "En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann.",
        "Códigos Prácticos Resistentes a Pérdidas.",
        "En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997.",
        "Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe.",
        "Modelado del rendimiento de TCP: Un modelo simple y su validación empírica.",
        "En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang.",
        "Inferencia basada en el servidor de la pérdida de enlaces de Internet.",
        "En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou.",
        "Transmisión entre pares resiliente.",
        "En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai.",
        "Distribución de contenido de medios en streaming utilizando redes cooperativas.",
        "En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe.",
        "Un plan para introducir tecnología disruptiva en Internet.",
        "En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim.",
        "Redes de conexión más cortas y algunas generalizaciones.",
        "En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat.",
        "MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas.",
        "Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel.",
        "SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala.",
        "En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage.",
        "Sting: Una herramienta de medición de red basada en TCP.",
        "En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999.",
        "Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford.",
        "Enrutamiento de contenido basado en malla utilizando XML.",
        "En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker.",
        "Escalabilidad y precisión en un emulador de red a gran escala.",
        "En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297"
    ],
    "error_count": 0,
    "keys": {
        "overlay mesh": {
            "translated_key": "malla superpuesta",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an <br>overlay mesh</br> Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an <br>overlay mesh</br>, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth <br>overlay mesh</br>.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an <br>overlay mesh</br> that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an <br>overlay mesh</br> constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the <br>overlay mesh</br>, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an <br>overlay mesh</br>, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an <br>overlay mesh</br> to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the <br>overlay mesh</br> to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an <br>overlay mesh</br> is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Bullet: High Bandwidth Data Dissemination Using an <br>overlay mesh</br> Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "For these applications, we argue that an <br>overlay mesh</br>, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth <br>overlay mesh</br>.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an <br>overlay mesh</br> that attempts to maintain the above properties.",
                "This allows us to quantify the possible improvements of an <br>overlay mesh</br> constructed using Bullet relative to the best possible tree."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet.",
                "Para estas aplicaciones, sostenemos que una <br>malla superpuesta</br>, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas.",
                "Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una <br>malla superpuesta</br> de alta capacidad de ancho de banda.",
                "En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una <br>malla superpuesta</br> que intenta mantener las propiedades mencionadas anteriormente.",
                "Esto nos permite cuantificar las posibles mejoras de una <br>malla superpuesta</br> construida usando Bullet en relación con el mejor árbol posible."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una <br>malla superpuesta</br>, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una <br>malla superpuesta</br> de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una <br>malla superpuesta</br> que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una <br>malla superpuesta</br> construida usando Bullet en relación con el mejor árbol posible. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "data dissemination": {
            "translated_key": "difusión de datos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth <br>data dissemination</br> Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast <br>data dissemination</br> should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth <br>data dissemination</br> centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to <br>data dissemination</br> approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth <br>data dissemination</br>.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Bullet: High Bandwidth <br>data dissemination</br> Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast <br>data dissemination</br> should be re-examined.",
                "SYSTEM COMPONENTS Our approach to high bandwidth <br>data dissemination</br> centers around the techniques depicted in Figure 1.",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to <br>data dissemination</br> approaches that use some form of epidemic routing.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth <br>data dissemination</br>."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet.",
                "Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de <br>difusión de datos</br> de multidifusión de alta velocidad debería ser reexaminado.",
                "COMPONENTES DEL SISTEMA Nuestro enfoque en la <br>difusión de datos</br> de alta velocidad se centra en las técnicas representadas en la Figura 1.",
                "Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de <br>diseminación de datos</br> que utilizan alguna forma de enrutamiento epidémico.",
                "En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una <br>difusión de datos</br> de alta velocidad."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de <br>difusión de datos</br> de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la <br>difusión de datos</br> de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de <br>diseminación de datos</br> que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una <br>difusión de datos</br> de alta velocidad. ",
            "candidates": [],
            "error": [
                [
                    "difusión de datos",
                    "difusión de datos",
                    "diseminación de datos",
                    "difusión de datos"
                ]
            ]
        },
        "overlay network": {
            "translated_key": "redes superpuestas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current <br>overlay network</br> distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying <br>overlay network</br> trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing <br>overlay network</br> model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an <br>overlay network</br>.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "While many current <br>overlay network</br> distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "In addition, we have implemented a number of underlying <br>overlay network</br> trees upon which Bullet can execute.",
                "This closely models the existing <br>overlay network</br> model with IP for unicast routing. 2.",
                "Overcast: Reliable Multicasting with an <br>overlay network</br>."
            ],
            "translated_annotated_samples": [
                "Si bien muchos algoritmos actuales de distribución de <br>redes superpuestas</br> utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol.",
                "Además, hemos implementado una serie de árboles de <br>red superpuestos</br> subyacentes sobre los cuales Bullet puede ejecutarse.",
                "Esto modela de cerca el modelo de <br>red de superposición</br> existente con IP para enrutamiento unicast. 2.",
                "Nublado: Multidifusión confiable con una <br>red superpuesta</br>."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de <br>redes superpuestas</br> utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de <br>red superpuestos</br> subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de <br>red de superposición</br> existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una <br>red superpuesta</br>. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    "redes superpuestas",
                    "red superpuestos",
                    "red de superposición",
                    "red superpuesta"
                ]
            ]
        },
        "ip multicast": {
            "translated_key": "multidifusión IP",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to <br>ip multicast</br> for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native <br>ip multicast</br> has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of <br>ip multicast</br>.",
                "Even if all these problems were to be addressed, <br>ip multicast</br> does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to <br>ip multicast</br>.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to <br>ip multicast</br> for efficient point to multipoint communication across the Internet.",
                "Traditionally, native <br>ip multicast</br> has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of <br>ip multicast</br>.",
                "Even if all these problems were to be addressed, <br>ip multicast</br> does not consider bandwidth when constructing its distribution tree.",
                "There are numerous protocols that aim to add reliability to <br>ip multicast</br>."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la <br>multidifusión IP</br> para una comunicación eficiente de punto a multipunto a través de Internet.",
                "Tradicionalmente, la <br>multidifusión IP</br> nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable.",
                "Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la <br>multidifusión IP</br>.",
                "Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución.",
                "Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la <br>multidifusión de IP</br>."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la <br>multidifusión IP</br> para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la <br>multidifusión IP</br> nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la <br>multidifusión IP</br>. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la <br>multidifusión de IP</br>. ",
            "candidates": [],
            "error": [
                [
                    "multidifusión IP",
                    "multidifusión IP",
                    "multidifusión IP",
                    "multidifusión de IP"
                ]
            ]
        },
        "multipoint communication": {
            "translated_key": "comunicación eficiente de punto a multipunto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to <br>multipoint communication</br> across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to <br>multipoint communication</br> across the Internet."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una <br>comunicación eficiente de punto a multipunto</br> a través de Internet."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una <br>comunicación eficiente de punto a multipunto</br> a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "high-bandwidth data distribution": {
            "translated_key": "distribución de datos de alta velocidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target <br>high-bandwidth data distribution</br> from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "In this paper, we target <br>high-bandwidth data distribution</br> from a single source to a large number of receivers."
            ],
            "translated_annotated_samples": [
                "En este documento, nos enfocamos en la <br>distribución de datos de alta velocidad</br> desde una única fuente a un gran número de receptores."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la <br>distribución de datos de alta velocidad</br> desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "large-file transfer": {
            "translated_key": "transferencias de archivos grandes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include <br>large-file transfer</br>s and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Applications include <br>large-file transfer</br>s and real-time multimedia streaming."
            ],
            "translated_annotated_samples": [
                "Las aplicaciones incluyen <br>transferencias de archivos grandes</br> y transmisión de multimedia en tiempo real."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen <br>transferencias de archivos grandes</br> y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "real-time multimedia streaming": {
            "translated_key": "transmisión de multimedia en tiempo real",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and <br>real-time multimedia streaming</br>.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and <br>real-time multimedia streaming</br>.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Applications include large-file transfers and <br>real-time multimedia streaming</br>.",
                "Our problem domain includes software or video distribution and <br>real-time multimedia streaming</br>."
            ],
            "translated_annotated_samples": [
                "Las aplicaciones incluyen transferencias de archivos grandes y <br>transmisión de multimedia en tiempo real</br>.",
                "Nuestro dominio de problemas incluye la distribución de software o video y la <br>transmisión de multimedia en tiempo real</br>."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y <br>transmisión de multimedia en tiempo real</br>. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la <br>transmisión de multimedia en tiempo real</br>. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "bullet": {
            "translated_key": "balas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>bullet</br>: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents <br>bullet</br>, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct <br>bullet</br> around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual <br>bullet</br> receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of <br>bullet</br> running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, <br>bullet</br> reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In <br>bullet</br> however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, <br>bullet</br> would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of <br>bullet</br>, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "<br>bullet</br> nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each <br>bullet</br> node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "<br>bullet</br> then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, <br>bullet</br> layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, <br>bullet</br> can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the <br>bullet</br> mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with <br>bullet</br> allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in <br>bullet</br>, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the <br>bullet</br> mesh.",
                "We have completed a prototype of <br>bullet</br> running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that <br>bullet</br> can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that <br>bullet</br> can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the <br>bullet</br> mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details <br>bullet</br>, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire <br>bullet</br> architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, <br>bullet</br> is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in <br>bullet</br>.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing <br>bullet</br>, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "<br>bullet</br> <br>bullet</br> is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, <br>bullet</br> layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "<br>bullet</br> requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, <br>bullet</br> is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run <br>bullet</br> over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "<br>bullet</br> registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, <br>bullet</br> can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "<br>bullet</br> receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, <br>bullet</br> periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, <br>bullet</br> removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry <br>bullet</br> summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though <br>bullet</br> supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a <br>bullet</br> node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a <br>bullet</br> receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A <br>bullet</br> receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, <br>bullet</br> attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, <br>bullet</br> nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, <br>bullet</br> distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, <br>bullet</br> simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, <br>bullet</br> data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, <br>bullet</br> still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the <br>bullet</br> Mesh <br>bullet</br> allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a <br>bullet</br> sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with <br>bullet</br> on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which <br>bullet</br> can execute.",
                "Because <br>bullet</br> performs well over a randomly created overlay tree, we present results with <br>bullet</br> running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core <br>bullet</br> logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using <br>bullet</br> relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a <br>bullet</br> mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 <br>bullet</br> vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare <br>bullet</br> running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, <br>bullet</br> was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that <br>bullet</br> is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, <br>bullet</br> has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated <br>bullet</br> under a number of bandwidth constraints to determine how <br>bullet</br> performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for <br>bullet</br> and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, <br>bullet</br> outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, <br>bullet</br> and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow <br>bullet</br> to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, <br>bullet</br> running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) <br>bullet</br> - High Bandwidth Bottleneck tree - High Bandwidth <br>bullet</br> - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, <br>bullet</br> attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A <br>bullet</br> parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives <br>bullet</br> of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how <br>bullet</br> compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than <br>bullet</br> (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for <br>bullet</br> and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by <br>bullet</br> and the two epidemic approaches.",
                "As expected, <br>bullet</br> comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw <br>bullet</br> raw <br>bullet</br> useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "<br>bullet</br>, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 <br>bullet</br> on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over <br>bullet</br> and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than <br>bullet</br> when used on a lossy network.",
                "In all cases, <br>bullet</br> delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by <br>bullet</br>. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) <br>bullet</br> - High Bandwidth <br>bullet</br> - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because <br>bullet</br>, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, <br>bullet</br> nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because <br>bullet</br> is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of <br>bullet</br> over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that <br>bullet</br> can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran <br>bullet</br> over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of <br>bullet</br> to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) <br>bullet</br> Good Tree Worst Tree Figure 15: Achieved bandwidth over time for <br>bullet</br> and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, <br>bullet</br> was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the <br>bullet</br> overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to <br>bullet</br>, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "<br>bullet</br> is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, <br>bullet</br> behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, <br>bullet</br> uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a <br>bullet</br> node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while <br>bullet</br> strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of <br>bullet</br> is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "<br>bullet</br> is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "<br>bullet</br> is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, <br>bullet</br> and SplitStream are complementary.",
                "For instance, <br>bullet</br> could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, <br>bullet</br> provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of <br>bullet</br>, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of <br>bullet</br>, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that <br>bullet</br> running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "<br>bullet</br>: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "This paper presents <br>bullet</br>, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct <br>bullet</br> around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual <br>bullet</br> receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of <br>bullet</br> running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las <br>redes superpuestas</br> se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet.",
                "Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda.",
                "Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red.",
                "Los receptores de <br>balas</br> individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo.",
                "Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de <br>Bullet</br> ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias."
            ],
            "translated_text": "En los últimos años, las <br>redes superpuestas</br> se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de <br>balas</br> individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de <br>Bullet</br> ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. ",
            "candidates": [],
            "error": [
                [
                    "redes superpuestas",
                    "balas",
                    "Bullet"
                ]
            ]
        },
        "bandwidth probing": {
            "translated_key": "exploración del ancho de banda",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive <br>bandwidth probing</br>.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While <br>bandwidth probing</br> is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive <br>bandwidth probing</br>.",
                "While <br>bandwidth probing</br> is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results."
            ],
            "translated_annotated_samples": [
                "Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar <br>sondas de ancho de banda</br> costosas.",
                "Si bien la <br>exploración del ancho de banda</br> es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar <br>sondas de ancho de banda</br> costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la <br>exploración del ancho de banda</br> es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    "sondas de ancho de banda",
                    "exploración del ancho de banda"
                ]
            ]
        },
        "peer-to-peer": {
            "translated_key": "peer-to-peer",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular <br>peer-to-peer</br> file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient <br>peer-to-peer</br> Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular <br>peer-to-peer</br> file swapping network.",
                "Resilient <br>peer-to-peer</br> Streaming."
            ],
            "translated_annotated_samples": [
                "El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos <br>peer-to-peer</br>.",
                "Transmisión <br>entre pares</br> resiliente."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos <br>peer-to-peer</br>. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión <br>entre pares</br> resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    "peer-to-peer",
                    "entre pares"
                ]
            ]
        },
        "ransub": {
            "translated_key": "ransub",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including <br>ransub</br>, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 <br>ransub</br> To address the challenge of locating disjoint content within the system, we use <br>ransub</br> [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "<br>ransub</br> assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "<br>ransub</br> distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, <br>ransub</br> distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of <br>ransub</br> is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the <br>ransub</br> protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "<br>ransub</br> offers several ways of constructing distribute sets.",
                "For our system, we choose the <br>ransub</br>-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates <br>ransub</br>-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using <br>ransub</br>, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for <br>ransub</br> to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers <br>ransub</br> periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "<br>ransub</br> messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "<br>ransub</br> delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of <br>ransub</br> to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because <br>ransub</br> collects descendant counts di for each child i, Bullet simply makes a call into <br>ransub</br> when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of <br>ransub</br> means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few <br>ransub</br> epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that <br>ransub</br> [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, <br>ransub</br> makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in <br>ransub</br> so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, <br>ransub</br> stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable <br>ransub</br> failure detection that recognizes a nodes failure when a <br>ransub</br> epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon <br>ransub</br> timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With <br>ransub</br> failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no <br>ransub</br> recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and <br>ransub</br> recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through <br>ransub</br> to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "<br>ransub</br> periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Section 2 presents Bullets system components including <br>ransub</br>, informed content delivery, and TFRC.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 <br>ransub</br> To address the challenge of locating disjoint content within the system, we use <br>ransub</br> [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "<br>ransub</br> assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "<br>ransub</br> distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Using the collect and distribute messages, <br>ransub</br> distributes a random subset of participants to each node once per epoch."
            ],
            "translated_annotated_samples": [
                "La sección 2 presenta los componentes del sistema Bullets, incluyendo <br>RanSub</br>, entrega de contenido informada y TFRC.",
                "Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos <br>RanSub</br> [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición.",
                "RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el <br>árbol subyacente</br>.",
                "RanSub distribuye <br>subconjuntos aleatorios</br> de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución.",
                "Utilizando los mensajes de recolección y distribución, <br>RanSub</br> distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo <br>RanSub</br>, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos <br>RanSub</br> [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el <br>árbol subyacente</br>. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye <br>subconjuntos aleatorios</br> de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, <br>RanSub</br> distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. ",
            "candidates": [],
            "error": [
                [
                    "RanSub",
                    "RanSub",
                    "árbol subyacente",
                    "subconjuntos aleatorios",
                    "RanSub"
                ]
            ]
        },
        "content delivery": {
            "translated_key": "entrega de contenido",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed <br>content delivery</br>, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed <br>content delivery</br> Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed <br>content delivery</br> Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within <br>content delivery</br> Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Section 2 presents Bullets system components including RanSub, informed <br>content delivery</br>, and TFRC.",
                "In the figure, AS stands for node As state. 2.3 Informed <br>content delivery</br> Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Informed <br>content delivery</br> Across Adaptive Overlay Networks.",
                "FastReplica: Efficient Large File Distribution within <br>content delivery</br> Networks."
            ],
            "translated_annotated_samples": [
                "La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, <br>entrega de contenido informada</br> y TFRC.",
                "En la figura, AS representa el estado del nodo A. 2.3 Técnicas de <br>entrega de contenido</br> informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos.",
                "Entrega de contenido informada a través de redes superpuestas adaptativas.",
                "FastReplica: Distribución eficiente de archivos grandes dentro de redes de <br>entrega de contenido</br>."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, <br>entrega de contenido informada</br> y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de <br>entrega de contenido</br> informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de <br>entrega de contenido</br>. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.\nTraducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297 ",
            "candidates": [],
            "error": [
                [
                    "entrega de contenido informada",
                    "entrega de contenido",
                    "entrega de contenido"
                ]
            ]
        },
        "tfrc": {
            "translated_key": "tfrc",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use <br>tfrc</br> [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree.",
                "One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and <br>tfrc</br>.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 <br>tfrc</br> to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based <br>tfrc</br> protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or <br>tfrc</br>, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, <br>tfrc</br> is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of <br>tfrc</br> is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, <br>tfrc</br> uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in <br>tfrc</br>.",
                "The formula of the TCP response function [27] used in <br>tfrc</br> to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "<br>tfrc</br> senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of <br>tfrc</br>.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from <br>tfrc</br>.",
                "Further, <br>tfrc</br> does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using <br>tfrc</br> we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of <br>tfrc</br>.",
                "For the remainder of this paper, we assume the use of <br>tfrc</br> since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, <br>tfrc</br>, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use <br>tfrc</br> to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for <br>tfrc</br> streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of <br>tfrc</br> in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, <br>tfrc</br> transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow <br>tfrc</br> enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and <br>tfrc</br> streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Finally, we use <br>tfrc</br> [15] to transfer data both down the overlay tree and among peers.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and <br>tfrc</br>.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 <br>tfrc</br> to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based <br>tfrc</br> protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "TCP Friendly Rate Control, or <br>tfrc</br>, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15]."
            ],
            "translated_annotated_samples": [
                "Finalmente, utilizamos <br>TFRC</br> [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares.",
                "La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC.",
                "A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 <br>TFRC</br> para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente.",
                "Utilizamos el <br>protocolo TFRC basado en ecuaciones</br> para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP.",
                "El Control de Tasa Amigable con TCP, o <br>TFRC</br>, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos <br>TFRC</br> [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 <br>TFRC</br> para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el <br>protocolo TFRC basado en ecuaciones</br> para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o <br>TFRC</br>, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. ",
            "candidates": [],
            "error": [
                [
                    "TFRC",
                    "TFRC",
                    "protocolo TFRC basado en ecuaciones",
                    "TFRC"
                ]
            ]
        },
        "bandwidth": {
            "translated_key": "ancho de banda",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High <br>bandwidth</br> Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-<br>bandwidth</br> data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher <br>bandwidth</br> and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high <br>bandwidth</br> overlay mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two <br>bandwidth</br> improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive <br>bandwidth</br> probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of <br>bandwidth</br> delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider <br>bandwidth</br> when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical overlay structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high <br>bandwidth</br> multicast and for high reliability.",
                "One difficulty with trees is that <br>bandwidth</br> is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the <br>bandwidth</br> available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available <br>bandwidth</br> in an overlay tree [2, 6].",
                "However, fundamentally, the <br>bandwidth</br> available to any host is limited by the <br>bandwidth</br> available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-<br>bandwidth</br> multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher <br>bandwidth</br>-leveraging the <br>bandwidth</br> from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node overlay with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) <br>bandwidth</br> to each of A and B.",
                "However, there is also 1 Mbps of available <br>bandwidth</br> between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck <br>bandwidth</br> and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available <br>bandwidth</br> between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the <br>bandwidth</br> delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the <br>bandwidth</br> available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-<br>bandwidth</br> mesh on top of an arbitrary overlay tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable <br>bandwidth</br>, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers.",
                "This ensures that the entire overlay behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the <br>bandwidth</br> delivered by the Bullet mesh is somewhat independent of the <br>bandwidth</br> available through the underlying overlay tree.",
                "One significant limitation to building high <br>bandwidth</br> overlay trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available <br>bandwidth</br> because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While <br>bandwidth</br> probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high <br>bandwidth</br> in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the <br>bandwidth</br> available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the <br>bandwidth</br> that would normally be consumed probing for <br>bandwidth</br> can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of overlay trees.",
                "Our evaluation of a 1000-node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the <br>bandwidth</br> of a <br>bandwidth</br>-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable <br>bandwidth</br> performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-<br>bandwidth</br>, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for <br>bandwidth</br> intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high <br>bandwidth</br> data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available <br>bandwidth</br> to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available <br>bandwidth</br> in the overlay tree.",
                "Our overall goal however is to deliver more <br>bandwidth</br> than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the overlay form a mesh to augment the <br>bandwidth</br> available through the tree.",
                "In Figure 1, node D only has sufficient <br>bandwidth</br> to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered <br>bandwidth</br> from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful <br>bandwidth</br> delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable <br>bandwidth</br>, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a <br>bandwidth</br>-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available <br>bandwidth</br>, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available <br>bandwidth</br> like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new <br>bandwidth</br>, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for <br>bandwidth</br> intensive applications.",
                "While many current overlay network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall <br>bandwidth</br> to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay.",
                "This has significant <br>bandwidth</br> impact when a single node in the overlay is unable to deliver adequate <br>bandwidth</br> to a receiving node.",
                "Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participantss state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the overlay.",
                "As a result, Bullet is capable of functioning on top of essentially any overlay tree.",
                "In our experiments, we have run Bullet over random and <br>bandwidth</br>-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs <br>bandwidth</br> and its relative position in the tree. 3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good <br>bandwidth</br>.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted <br>bandwidth</br>.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional overlay distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the <br>bandwidth</br> achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high <br>bandwidth</br> would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs <br>bandwidth</br> is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate <br>bandwidth</br> will own more of their share of packets than those with inadequate <br>bandwidth</br>.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available <br>bandwidth</br> if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional <br>bandwidth</br> may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available <br>bandwidth</br> to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample <br>bandwidth</br>, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the <br>bandwidth</br> performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received <br>bandwidth</br>.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its <br>bandwidth</br> through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck <br>bandwidth</br> tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, <br>bandwidth</br>, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological <br>bandwidth</br> by setting the <br>bandwidth</br> for each link depending on its type.",
                "Each type of link has an associated <br>bandwidth</br> range from which the <br>bandwidth</br> is chosen uniformly at random.",
                "By changing these ranges, we vary <br>bandwidth</br> constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying <br>bandwidth</br> constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck <br>bandwidth</br> Tree One of our goals is to determine Bullets performance relative to the best possible <br>bandwidth</br>-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of <br>bandwidth</br>.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the <br>bandwidth</br> of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low <br>bandwidth</br> 300-600 500-1000 1000-2000 2000-4000 Medium <br>bandwidth</br> 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, <br>bandwidth</br>, and packet loss rates), what is the overlay tree that will deliver the highest <br>bandwidth</br> to a set of predetermined overlay nodes?",
                "We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the overlay maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial <br>bandwidth</br>, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two overlay participants is fixed.",
                "This closely models the existing overlay network model with IP for unicast routing. 2.",
                "The overlay tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an overlay link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), <br>bandwidth</br> B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput overlay link.",
                "Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated.",
                "However, by attaching the node with the highest residual <br>bandwidth</br> at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average <br>bandwidth</br> that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck <br>bandwidth</br> tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved <br>bandwidth</br> of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online <br>bandwidth</br> overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 <br>bandwidth</br>(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized overlay.",
                "Hence, Bullets goal is to overcome this <br>bandwidth</br> limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the <br>bandwidth</br> achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average <br>bandwidth</br> received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and <br>bandwidth</br> setting, Bullet was able to achieve an average <br>bandwidth</br> of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total <br>bandwidth</br> (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high <br>bandwidth</br> while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the overlay is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited <br>bandwidth</br> randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate <br>bandwidth</br> even though they are <br>bandwidth</br> constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of <br>bandwidth</br> constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 <br>bandwidth</br>(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative <br>bandwidth</br> settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough <br>bandwidth</br> is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available <br>bandwidth</br> is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck <br>bandwidth</br> tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck <br>bandwidth</br> tree by a factor of up to 100%, depending on how much <br>bandwidth</br> is constrained in the underlying topology.",
                "In one extreme, having more than ample <br>bandwidth</br>, Bullet and the bottleneck <br>bandwidth</br> tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the <br>bandwidth</br> achievable via the bottleneck <br>bandwidth</br> tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained <br>bandwidth</br> topology is able to outperform the bottleneck <br>bandwidth</br> tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 <br>bandwidth</br>(Kbps) Time (s) Bullet - High <br>bandwidth</br> Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple <br>bandwidth</br> optimizing overlay tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the <br>bandwidth</br> of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high <br>bandwidth</br> levels to nodes depends on its disjoint transmission strategy.",
                "That is, when <br>bandwidth</br> to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting <br>bandwidth</br> over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its <br>bandwidth</br> capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 <br>bandwidth</br>(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved <br>bandwidth</br> over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average <br>bandwidth</br> achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting <br>bandwidth</br> over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target <br>bandwidth</br> to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful <br>bandwidth</br> provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 <br>bandwidth</br>(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved <br>bandwidth</br> over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good <br>bandwidth</br> and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck <br>bandwidth</br> tree.",
                "Because losses adversely affect the <br>bandwidth</br> achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much <br>bandwidth</br> than the bottleneck <br>bandwidth</br> tree.",
                "Additionally, losses in the low <br>bandwidth</br> topology essentially keep the bottleneck <br>bandwidth</br> tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved <br>bandwidth</br> by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 <br>bandwidth</br>(Kbps) Time (s) Bullet - High <br>bandwidth</br> Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved <br>bandwidth</br> over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 <br>bandwidth</br>(Kbps) Time (s) <br>bandwidth</br> received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample <br>bandwidth</br> available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher <br>bandwidth</br> than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low <br>bandwidth</br>.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck <br>bandwidth</br> tree for comparison.",
                "We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 <br>bandwidth</br>(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved <br>bandwidth</br> over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high <br>bandwidth</br> measurements were placed close to the root.",
                "In this case, we are able to achieve a <br>bandwidth</br> of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst <br>bandwidth</br> characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high <br>bandwidth</br> characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high <br>bandwidth</br> conditions and improves performance under constrained <br>bandwidth</br> scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an overlay mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the <br>bandwidth</br> delivered to the overlay participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an overlay routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more <br>bandwidth</br> than nodes organized into the Bullet overlay structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-<br>bandwidth</br> streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the <br>bandwidth</br> through the tree, while Bullet strives to provide more <br>bandwidth</br> to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available <br>bandwidth</br> on overlay links.",
                "It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the <br>bandwidth</br> available through a Narada tree is still limited to the <br>bandwidth</br> available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase <br>bandwidth</br> through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a <br>bandwidth</br>-efficient overlay tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of <br>bandwidth</br>.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target <br>bandwidth</br> without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high <br>bandwidth</br> data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node <br>bandwidth</br> constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available <br>bandwidth</br> to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the <br>bandwidth</br> delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high <br>bandwidth</br> overlay data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher <br>bandwidth</br>.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant <br>bandwidth</br> improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher <br>bandwidth</br> throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available <br>bandwidth</br> in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional <br>bandwidth</br> tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive Overlay Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-<br>bandwidth</br> Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available <br>bandwidth</br>: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an Overlay Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Bullet: High <br>bandwidth</br> Data Dissemination Using an Overlay Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "In this paper, we target high-<br>bandwidth</br> data distribution from a single source to a large number of receivers.",
                "For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher <br>bandwidth</br> and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high <br>bandwidth</br> overlay mesh.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two <br>bandwidth</br> improvements under a variety of circumstances."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet.",
                "En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores.",
                "Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor <br>ancho de banda</br> y fiabilidad en comparación con las estructuras de árbol típicas.",
                "Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de <br>ancho de banda</br>.",
                "Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de <br>ancho de banda</br> de hasta un factor dos bajo una variedad de circunstancias."
            ],
            "translated_text": "En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor <br>ancho de banda</br> y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de <br>ancho de banda</br>. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de <br>ancho de banda</br> de hasta un factor dos bajo una variedad de circunstancias. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "overlay": {
            "translated_key": "superposición",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bullet: High Bandwidth Data Dissemination Using an <br>overlay</br> Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, <br>overlay</br> networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient <br>overlay</br> tree, one that meets performance targets without placing undue burden on the underlying network.",
                "In this paper, we target high-bandwidth data distribution from a single source to a large number of receivers.",
                "Applications include large-file transfers and real-time multimedia streaming.",
                "For these applications, we argue that an <br>overlay</br> mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth <br>overlay</br> mesh.",
                "We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network.",
                "Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the <br>overlay</br> such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances.",
                "In addition, we find that, relative to tree-based solutions, Bullet reduces the need to perform expensive bandwidth probing.",
                "In a tree, it is critical that a nodes parent delivers a high rate of application data to each child.",
                "In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems; H.4.3 [Information Systems Applications]: Communications Applications General Terms Experimentation, Management, Performance 1.",
                "INTRODUCTION In this paper, we consider the following general problem.",
                "Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers?",
                "Our problem domain includes software or video distribution and real-time multimedia streaming.",
                "Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion.",
                "However, a number of considerations, including scale, reliability, and congestion control, have limited the wide-scale deployment of IP multicast.",
                "Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree.",
                "More recently, overlays have emerged as a promising alternative to multicast for network-efficient point to multipoint data delivery.",
                "Typical <br>overlay</br> structures attempt to mimic the structure of multicast routing trees.",
                "In network-layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility.",
                "Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the <br>overlay</br> tree, with these hosts acting as repeaters to multiple children down the tree.",
                "Overlays have shown tremendous promise for multicast-style applications.",
                "However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability.",
                "One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree.",
                "Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree.",
                "A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an <br>overlay</br> tree [2, 6].",
                "However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that nodes single parent in the tree.",
                "Thus, our work operates on the premise that the model for high-bandwidth multicast data dissemination should be re-examined.",
                "Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast <br>overlay</br> cooperate to strategically 282 transmit disjoint data sets to various points in the network.",
                "Here, the sender splits data into sequential blocks.",
                "Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network.",
                "Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects.",
                "We use a distributed algorithm that aims to make the availability of data items uniformly spread across all <br>overlay</br> participants.",
                "In this way, we avoid the problem of locating the last object, which may only be available at a few nodes.",
                "One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth-leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent-and higher reliability-retrieving data from multiple peers reduces the potential damage from a single node failure.",
                "To illustrate Bullets behavior, consider a simple three node <br>overlay</br> with a root R and two children A and B. R has 1 Mbps of available (TCP-friendly) bandwidth to each of A and B.",
                "However, there is also 1 Mbps of available bandwidth between A and B.",
                "In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B.",
                "A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps.",
                "On the other hand, any <br>overlay</br> tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data.",
                "Any solution for achieving the above model must maintain a number of properties.",
                "First, it must be TCP friendly [15].",
                "No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate.",
                "Second, it must impose low control overhead.",
                "There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources.",
                "Third, the algorithm should be decentralized and scalable to thousands of participants.",
                "No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes.",
                "Finally, the approach must be robust to individual failures.",
                "For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast <br>overlay</br> tree.",
                "In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an <br>overlay</br> mesh that attempts to maintain the above properties.",
                "Bullet nodes begin by self-organizing into an <br>overlay</br> tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34].",
                "Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants.",
                "The level of disjointness is determined by the bandwidth available to each of its children.",
                "Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node.",
                "Thus, Bullet layers a high-bandwidth mesh on top of an arbitrary <br>overlay</br> tree.",
                "Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding (MDC) [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses.",
                "Finally, we use TFRC [15] to transfer data both down the <br>overlay</br> tree and among peers.",
                "This ensures that the entire <br>overlay</br> behaves in a congestion-friendly manner, adjusting its transmission rate on a per-connection basis based on prevailing network conditions.",
                "One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying <br>overlay</br> tree.",
                "One significant limitation to building high bandwidth <br>overlay</br> trees is the overhead associated with the tree construction protocol.",
                "In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent).",
                "Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions.",
                "While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results.",
                "Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system.",
                "Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree.",
                "Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh.",
                "We have completed a prototype of Bullet running on top of a number of <br>overlay</br> trees.",
                "Our evaluation of a 1000-node <br>overlay</br> running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth-optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly.",
                "We also deployed our prototype across the PlanetLab [31] wide-area testbed.",
                "For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements.",
                "In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high-bandwidth, large-scale scenarios.",
                "The remainder of this paper is organized as follows.",
                "Section 2 presents Bullets system components including RanSub, informed content delivery, and TFRC.",
                "Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications.",
                "Section 4 evaluates Bullets performance for a variety of network topologies, and compares it to existing multicast techniques.",
                "Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. 2.",
                "SYSTEM COMPONENTS Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1.",
                "First, we split the target data stream into blocks which are further subdivided into individual (typically packet-sized) objects.",
                "Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient.",
                "Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High-level view of Bullets operation. to different clients at a rate determined by the available bandwidth to each client.",
                "We use the equation-based TFRC protocol to communicate among all nodes in the <br>overlay</br> in a congestion responsive and TCP friendly manner.",
                "Given the above techniques, data is spread across the <br>overlay</br> tree at a rate commensurate with the available bandwidth in the <br>overlay</br> tree.",
                "Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree.",
                "Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers.",
                "In essence, these perpendicular links across the <br>overlay</br> form a mesh to augment the bandwidth available through the tree.",
                "In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent.",
                "However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit.",
                "Locating appropriate remote peers cannot require global state or global communication.",
                "Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each <br>overlay</br> node once per configurable time period.",
                "This random subset contains summary tickets of the objects available at a subset of the nodes in the system.",
                "Each node uses this information to request data objects from remote nodes that have significant divergence in object membership.",
                "It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it.",
                "In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work.",
                "Section 3 then presents the details of the entire Bullet architecture. 2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency.",
                "For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream.",
                "For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet.",
                "Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream.",
                "Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best-effort through the system.",
                "In this paper, we focus on the benefits of a special class of erasure-correcting codes used to implement the digital fountain [7] approach.",
                "Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets.",
                "Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05.",
                "In return, they provide significantly faster encoding and decoding times.",
                "Additionally, the decoding algorithm can run in real-time, and the reconstruction process can start as soon as sufficiently many packets have arrived.",
                "Tornado codes require a predetermined stretch factor (n/k, where n is the total number of encoded packets), and their encoding time is proportional to n. LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05. 2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an <br>overlay</br> tree.",
                "RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree.",
                "A number of such techniques are described in [1, 18, 21, 24, 34].",
                "RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages.",
                "Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root.",
                "Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants.",
                "Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch.",
                "The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree.",
                "For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness.",
                "As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children.",
                "The contents of the distribute set are constructed using the collect set gathered during the previous collect phase.",
                "During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants.",
                "After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch.",
                "One of the key features of RanSub is the Compact operation.",
                "This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub-tree rooted at that node.",
                "Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed-size subset.",
                "The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch.",
                "The collect phase is shown on the left, where the collect sets are traveling up the <br>overlay</br> to the root.",
                "The distribute phase on the right shows the distribute sets traveling down the <br>overlay</br> to the leaf nodes. members of the resulting set are uniformly random representatives of the input subset members.",
                "RanSub offers several ways of constructing distribute sets.",
                "For our system, we choose the RanSub-nondescendants option.",
                "In this case, each node receives a random subset consisting of all nodes excluding its descendants.",
                "This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases.",
                "A parent creates RanSub-nondescendants distribute sets for each child by compacting collect sets from that childs siblings and its own distribute set.",
                "The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child.",
                "We depict an example of RanSubs collect-distribute process in Figure 2.",
                "In the figure, AS stands for node As state. 2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data.",
                "Additionally, we require a bandwidth-efficient method with low computational overhead.",
                "We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet.",
                "To describe the content, nodes maintain working sets.",
                "The working set contains sequence numbers of packets that have been successfully received by each node over some period of time.",
                "We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine-grained reconciliation is beneficial.",
                "Summary tickets, or min-wise sketches [5], serve this purpose.",
                "The main idea is to create a summary ticket that is an unbiased random sample of the working set.",
                "A summary ticket is a small fixed-size array.",
                "Each entry in this array is maintained by a specific permutation function.",
                "The goal is to have each entry populated by the element with the smallest permuted value.",
                "To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate.",
                "The permutation function can be thought of as a specialized hash function.",
                "The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions.",
                "Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme).",
                "To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets.",
                "Figure 3 shows the way the permutation functions are used to populate the summary ticket. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set.",
                "To perform approximate fine-grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest.",
                "For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions.",
                "An element s from the set of received keys S = {so, s2, . . . , sn−1} is inserted into the filter by computing the hash values h0, h1, . . . , hk−1 of s and setting the bits in the array that correspond to the hashed 285 values.",
                "To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set.",
                "If at least one is not set, we know that the Bloom filter does not contain x.",
                "When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero.",
                "In this case, we have a false positive.",
                "Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it.",
                "On the other hand, a node will never send a packet that is described in the Bloom filter, i.e. there are no false negatives.",
                "The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn/m )k .",
                "We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio. 2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCPs reaction to a single dropped packet to be unnecessarily severe.",
                "TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15].",
                "TCP halves the sending rate as soon as one packet loss is detected.",
                "Alternatively, TFRC is an equation-based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round-trip time.",
                "Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion.",
                "To guarantee fairness with TCP, TFRC uses the response function that describes the steady-state sending rate of TCP to determine the transmission rate in TFRC.",
                "The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes/second, as a function of the round-trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds.",
                "TFRC senders and receivers must cooperate to achieve a smooth transmission rate.",
                "The sender is responsible for computing the weighted round-trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O.",
                "In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP.",
                "The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver.",
                "The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver.",
                "Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow-start.",
                "The main role of the receiver is to send feedback to the sender once per round-trip time and to calculate the loss event rate included in the feedback packets.",
                "To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals.",
                "A loss interval is defined as the number of packets received correctly between two loss events.",
                "The array is continually updated as losses are detected.",
                "A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p. When implementing Bullet, we used an unreliable version of TFRC.",
                "We wanted a transport protocol that was congestion aware and TCP friendly.",
                "Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender.",
                "Hence, we eliminate retransmissions from TFRC.",
                "Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an <br>overlay</br> tree where there might be multiple competing flows sharing the same links.",
                "For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree.",
                "By using TFRC we were able to avoid these scenarios. 3.",
                "BULLET Bullet is an efficient data distribution system for bandwidth intensive applications.",
                "While many current <br>overlay</br> network distribution algorithms use a distribution tree to deliver data from the trees root to all other nodes, Bullet layers a mesh on top of an original <br>overlay</br> tree to increase overall bandwidth to all nodes in the tree.",
                "Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the <br>overlay</br>.",
                "This has significant bandwidth impact when a single node in the <br>overlay</br> is unable to deliver adequate bandwidth to a receiving node.",
                "Bullet requires an underlying <br>overlay</br> tree for RanSub to deliver random subsets of participantss state to nodes in the <br>overlay</br>, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the nodes current peers and parent.",
                "While we also use the underlying tree for baseline streaming, this is not critical to Bullets ability to efficiently deliver data to nodes in the <br>overlay</br>.",
                "As a result, Bullet is capable of functioning on top of essentially any <br>overlay</br> tree.",
                "In our experiments, we have run Bullet over random and bandwidth-optimized trees created oﬄine (with global topological knowledge).",
                "Bullet registers itself with the underlying <br>overlay</br> tree so that it is informed when the <br>overlay</br> changes as nodes come and go or make performance transformations in the overlay.",
                "As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC.",
                "For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in-order delivery.",
                "For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers.",
                "Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the childs bandwidth and its relative position in the tree. 3.1 Finding <br>overlay</br> Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the <br>overlay</br>.",
                "Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth.",
                "RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains.",
                "RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default).",
                "Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers.",
                "Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far.",
                "Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it.",
                "This allows us to keep the Bloom filter population n from growing at an unbounded rate.",
                "The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate.",
                "Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket.",
                "We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree.",
                "In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non-fragmented IP packet.",
                "Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications needs.",
                "In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies.",
                "In essence, during an epoch a node receives a summarized partial view of the systems state at that time.",
                "Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket.",
                "This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4).",
                "Once a node has chosen the best node it sends it a peering request containing the requesting nodes Bloom filter.",
                "Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver.",
                "Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4). 3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node.",
                "The requesting node will refresh its installed Bloom filters at each of its sending peers periodically.",
                "Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders.",
                "In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources.",
                "A node divides the sequence space in its current working set among each of its senders uniformly.",
                "As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers.",
                "A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter.",
                "This identifies the range of packets that the receiver is currently interested in recovering.",
                "Over time, this range shifts as depicted in Figure 4-b).",
                "In addition, the receiving node assigns to each sender a row from the matrix, labeled mod.",
                "A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has.",
                "It requests data within the range (Low, High) of sequence numbers based on what it has received. a) The receiver requests a specific row in the sequence matrix from each sender. b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders. the receiver that have a sequence number x such that x modulo s equals the mod number.",
                "In this fashion, receivers register to receive disjoint data from their sending peers.",
                "By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth.",
                "A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants).",
                "In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers.",
                "In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments. 3.3 Making Data Disjoint We now provide details of Bullets mechanisms to increase the ease by which nodes can find disjoint data not provided by parents.",
                "We operate on the premise that the main challenge in recovering lost data packets transmitted over an <br>overlay</br> distribution tree lies in finding the peer node housing the data to recover.",
                "Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied.",
                "This ultimately leads to scalability issues at higher levels in the hierarchy particularly when <br>overlay</br> links are bandwidthconstrained.",
                "On the other hand, Bullet attempts to recover lost data from any non-descendant node, not just ancestors, thereby increasing overall system scalability.",
                "In traditional <br>overlay</br> distribution trees, packets are lost by the transmission transport and/or the network.",
                "Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network.",
                "As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data.",
                "If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems.",
                "In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport.",
                "If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child.",
                "In addition, because nodes recover data from participants chosen uniformly at random from the set of non-descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes.",
                "That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet.",
                "While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost.",
                "To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same.",
                "A node p maintains for each child, i, a limiting and sending factor, lfi and sfi.",
                "These factors determine the proportion of ps received data rate that it will forward to each child.",
                "The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has.",
                "The more descendants a child has, the larger the portion of received data it should own.",
                "The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle.",
                "For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor.",
                "Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it.",
                "Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children.",
                "For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .",
                "In addition, a node tracks the data successfully transmitted via the transport.",
                "That is, Bullet data transport sockets are non-blocking; successful transmissions are send attempts that are accepted by the non-blocking transport.",
                "If the transport would block on a send (i.e., transmission of the packet would exceed the TCP-friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt.",
                "When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch.",
                "It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5.",
                "Having chosen the target of a particular packet, the parent attempts to forward the packet to the child.",
                "If the send is not successful, the node must find an alternate child to own the packet.",
                "This occurs when a childs bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi).",
                "To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet).",
                "The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth.",
                "In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // send succeeded target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) // transfer ownership should_send = 1; else // test for available bandwidth if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // i received ownership child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // send failed if (sent_packet) // was for extra bw decrease(child->limiting_factor); } } Figure 5: Pseudo code for Bullets disjoint data send routine stream.",
                "While making data more difficult to recover, Bullet still allows for recovery of such data to its children.",
                "The sending node will cache the data packet and serve it to its requesting peers.",
                "This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available.",
                "Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi.",
                "For each child i, a node attempts to forward the packet deterministically if the packets sequence modulo 1/lfi is zero.",
                "Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each.",
                "If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch.",
                "If the transmission fails, lfi is decreased by the same amount.",
                "This allows children limiting factors to be continuously adjusted in response to changing network conditions.",
                "It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream.",
                "In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns.",
                "In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0.",
                "In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets. 3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships.",
                "That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation).",
                "A number of considerations can make the current peering relationships sub-optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing.",
                "For example, a sender node may wind up being unable to provide a node with very much useful (non-duplicate) data.",
                "In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility.",
                "Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers.",
                "A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received.",
                "This threshold is set to 50% by default.",
                "If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it.",
                "It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list.",
                "In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions.",
                "Likewise, a Bullet sender will periodically evaluate its receivers.",
                "Each receiver updates senders of the total received bandwidth.",
                "The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender.",
                "This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender.",
                "The sender drops this receiver, creating an empty slot for some other trial receiver.",
                "This is similar to the concept of weans presented in [24]. 4.",
                "EVALUATION We have evaluated Bullets performance in real Internet environments as well as the ModelNet [37] IP emulation framework.",
                "While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31].",
                "In addition, we have implemented a number of underlying <br>overlay</br> network trees upon which Bullet can execute.",
                "Because Bullet performs well over a randomly created <br>overlay</br> tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1.",
                "All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of <br>overlay</br> algorithms in a simple domainspecific language.",
                "It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment.",
                "As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies.",
                "Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure.",
                "Our ModelNet experiments make use of 50 2Ghz Pentium4s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches.",
                "For the majority of these experiments, we multiplex one thousand instances (<br>overlay</br> participants) of our <br>overlay</br> applications across the 50 Linux nodes (20 per machine).",
                "In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop-by-hop delay, bandwidth, and congestion of a network topology.",
                "In our evaluations, we used four 1.4Ghz Pentium IIIs running FreeBSD-4.7 as emulators.",
                "This platform supports approximately 2-3 Gbps of aggregate simultaneous communication among end hosts.",
                "For most of our ModelNet experiments, we use 20,000-node INET-generated topologies [10].",
                "We randomly assign our participant nodes to act as clients connected to one-degree stub nodes in the topology.",
                "We randomly select one of these participants to act as the source of the data stream.",
                "Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET.",
                "Based on the classification in [8], we classify network links as being Client-Stub, Stub-Stub, TransitStub, and Transit-Transit depending on their location in the network.",
                "We restrict topological bandwidth by setting the bandwidth for each link depending on its type.",
                "Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random.",
                "By changing these ranges, we vary bandwidth constraints in our topologies.",
                "For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600-1000 Kbps as specified in Table 1.",
                "While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior.",
                "We do not implement any particular coding scheme for our experiments.",
                "Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file. 4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullets performance relative to the best possible bandwidth-optimized tree for a given network topology.",
                "This allows us to quantify the possible improvements of an <br>overlay</br> mesh constructed using Bullet relative to the best possible tree.",
                "While we have not yet proven this, we believe that this problem is NP-hard.",
                "Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth.",
                "In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm.",
                "At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming).",
                "In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6. 289 Topology classification Client-Stub Stub-Stub Transit-Stub Transit-Transit Low bandwidth 300-600 500-1000 1000-2000 2000-4000 Medium bandwidth 800-2800 1000-4000 1000-4000 5000-10000 High bandwidth 1600-5600 2000-8000 2000-8000 10000-20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps.",
                "Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the <br>overlay</br> tree that will deliver the highest bandwidth to a set of predetermined <br>overlay</br> nodes?",
                "We assume that the throughput of the slowest <br>overlay</br> link (the bottleneck link) determines the throughput of the entire tree.",
                "We are, therefore, trying to find the directed <br>overlay</br> tree with the maximum bottleneck link.",
                "Accordingly, we refer to this problem as the <br>overlay</br> maximum bottleneck tree (OMBT).",
                "In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23].",
                "In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP-hard [12], even in the absence of link losses.",
                "For the purposes of this paper, our goal is to determine a good <br>overlay</br> streaming tree that provides each <br>overlay</br> participant with substantial bandwidth, while avoiding overlay links with high end-to-end loss rates.",
                "We make the following assumptions: 1.",
                "The routing path between any two <br>overlay</br> participants is fixed.",
                "This closely models the existing <br>overlay</br> network model with IP for unicast routing. 2.",
                "The <br>overlay</br> tree will use TCP-friendly unicast connections to transfer data point-to-point. 3.",
                "In the absence of other flows, we can estimate the throughput of a TCP-friendly flow using a steady-state formula [27]. 4.",
                "When several (n) flows share the same bottleneck link, each flow can achieve throughput of at most c n , where c is the physical capacity of the link.",
                "Given these assumptions, we concentrate on estimating the throughput available between two participants in the <br>overlay</br>.",
                "We start by calculating the throughput using the steady-state formula.",
                "We then route the flow in the network, and consider the physical links one at a time.",
                "On each physical link, we compute the fair-share for each of the competing flows.",
                "The throughput of an <br>overlay</br> link is then approximated by the minimum of the fair-shares along the routing path, and the formula rate.",
                "If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute.",
                "We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links.",
                "More formally, we define the problem as follows: <br>overlay</br> Maximum Bottleneck Tree (OMBT).",
                "Given a physical network represented as a graph G = (V, E), set of <br>overlay</br> participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible <br>overlay</br> links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady-state sending rate, computed from round-trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)).",
                "We write e ∈ o to express that link e is included in the os routing path (RT(o, e) = 1).",
                "Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm.",
                "This algorithm is non-optimal, but a similar approach was found to perform well [12].",
                "Our algorithm is similar to the Widest Path Heuristic (WPH) [12], and more generally to Prims MST algorithm [32].",
                "During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes.",
                "To grow the tree, we consider all the <br>overlay</br> links leading from the nodes in the tree to the remaining nodes.",
                "We greedily pick the node with the highest throughput <br>overlay</br> link.",
                "Using this <br>overlay</br> link might cause us to route traffic over physical links traversed by some other tree flows.",
                "Since we do not re-examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower <br>overlay</br> links than initially estimated.",
                "However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after-the-fact physical link sharing.",
                "With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree. 4.2 Bullet vs. Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree.",
                "In our implementation, we are able to stream data through <br>overlay</br> trees using UDP, TFRC, or TCP.",
                "Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x-axis.",
                "In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior).",
                "In these experiments, streaming begins 100 seconds into each run.",
                "While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm <br>overlay</br> delivers approximately 400 Kbps of data.",
                "For this experiment, bandwidths were set to the medium range from Table 1.",
                "We believe that any degree-constrained online bandwidth <br>overlay</br> tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree. optimized <br>overlay</br>.",
                "Hence, Bullets goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm.",
                "To evaluate Bullets ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random <br>overlay</br> tree to the streaming behavior shown in Figure 6.",
                "Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation.",
                "The graph also plots the total amount of data received and the amount of data a node receives from its parent.",
                "For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm.",
                "Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources.",
                "Bullets use of TFRC in this example ensures that the <br>overlay</br> is TCP friendly throughout.",
                "The average per-node control overhead is approximately 30 Kbps.",
                "By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system.",
                "Though the link stress can be different for each packet since each can take a different path through the <br>overlay</br> mesh, we average link stress due to each traced packet.",
                "For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22.",
                "The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client-Stub and Stub-Stub links.",
                "We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity.",
                "A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives.",
                "The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained.",
                "The distribution rises sharply starting at approximately 500 Kbps.",
                "The vast majority of nodes receive a stream of 500-600 Kbps.",
                "We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree. 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds. available bandwidth of the underlying topology.",
                "Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps.",
                "The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted.",
                "Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range.",
                "In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology.",
                "In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example).",
                "In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree.",
                "For all other topologies, Bullets benefits are somewhere in between.",
                "In our example, Bullet running over our medium-constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25%.",
                "Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bottleneck tree - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies. be extremely difficult for any online tree-based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information.",
                "For instance, we built a simple bandwidth optimizing <br>overlay</br> tree construction based on Overcast [21].",
                "The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm. 4.3 Creating Disjoint Data Bullets ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy.",
                "That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated.",
                "A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree.",
                "It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits.",
                "Figure 10 shows the resulting bandwidth over time for the non-disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links).",
                "Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance).",
                "By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7. 4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing.",
                "We implemented a form of gossiping, where a node forwards non-duplicate packets to a randomly chosen number of nodes in its local view.",
                "This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]).",
                "We do not disseminate packets every T seconds; instead we forward them as soon as they arrive. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission.",
                "We also implemented a pbcast-like [2] approach for retrieving data missing from a data distribution tree.",
                "The idea here is that nodes are expected to obtain most of their data from their parent.",
                "Nodes then attempt to retrieve any missing data items through gossiping with random peers.",
                "Instead of using gossiping with a fixed number of rounds for each packet, we use anti-entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items.",
                "To make our evaluation conservative, we assume that nodes employing gossip and anti-entropy recovery are able to maintain full group membership.",
                "While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti-entropy recovery that employs an underlying tree.",
                "Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc.",
                "To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10).",
                "For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead.",
                "In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system.",
                "To allow TFRC enough time to ramp up to the appropriate TCP-friendly sending rate, we set the epoch length for anti-entropy recovery to 20 seconds.",
                "For these experiments, we use a 5000-node INET topology with no explicit physical link losses.",
                "We set link bandwidths according to the medium range from Table 1, and randomly assign 100 <br>overlay</br> participants.",
                "The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti-entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping.",
                "Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches.",
                "As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti-entropy.",
                "The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node.",
                "More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w/AE raw Bullet raw Bullet useful Push gossiping useful Streaming w/AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches. width and the similarity ratio.",
                "Bullet, on the other hand, establishes long-term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each nodes peers. 4.5 Bullet on a Lossy Network To evaluate Bullets performance under more lossy network conditions, we have modified our 20,000-node topologies used in our previous experiments to include random packet losses.",
                "ModelNet allows the specification of a packet loss rate in the description of a network link.",
                "Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic.",
                "To effect this behavior, we first modify all non-transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3%.",
                "Transit links are likewise modified, but with a maximum loss rate of 0.1%.",
                "Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10%.",
                "Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree.",
                "Because losses adversely affect the bandwidth achievable over TCP-friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network.",
                "In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree.",
                "Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet. 4.6 Performance Under Failure In this section, we discuss Bullets behavior in the face of node failure.",
                "In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullets failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming.",
                "While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet - High Bandwidth Bullet - Medium Bandwidth Bottleneck tree - High Bandwidth Bottleneck tree - Medium Bandwidth Bullet - Low Bandwidth Bottleneck tree - Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology. disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage.",
                "Because Bullet, and, more importantly, RanSub makes use of an underlying tree <br>overlay</br>, part of Bullets failure recovery properties will depend on the failure recovery behavior of the underlying tree.",
                "For the purposes of this discussion, we simply assume the worst-case scenario where an underlying tree has no failure recovery.",
                "In our failure experiments, we fail one of roots children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started.",
                "By failing one of roots children, we are able to show Bullets worst-case performance under a single node failure.",
                "In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers.",
                "That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run.",
                "Figure 13 shows Bullets achieved bandwidth over time for this case.",
                "While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate.",
                "Next, we enable RanSub failure detection that recognizes a nodes failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test).",
                "In this case, the root simply initiates the next distribute phase upon RanSub timeout.",
                "The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions.",
                "As shown in Figure 14, the failure causes a negligible disruption in performance.",
                "With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data.",
                "Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestors failure.",
                "Hence, because Bullet is an <br>overlay</br> mesh, its reliability characteristics far exceed that of typical <br>overlay</br> distribution trees. 4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide-area network testbed.",
                "For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst-case node failure and no RanSub recovery. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst-case node failure and RanSub recovery enabled. our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site.",
                "Since there is currently ample bandwidth available throughout the PlanetLab <br>overlay</br> (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an <br>overlay</br> tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash-crowd.",
                "We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth.",
                "The node we selected was in Italy (cs.unibo.it) and we had 10 other <br>overlay</br> nodes in Europe.",
                "Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison.",
                "We ran Bullet over a random <br>overlay</br> tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps.",
                "We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree.",
                "We compare the performance of Bullet to data streaming over multiple handcrafted trees.",
                "Figure 15 shows our results for two such trees.",
                "The good tree has all nodes in Europe located high in the tree, close to the root.",
                "We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe. available bandwidth between the root and all other nodes.",
                "Nodes with high bandwidth measurements were placed close to the root.",
                "In this case, we are able to achieve a bandwidth of approximately 300 Kbps.",
                "The worst tree was created by setting the roots children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload.",
                "All subsequent levels in the tree were set in this fashion.",
                "For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics.",
                "As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case.",
                "A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. 5.",
                "RELATED WORK Snoeren et al. [36] use an <br>overlay</br> mesh to achieve reliable and timely delivery of mission-critical data.",
                "In this system, every node chooses n parents from which to receive duplicate packet streams.",
                "Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the <br>overlay</br> participants by sending disjoint data at each level.",
                "Further, during recovery from parent failure, it limits an <br>overlay</br> routers choice of parents to nodes with a level number that is less than its own level number.",
                "The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer-to-peer file swapping network.",
                "Kazaa nodes are organized into a scalable, hierarchical structure.",
                "Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it.",
                "Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet <br>overlay</br> structure.",
                "Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes. 294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet.",
                "It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file.",
                "The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file.",
                "Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date.",
                "Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns.",
                "Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source.",
                "FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs).",
                "In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node.",
                "To distribute the file, a node splits it into n equal-sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members.",
                "Since only a fixed portion of the file is transmitted along each of the <br>overlay</br> links, the impact of congestion is smaller than in the case of tree distribution.",
                "However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth <br>overlay</br> links in the system.",
                "Since it requires file store-and-forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high-bandwidth streaming.",
                "There are numerous protocols that aim to add reliability to IP multicast.",
                "In Scalable Reliable Multicast (SRM) [16], nodes multicast retransmission requests for missed packets.",
                "Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups.",
                "However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc. even when adaptive techniques are used.",
                "One recent study [2] shows that SRM may have significant overhead due to retransmission requests.",
                "Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP-multicast tree.",
                "In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets.",
                "A node that receives the digest responds to the sender with the missing packets in a last-in, first-out fashion.",
                "Lbpcast [14] addresses pbcasts scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node.",
                "The average size of the views is engineered to allow a message to reach all participants with high probability.",
                "Since lbpcast does not require an underlying tree for data distribution and relies on the push-gossiping model, its network overhead can be quite high.",
                "Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers.",
                "Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content.",
                "Further, a Bullet node splits the retransmission load between all of its peers.",
                "We note that pbcast nodes contain a mechanism to rate-limit retransmitted packets and to send different packets in response to the same digest.",
                "However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates.",
                "More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree.",
                "Narada [19] builds a delay-optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on <br>overlay</br> links.",
                "It then runs a standard routing protocol on top of the <br>overlay</br> mesh to construct forwarding trees using each node as a possible source.",
                "Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes.",
                "Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent.",
                "On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers.",
                "Overcast [21] is an example of a bandwidth-efficient <br>overlay</br> tree construction algorithm.",
                "In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth.",
                "Bullet is expected to be more resilient to node departures than any tree, including Overcast.",
                "Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers.",
                "This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters.",
                "Overcast convergence time is limited by probes to immediate siblings and ancestors.",
                "Bullet is able to provide approximately a target bandwidth without having a fully converged tree.",
                "In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination.",
                "It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34].",
                "The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single nodes sudden departure on the rest of the system.",
                "The join procedure can potentially sacrifice the interior-node-disjointness achieved by Scribe.",
                "Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe.",
                "To some extent, Bullet and SplitStream are complementary.",
                "For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe.",
                "CoopNet [29] considers live content streaming in a peerto-peer environment, subject to high node churn.",
                "Consequently, the system favors resilience over network efficiency.",
                "It uses a centralized approach for constructing either random or deterministic node-disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal-to-noise ratio perceived by receivers.",
                "In the case of on-demand streaming, CoopNet [30] addresses 295 the flash-crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content.",
                "Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system-wide distribution of the file. 6.",
                "CONCLUSIONS Typically, high bandwidth <br>overlay</br> data streaming takes place over a distribution tree.",
                "In this paper, we argue that, in fact, an <br>overlay</br> mesh is able to deliver fundamentally higher bandwidth.",
                "Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers.",
                "This paper presents the design and implementation of Bullet, a scalable and efficient <br>overlay</br> construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures.",
                "Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an <br>overlay</br> construction algorithm that creates a mesh over any distribution tree and allows <br>overlay</br> participants to achieve a higher bandwidth throughput than traditional data streaming.",
                "As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques. • We provide a technique for recovering missing data from peers in a scalable and efficient manner.",
                "RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants. • We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes. • A large-scale evaluation of 1000 <br>overlay</br> participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree.",
                "Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations.",
                "In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback. 7.",
                "REFERENCES [1] Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.",
                "Scalable Application Layer Multicast.",
                "In Proceedings of ACM SIGCOMM, August 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky.",
                "Bimodal Multicast.",
                "ACM Transaction on Computer Systems, 17(2), May 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom.",
                "Space/Time Trade-offs in Hash Coding with Allowable Errors.",
                "Communication of ACM, 13(7):422-426, July 1970. [5] Andrei Broder.",
                "On the Resemblance and Containment of Documents.",
                "In Proceedings of Compression and Complexity of Sequences (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost.",
                "Informed Content Delivery Across Adaptive <br>overlay</br> Networks.",
                "In Proceedings of ACM SIGCOMM, August 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege.",
                "A Digital Fountain Approach to Reliable Distribution of Bulk Data.",
                "In SIGCOMM, pages 56-67, 1998. [8] Ken Calvert, Matt Doar, and Ellen W. Zegura.",
                "Modeling Internet Topology.",
                "IEEE Communications Magazine, June 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh.",
                "Splitstream: High-bandwidth Content Distribution in Cooperative Environments.",
                "In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger.",
                "Towards Capturing Representative AS-Level Internet Topologies.",
                "In Proceedings of ACM SIGMETRICS, June 2002. [11] Ludmila Cherkasova and Jangwon Lee.",
                "FastReplica: Efficient Large File Distribution within Content Delivery Networks.",
                "In 4th USENIX Symposium on Internet Technologies and Systems, March 2003. [12] Reuven Cohen and Gideon Kaempfer.",
                "A Unicast-based Approach for Streaming Multicast.",
                "In INFOCOM, pages 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "To appear in ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec, and Petr Kouznetsov.",
                "Lightweight Probabilistic Broadcast.",
                "In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer.",
                "Equation-based congestion control for unicast applications.",
                "In SIGCOMM 2000, pages 43-56, Stockholm, Sweden, August 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne, and Lixia Zhang.",
                "A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing.",
                "IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.",
                "Multiple Description Coding: Compression Meets the Network.",
                "IEEE Signal Processing Mag., pages 74-93, May 2001. [18] Yang hua Chu, Sanjay Rao, and Hui Zhang.",
                "A Case For End System Multicast.",
                "In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan, and Hui Zhang.",
                "Enabling Conferencing Applications on the Internet using an <br>overlay</br> Multicast Architecture.",
                "In Proceedings of ACM SIGCOMM, August 2001. [20] Manish Jain and Constantinos Dovrolis.",
                "End-to-end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput.",
                "In Proceedings of SIGCOMM 2002, New York, August 19-23 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek, and Jr. James W. OToole.",
                "Overcast: Reliable Multicasting with an <br>overlay</br> Network.",
                "In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000. [22] Kazaa media desktop. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam, and Dong-Young Lee. 296 Optimal Distribution Tree for Internet Streaming Media.",
                "Technical Report TR-02-48, Department of Computer Sciences, University of Texas at Austin, September 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat.",
                "Using Random Subsets to Build Scalable Network Services.",
                "In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003. [25] Michael Luby.",
                "LT Codes.",
                "In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman, and Volker Stemann.",
                "Practical Loss-Resilient Codes.",
                "In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC 97), pages 150-159, New York, May 1997.",
                "Association for Computing Machinery. [27] Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe.",
                "Modeling TCP Throughput: A Simple Model and its Empirical Validation.",
                "In ACM SIGCOMM 98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu, and Helen J. Wang.",
                "Server-based Inference of Internet Link Lossiness.",
                "In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003. [29] Venkata N. Padmanabhan, Helen J. Wang, and Philip A. Chou.",
                "Resilient Peer-to-Peer Streaming.",
                "In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou, and Kunwadee Sripanidkulchai.",
                "Distributing Streaming Media Content Using Cooperative Networking.",
                "In ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe.",
                "A Blueprint for Introducing Disruptive Technology into the Internet.",
                "In Proceedings of ACM HotNets-I, October 2002. [32] R. C. Prim.",
                "Shortest Connection Networks and Some Generalizations.",
                "In Bell Systems Technical Journal, pages 1389-1401, November 1957. [33] Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat.",
                "MACEDON: Methodology for Automatically Creating, Evaluating, and Designing <br>overlay</br> Networks.",
                "Technical Report CS-2003-09, Duke University, July 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro, and Peter Druschel.",
                "SCRIBE: The Design of a Large-scale Event Notification Infrastructure.",
                "In Third International Workshop on Networked Group Communication, November 2001. [35] Stefan Savage.",
                "Sting: A TCP-based Network Measurement Tool.",
                "In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS-99), pages 71-80, Berkeley, CA, October 11-14 1999.",
                "USENIX Association. [36] Alex C. Snoeren, Kenneth Conley, and David K. Gifford.",
                "Mesh-Based Content Routing Using XML.",
                "In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP 01), October 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker.",
                "Scalability and Accuracy in a Large-Scale Network Emulator.",
                "In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002. 297"
            ],
            "original_annotated_samples": [
                "Bullet: High Bandwidth Data Dissemination Using an <br>overlay</br> Mesh Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, and Amin Vahdat∗ Department of Computer Science Duke University {dkostic,razor,albrecht,vahdat}@cs.duke.edu ABSTRACT In recent years, <br>overlay</br> networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet.",
                "Typically, nodes self-organize with the goal of forming an efficient <br>overlay</br> tree, one that meets performance targets without placing undue burden on the underlying network.",
                "For these applications, we argue that an <br>overlay</br> mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures.",
                "This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self-organize into a high bandwidth <br>overlay</br> mesh.",
                "Key contributions of this work include: i) an algorithm that sends data to different points in the <br>overlay</br> such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large-scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances."
            ],
            "translated_annotated_samples": [
                "En los últimos años, las <br>redes superpuestas</br> se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet.",
                "Normalmente, los nodos se autoorganizan con el objetivo de formar un <br>árbol de superposición</br> eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente.",
                "Para estas aplicaciones, sostenemos que una <br>malla superpuesta</br>, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas.",
                "Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla <br>superpuesta</br> de alta capacidad de ancho de banda.",
                "Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la <br>superposición</br> de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias."
            ],
            "translated_text": "En los últimos años, las <br>redes superpuestas</br> se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un <br>árbol de superposición</br> eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una <br>malla superpuesta</br>, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla <br>superpuesta</br> de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la <br>superposición</br> de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. ",
            "candidates": [],
            "error": [
                [
                    "redes superpuestas",
                    "árbol de superposición",
                    "malla superpuesta",
                    "superpuesta",
                    "superposición"
                ]
            ]
        }
    }
}